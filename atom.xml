<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SplendidWave&#39;Blog</title>
  
  <subtitle>灿 烂 的 波</subtitle>
  <link href="https://splendidwave.github.io/atom.xml" rel="self"/>
  
  <link href="https://splendidwave.github.io/"/>
  <updated>2023-05-05T12:03:42.626Z</updated>
  <id>https://splendidwave.github.io/</id>
  
  <author>
    <name>splendidwave</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>电动汽车选配指南--以比亚迪为例</title>
    <link href="https://splendidwave.github.io/2023/04/28/2023-4/%E7%94%B5%E5%8A%A8%E6%B1%BD%E8%BD%A6%E9%80%89%E9%85%8D%E6%8C%87%E5%8D%97--%E4%BB%A5%E6%AF%94%E4%BA%9A%E8%BF%AA%E4%B8%BA%E4%BE%8B/"/>
    <id>https://splendidwave.github.io/2023/04/28/2023-4/%E7%94%B5%E5%8A%A8%E6%B1%BD%E8%BD%A6%E9%80%89%E9%85%8D%E6%8C%87%E5%8D%97--%E4%BB%A5%E6%AF%94%E4%BA%9A%E8%BF%AA%E4%B8%BA%E4%BE%8B/</id>
    <published>2023-04-28T08:57:01.000Z</published>
    <updated>2023-05-05T12:03:42.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>随着清洁能源技术的不断进步和国家政策的推动，越来越多的年轻用户选择科技感更强的电动汽车。比起以往的燃油车，电动汽车更像是一种能够移动的电子设备，其日新月异的新技术也使得许多老车主纷纷表示被“背刺”了。本文将以科普的角度，简要介绍电动汽车的分类、结构。并以比亚迪的汉EV千山翠限量版和宋PLUSDM-i为例介绍展开介绍。</p><p>注：本文主要介绍汽车的一些原理和名词解释，并拿了市面上销量较好的比亚迪举例子，并无消费导向，大家根据实际需求购买（除非byd给我打广告费）。</p><span id="more"></span><h2 id="明确需求">1.明确需求</h2><h3 id="电动车和燃油车的区别">1.1 电动车和燃油车的区别</h3><p>目前选购一辆代步车大部分人会在燃油车和新能源车中纠结一下。为此需要了解两者的异同才能更好地做出抉择。</p><p>传统燃油车是由如下几个部分组成 -车身主体：汽车的车身结构大部分由高强度材料组成，起到支撑车体和保护驾驶员安全的作用。部分车型会将前后车身做得偏软，发生碰撞可以用来缓冲防止行人或他车车主受到伤害。-发动机：发动机是汽车的心脏部分，它将燃油的化学能转化为机械能，驱动汽车前进，由于发动机开始工作时需要进气引导，工作过程中需要不停点火，所以燃油车会配上一块蓄电池用于提供这部分所需能量。-传动装置：传动轴和齿轮将发动机产生的动力传递到车轮，从而使车辆运动，同时它可以利用齿轮组的传动比将发动机的高速低扭转化为车轮的低速高扭。由于传动杆的存在，我们可以看见车子中轴线会存在一条凸起。-悬架系统：悬架又称底盘，它起到了支撑车身重量，并减缓路面的颠簸和震动，控制转弯等功能。-控制系统：车子的控制主要分为机械控制和电子控制两部分，用于辅助驾驶员控制汽车，通常以方向盘、踏板、机械开关或者车机交互的方法实现。</p><p>相比之下，电动汽车主要的改动点就在于采用电动机代替了发动机再搭载一块大电池，电机的效率更高更节能。它在低速状态下可以输出极大的扭矩，而且不需要排放尾气。这也是国家大力推动新能源汽车发展的重要原因之一。</p><h3 id="油电混动车型">1.2 油电混动车型</h3><p>但新能源汽车发展早期存在电池技术不成熟，充电桩寻找困难、充电速度慢等问题，再加上BBA（宝马、奔驰、奥迪）和日系合资车的社会认可度更高，导致电动车选购率低，就算是选择新能源车也会选择混动类型的。</p><p>混动类型可以分为如下三种： -增程式：增程式是指内燃机只负责发电，不需要考虑驱动车辆，燃油只负责增加行驶路程的功能。-插电混合：插电混动是指既可以随意使用电机又可以使用发动机驱动，它解决了电池充电慢，远距离续航不足的问题，会受到更多人的青睐。-油电混合：油电混动是指车子在行驶过程中同时使用电和油，它结合了电车起步快和油车行驶稳定的优势，这种类型因为还是会排放大量尾气所以通常不被上绿牌不享受新能源政策，只是相当于一个省油的油车。</p><p>纯电车是完全依赖电池行驶，虽然会有里程焦虑但是电车的养护成本会比油车低很多。</p><h3 id="如何选取">1.3 如何选取</h3><p>在选购车子的时候可以根据如下3点进行判断。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/05/20230505171127.png"alt="选车" /><figcaption aria-hidden="true">选车</figcaption></figure><p>主要还是根据使用场景进行选购，决定好买油车还是电车后再结合预算要SUV、轿车、越野车还是跑车就可以将购车范围缩小到几种车，然后针对性地去4s店看车和试驾。如果对自己使用需求不明确或者对外观要求较高的，可以先去车展看看效率比较高。一般来说选择市场认可度比较高的会更有保障，真出问题了也可以联合更多人去找厂商的问题。</p><p>接下来针对一些细节结构进行展开介绍。</p><h2 id="车身尺寸">2.车身尺寸</h2><h3 id="车柱与轴距">2.1 车柱与轴距</h3><p>车身承担了兼具实用（保护驾驶员安全）和美观（车型外观）两个重要因素。下图标注了聊车身经常会提到的几个名词指代的位置，如A柱、B柱、轴距。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/04/20230425202425.png"alt="车柱" /><figcaption aria-hidden="true">车柱</figcaption></figure><p>这张图中位于上方的车就是轿车，位于下方的则是SUV。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/04/20230425202640.png"alt="轴距" /><figcaption aria-hidden="true">轴距</figcaption></figure><p>根据轴距可以将车分为如下几个类型，下表只是一个参考标准，级别没有明确的定义。</p><table><thead><tr class="header"><th>级别</th><th>定义</th><th>轴距范围</th></tr></thead><tbody><tr class="odd"><td>A0级</td><td>微型车</td><td>≤ 2,490 mm</td></tr><tr class="even"><td>A级</td><td>小型车</td><td>2,491 mm - 2,700 mm</td></tr><tr class="odd"><td>B级</td><td>中型车</td><td>2,701 mm - 2,900 mm</td></tr><tr class="even"><td>C级</td><td>大型车</td><td>≥ 2,901 mm</td></tr></tbody></table><p>轴距越大乘坐体验就会越舒适，但对司机的驾驶要求会相对提升一些，中国老百姓普遍喜欢买大一些的车，显得气派。千山翠的是轴距在2920，车长4995，属于是B和C之间，但因为它后备箱空间不是很大所以后排体验是有C级车的标准的，后座使用的是隐私玻璃，定位也是商务车的定位。宋plus轴距是2765属于是中型的SUV。</p><h3 id="车漆">2.2 车漆</h3><p>汽车的车漆是车身保护和美观的关键组成部分。通常认为原厂的车漆要比后补的更好，尤其是像千山翠这类特制车漆，会比同配置的汉EV四驱版贵上两万，同时刮蹭后补漆价格也会更高。</p><p>对于轻微刮痕通常处理方法有，不处理、车漆笔、抛光等操作，如果刮痕比较深或者涉及到较大的区域，可能需要进行磨砂和补漆处理。</p><p>车漆的保护方法有定期洗车、避免太阳直射、车衣、镀晶/镀膜等。</p><h2 id="动力系统">3.动力系统</h2><h3 id="电机类型">3.1 电机类型</h3><p>目前电机主流使用的是以特斯拉为首的交流异步电机和以比亚迪为老大的永磁同步电机。</p><p>交流异步电机(Asynchronous AC Motor, AC InductionMotor)的工作原理是通过交流电源产生的旋转磁场诱导出转子中的电流，由于转子电流在磁场作用下会产生转矩，从而驱动转子旋转。然而，由于转子电流的产生和变化需要一定的时间，因此转子的旋转速度不能完全跟随旋转磁场的频率，产生了一定的转速差，因此被称为“异步”。</p><p>永磁同步电机(Permanent Magnet Synchronous Motor,PMSM)的转子由永磁体组成，永磁体的磁场与定子磁场相互作用，从而使转子转动。为了使永磁同步电机能够稳定运行，其定子的磁场必须保持同步旋转，这需要通过控制定子的电流和频率来实现</p><p>千山翠使用的是交流永磁同步电机(Permanent Magnet Synchronous Motorwith ACDrive)。这是一种结合了永磁同步电机和交流异步电机的特点的电机。它的转子由永磁体组成，因此具有永磁同步电机的高效率、高功率密度和响应速度快的特点。同时，它的定子采用交流异步电机的设计，可以通过变频器来控制其电流和频率，从而实现精确的转速控制和调节。</p><p>宋plus是插电类型的车，使用的是比亚迪自研的骁云-插混专用发动机，相对来说技术上还是比较有优势的。</p><h3 id="电机的指标">3.2 电机的指标</h3><p>电机性能的参数通常包括以下几个方面：</p><p>额定功率和额定转速：电机额定功率和额定转速是电机性能的基本参数，通常在电机铭牌上标明。额定功率是指电机在额定转速下所能输出的最大功率，单位为千瓦（kW）；额定转速是指电机在额定电压、额定电流下所能达到的转速，单位为转每分钟（rpm）。</p><p>转矩和转速曲线：电机的转矩和转速曲线反映了电机输出功率的变化规律，也是电机性能的重要参数。转矩和转速曲线通常以图表形式表示，可以用于评估电机在不同负载下的输出能力和效率。</p><p>效率：电机的效率是指电机输出功率与输入功率之比，通常以百分比表示。电机的效率直接关系到电机的能耗和工作效率，是评估电机性能的重要指标。</p><p>功率因数：电机的功率因数是指电机输出功率与电机视在功率之比，通常以小数形式表示。功率因数反映了电机的电能利用效率，高功率因数的电机能够降低电网负荷和能耗。</p><p>但通常汽车动力性能中标注的是最大功率和最大扭矩。越大说明汽车动力越足。</p><h3 id="驱动类型">3.3 驱动类型</h3><p>驱动类型通常指汽车的动力传动方式，主要分为前驱、后驱和四驱三种类型。</p><p><strong>前驱</strong>是指汽车动力由发动机传输到前轮驱动，通过前轮驱动车辆前部的重心提供更好的牵引力和稳定性。前驱车型通常比较节省油耗和制造成本，但在高速行驶时会出现轻微的转向不稳定和过弯时的欠稳定性。</p><p><strong>后驱</strong>是指汽车动力由发动机传输到后轮驱动，通过后轮驱动车辆后部的重心提供更好的牵引力和操控性。后驱车型通常有更好的平衡性和操控性，但在低摩擦路面上的牵引能力相对较差。</p><p><strong>四驱</strong>是指所有车轮都有动力输出，通过动力分配系统将动力传递到不同的车轮，以提供更好的牵引和操控性能。四驱车型通常适用于路况复杂、陡坡、泥泞等恶劣路况下行驶，但相对于前驱和后驱车型，制造成本和油耗较高。</p><p>不同驱动类型的汽车有各自的优缺点，在购买时需要根据自己的需求和用途进行选择。</p><h3 id="续航里程">3.4 续航里程</h3><p>在国内续航里程通常是按工信部制定的国家标准进行测评，其中最常用的标准为CLTC（ChinaLight-Duty Test Cycle）。</p><p>CLTC是一种基于欧盟NEDC（New European DrivingCycle）标准进行修改和优化的测试循环。CLTC包括两个部分：低速城市循环和高速公路循环，其中低速城市循环主要测试低速、停车、加速和制动等行驶状态，高速公路循环主要测试高速巡航状态。</p><p>在CLTC标准下，电动车续航里程的测量通常是在室温（20℃~30℃）下进行，电池充满电的情况下，以模拟真实驾驶情况，按照标准测试循环进行测试，最终得出一个标准化的续航里程数值。</p><p>除了里程外还需要关注的是汽车的电车容量和充电时间，一般在高速上跑和在冬天跑都会使续航里程打折，而且一般电车不会将电全部用完，在估算续航时都需要考虑在内。</p><h2 id="制动及悬架系统">4.制动及悬架系统</h2><h3 id="制动类型">4.1 制动类型</h3><p>制动类型主要有两类，一类是盘式制动，一类是鼓式制动。</p><p>盘式制动是通过刹车片钳住制动盘来实现制动，刹车片通常会听到brembo这个牌子，这是一个意大利牌子，以其制造高品质刹车和离合器组件而闻名于世界。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/04/20230428124054.png"alt="盘式制动" /><figcaption aria-hidden="true">盘式制动</figcaption></figure><p>鼓式制动也是利用摩擦制动，不同的是它使用圆柱形的鼓式制动器来刹车，但这种方法因为散热问题，稳定性不如盘式，其复杂结构也会导致高故障率。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/04/20230428124700.png"alt="鼓式制动" /><figcaption aria-hidden="true">鼓式制动</figcaption></figure><p>主流还是盘式用的比较多，千山翠用的是比亚迪自研的通风打孔盘式，作为自己调教的刹车片，会更适合自家的车型。</p><h3 id="悬架">4.2 悬架</h3><p>悬架系统主要由弹簧、减震器、连接杆等部件组成，起到提高了车辆的稳定性和驾驶舒适性等功能。独立悬架是目前主流的悬架形式，它能够独立支撑每个车轮，提高了车辆的操控性和行驶稳定性。通常按连杆类型又可以分为如下几种：</p><ul><li>麦弗逊悬架：麦弗逊悬架适用于大多数前驱车和后驱车的前悬架，其结构简单、可靠性高、成本低，是目前最常见的悬架类型之一。但它的行程比较受限而且对侧向受力化解比较乏力。</li><li>双连杆悬架：双连杆使用了两个控制臂来支撑和控制车轮，会比麦弗逊操控性更强。</li><li>多连杆悬架：三连杆、四连杆、五连杆都统称多连杆，多连杆悬架还可以提供更高的悬挂行程和更优秀的悬架响应，但其成本和车辆重量也会随之提升。</li></ul><p>主动悬架可以根据车辆运动和路况状况实时调整悬架系统的硬度、行程和其他参数，从而提高车辆的驾驶稳定性和悬架性能。需要软件和硬件相互配合实现，比亚迪的<ahref="https://www.bilibili.com/video/BV1wv4y1H7Zv/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">云辇</a>技术就是一个典型。</p><p>千山翠使用的是千麦弗逊后多连杆，在22款的低配汉ev车型中使用的是铁制连杆，所以被网友戏称“筷子悬挂”，在23款比亚迪就将底盘换成了铝合金了。</p><h3 id="轮胎">4.3 轮胎</h3><p>汽车轮胎直接与路面接触，承受着汽车的重量和各种力量，影响着汽车的操控性能、安全性能和舒适性能。比较出名的公司就是米其林。</p><p>轮胎标注一般会提供断面宽度(指轮胎正面的宽度)、扁平比(截面高度与截面宽度的比值)、尺寸(轮胎的内径)信息。其中扁平比可以会比较难理解，通俗来说较低的扁平比通常意味着高车辆的操控性和响应速度，但可能会牺牲一些乘坐舒适性。较高的扁平比则意味着轮胎的侧壁更高，对路面的减震效果更好，但可能会降低车辆的操控性。</p><p>千山翠的轮胎规格标注是245/45R19表示这是一款断面宽度为245毫米、扁平比为45%、结构类型为径向轮胎，适合安装在直径为19英寸的轮毂上的轮胎。千山翠的轮胎是米其林和固特异混发的，两者区别倒是不是很大。</p><h2 id="控制与辅助系统">5.控制与辅助系统</h2><p>这里列一下千山翠的一些控制辅助系统，因为是比亚迪王朝系列的顶配，基本市面上有的计算都加装了，需要的可以自行搜索阅读，没需求的可以直接跳过。</p><ul><li>自适应巡航控制（Adaptive CruiseControl，ACC）：一种智能驾驶辅助系统，能够通过雷达或激光等技术实现车辆的自动跟车和自动减速，使驾驶者在高速公路等道路上行驶更加轻松和安全。</li><li>智能车距控制（Intelligent CruiseControl，ICC）：也是适应巡航控制（Adaptive CruiseControl）系统的一种，除了保持与前车的安全距离外，还可以自动减速或停车以避免追尾事故的发生，相比之下更加智能。</li><li>交通拥堵辅助系统（Traffic Jam Assist,TJA）：是一种智能驾驶辅助系统，主要用于缓解城市拥堵时的驾驶压力，提高行驶安全性。</li><li>前方碰撞预警系统（Forward Collision Warning,FCW）：是一种车辆安全辅助系统，主要用于预警驾驶员前方可能发生的碰撞风险，以避免或减轻碰撞事故的后果。</li><li>自动紧急制动系统（Automatic Emergency Braking,AEB）：是一种紧急制动系统，通常和交通标志识别系统（Camera-based TrafficSign Recognition, CCR）和行人车辆识别系统（Vulnerable RoadUsers，VRU）联合使用。</li><li>紧急制动辅助系统（Emergency Brake Assist,EBA）：是一种汽车安全辅助系统，可以帮助驾驶员在紧急制动时更快更稳地停车，从而减少事故的发生。通常与ESP（电子稳定控制系统）和ABS（防抱死制动系统），以提高车辆的稳定性和安全性。</li><li>紧急制动信号系统（Emergency Stop Signal,ESS）：是一种汽车安全辅助系统，可以在紧急制动时自动闪烁制动灯，以提醒后方车辆注意。</li><li>车道偏离警示系统（Lane Departure Warning System,LDWS）：是一种车辆安全辅助系统，用于提醒驾驶员车辆偏离了车道。</li><li>车道保持系统（Lane Keeping System,LKS）：是一种车辆安全辅助系统，可以帮助驾驶员在车辆行驶过程中保持在正确的车道内。</li><li>智能远近光灯系统（Headlamp Matrix System,HMA）:是一种基于车辆摄像头和电子控制单元的智能车灯系统。</li><li>道路交通标志识别系统（Traffic Sign Recognition System,TSR）：是一种智能驾驶辅助系统，可以自动识别道路上的交通标志并显示在驾驶员的仪表盘上，帮助驾驶员更好地了解当前行驶状态和交通规则。</li><li>高速公路辅助驾驶系统（Highway Assist,HWA）：是一种智能驾驶辅助系统，可以在高速公路上为驾驶员提供自动加速、减速、转向和车道保持等功能，从而降低驾驶员的疲劳度和驾驶风险，提高驾驶舒适性和安全性。</li><li>交互式变道辅助系统（ILCA）：是一种智能驾驶辅助系统，又称拨杆变道辅助，在车速60-130km/h范围内，开启智能领航模式下，用户只需拨动转向拨杆，系统便会在确保安全前提下自动控制车辆变道。</li><li>前方交通穿行提示系统（Front Cross Traffic Alert,FCTA）：是一种车辆安全辅助系统，可用于检测和提示车辆前方横穿路口或停车位存在车辆或行人。同理还有后方交通穿行提示（RCTA）。</li><li>紧急车道保持辅助（Emergency Lane Keeping Assist,ELKA）：是一种智能辅助驾驶系统，当汽车发生意外偏离车道后,会发出提醒并通过制动或转向等手段停入紧急车道。</li><li>盲点监测系统（Blind Spot Detection,BSD）：是一种车辆驾驶辅助系统，可以帮助驾驶员检测车辆侧后方的盲区，以便更好地掌握交通状况和避免潜在的碰撞事故。</li><li>开门预警：打开门时如果后方有来车或来人会提示。</li><li>3D全息透明影像：这个功能非常的方便，特别是过窄路和停车的时候，新手或者车感不好的人一定要配一个。</li><li>遥控驾驶：用手机app可以遥控汽车。</li></ul><h2 id="购车流程和注意事项">6.购车流程和注意事项</h2><p>看车（4s店/车展）--&gt; 试驾（需要驾驶证） --&gt;谈价格（可以留意优惠和政府补贴） --&gt; 付定金 --&gt; 提车（!）</p><p>价格方面油车可能更容易打一些，而且挑淡季去谈优惠幅度会很大。比亚迪的价格是全国统一的，没法谈，只能多要点4s店的优惠。如果选购的是新能源车，23年是免购置税的，可能还会接着延长。其次国家的新能源车补贴是没有了，但地方政府的补贴还会不定期发放。其次买车还需要上牌费和保险之类的，会比裸车价高出一些。基本上想拿到一个比较优惠的价格就多去几家4s店。</p><p>提车这里需要注意的事项会比较多。特别是车子质量要仔细检查漆面是否有问题，轮胎和玻璃型号，发动机，排气口里程数之类的。如果发现小问题可以让4S店适当补偿。然后合同上价格明细和赠送要全部备注清楚。尽量在4S店买车在流程上会更有保障，其次要等保险生效后再把车开回家。</p><p>最后祝各位都能顺利喜提爱车。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;随着清洁能源技术的不断进步和国家政策的推动，越来越多的年轻用户选择科技感更强的电动汽车。比起以往的燃油车，电动汽车更像是一种能够移动的电子设备，其日新月异的新技术也使得许多老车主纷纷表示被“背刺”了。本文将以科普的角度，简要介绍电动汽车的分类、结构。并以比亚迪的汉EV千山翠限量版和宋PLUS
DM-i为例介绍展开介绍。&lt;/p&gt;
&lt;p&gt;注：本文主要介绍汽车的一些原理和名词解释，并拿了市面上销量较好的比亚迪举例子，并无消费导向，大家根据实际需求购买（除非byd给我打广告费）。&lt;/p&gt;</summary>
    
    
    
    <category term="文化娱乐" scheme="https://splendidwave.github.io/categories/%E6%96%87%E5%8C%96%E5%A8%B1%E4%B9%90/"/>
    
    <category term="逻辑与科普" scheme="https://splendidwave.github.io/categories/%E6%96%87%E5%8C%96%E5%A8%B1%E4%B9%90/%E9%80%BB%E8%BE%91%E4%B8%8E%E7%A7%91%E6%99%AE/"/>
    
    
    <category term="科普" scheme="https://splendidwave.github.io/tags/%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>C语言复习-进阶篇</title>
    <link href="https://splendidwave.github.io/2023/04/23/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    <id>https://splendidwave.github.io/2023/04/23/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E8%BF%9B%E9%98%B6%E7%AF%87/</id>
    <published>2023-04-23T08:02:01.000Z</published>
    <updated>2023-05-05T10:55:39.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>复习一下C语言的进阶应用。</p><p>基础篇：<ahref="https://splendidwave.github.io/2023/04/22/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E5%9F%BA%E7%A1%80%E7%AF%87/">C语言复习-基础篇</a></p><span id="more"></span><h2 id="内存管理">1.内存管理</h2><p>在C语言中，程序内存可以分为代码段、数据段、堆区(stack)和栈区(heap)。</p><h3 id="代码段">1.1 代码段</h3><p>代码段也称为文本段，是存储程序代码的区域，通常是只读的，且不允许在程序运行时进行修改。在程序执行时，代码段中的指令被复制到处理器中执行。</p><h3 id="数据段">1.2 数据段</h3><p>数据段是存储静态变量和全局变量的区域，包括已初始化和未初始化的变量。已初始化的变量在编译时就被赋初值，而未初始化的变量在程序运行时会被初始化为0或空指针。数据段也是只读的，不允许在程序运行时进行修改。</p><h3 id="堆区">1.3 堆区</h3><p>堆区是程序运行时动态分配内存的区域，通过malloc、realloc等函数来申请和释放内存。堆区的大小是在程序运行时动态变化的，因此需要开发者自行管理内存的分配和释放，这种相信程序员的方法带来方便的同时也会带来风险。</p><p>堆区是由操作系统进行管理的，当申请内存时，操作系统会在堆区中分配一块连续的空间，并返回一个指向该空间的指针。释放内存时，操作系统将该空间标记为可用，并将其返回给堆区。</p><h4 id="malloc函数">1.3.1 malloc函数</h4><p>malloc函数用来动态地分配指定字节数的内存空间，如果分配成功，则返回一个指向分配内存的指针，否则返回空指针。malloc函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>其中，size_t是一个无符号整数类型，表示要分配的内存字节数。如果调用成功，则返回一个指向分配内存的指针；否则返回空指针。void类型不能定义变量但是可以定义指针，这是一个指针函数。</p><h4 id="realloc函数">1.3.2 realloc函数</h4><p>realloc函数用来重新分配内存空间的大小，可以用来扩大或缩小原有的内存空间。如果成功，则返回指向新分配内存的指针，否则返回空指针。realloc函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>其中，ptr是一个指向原有内存的指针，size是新的内存大小。如果调用成功，则返回一个指向新分配内存的指针；否则返回空指针。</p><h4 id="free函数">1.3.3 free函数</h4><p>free函数用来释放已经分配的内存空间。free函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><p>其中，ptr是指向要释放的内存空间的指针。使用free函数时需要注意，必须传递给它一个之前由malloc或realloc函数返回的指针，否则会出现内存泄漏的问题。</p><h3 id="栈区">1.4 栈区</h3><p>栈区是用于存储局部变量、函数参数和函数返回地址等信息的区域，是由编译器自动管理的。每当一个函数被调用时，该函数的参数和局部变量就会被存储在栈区中。栈区是一个先进后出的结构，当一个函数返回时，该函数的所有局部变量和参数就会被弹出栈区。栈区的大小通常是固定的，但可以通过编译器选项进行调整。</p><p>需要注意的是，堆区和栈区的内存都属于虚拟内存范畴，具体的内存分配和管理是由操作系统进行管理的。在使用堆区和栈区时，需要注意内存的使用情况和分配方式，以避免内存泄漏和野指针等问题。</p><h2 id="函数指针">2.函数指针</h2><p>函数指针是指可以存储函数地址的变量，通过函数指针，可以动态地调用不同的函数，实现程序的灵活性和可扩展性。</p><h3 id="普通函数指针">2.1 普通函数指针</h3><p>函数指针的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*fptr)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>这个函数指针可以用来存储指向接受两个 int 类型参数并返回 int类型结果的函数的地址。</p><h3 id="回调函数">2.2 回调函数</h3><p>回调函数指被传递给另一个函数，并由另一个函数在需要时调用的函数。回调函数通常用于事件处理、错误处理和异步通信等任务中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">callback</span><span class="params">(<span class="type">int</span> result)</span><span class="comment">//定义回调函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_something</span><span class="params">(<span class="type">int</span> (*fptr)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">void</span> (*callback)(<span class="type">int</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = fptr(x, y);</span><br><span class="line">    callback(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    do_something(add, <span class="number">3</span>, <span class="number">4</span>, callback);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序在主函数中，我们调用 do_something 函数，传递 add函数的地址、两个整数和回调函数的地址。do_something 函数调用 add函数，并将结果传递给回调函数。回调函数的好处在于，它可以将程序的控制权交给另一个函数，使程序更加灵活和可扩展。</p><h3 id="函数指针作为成员">2.3 函数指针作为成员</h3><p>函数指针数组是指一个数组，其中的每个元素都是一个指向函数的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*fptr_arr[<span class="number">3</span>])(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>这个函数指针数组可以用来存储指向三个不同的函数的地址，这些函数都接受两个int 类型参数并返回 int 类型结果。</p><p>另一个做法是将函数指针放入结构体中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*fptr)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> <span class="title">s</span>;</span></span><br><span class="line">    s.fptr = add;</span><br><span class="line">    <span class="type">int</span> result = s.fptr(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>my_struct 结构体包含一个指向 int 类型函数的指针fptr。在主函数中，我们将 add 函数的地址存储到结构体的 fptr成员中，然后使用结构体中的 fptr 成员调用 add 函数。</p><p>另外函数指针还可以应用于动态加载库和多态性，这部分内容可能更偏向于C++这里先不展开。</p><h2 id="多文件程序">3.多文件程序</h2><p>一个工程通常将程序代码分布在多个文件中，以便于代码的组织、维护和共享。C语言中通常包括的是头文件（.h文件）和源文件（.c 文件）。</p><p>头文件定义了函数的原型和常量等信息，供其他文件引用。通常包含#ifndef、#define 和 #endif 三个预处理指令来防止头文件被重复引用。</p><p>源文件包含函数的实现代码，多个源文件可以通过头文件来共享函数的定义，从而实现模块化的程序设计。下面给出头文件中通常包含的一些内容。</p><h3 id="标准库函数">3.1 标准库函数</h3><p>下面列举了一些C标准库中常用的函数：</p><ul><li>stdio.h：输入输出函数，包括文件操作函数、格式化输入输出函数、字符输入输出函数等。</li><li>string.h：字符串操作函数，包括字符串复制函数、字符串连接函数、字符串比较函数等。</li><li>math.h：数学函数，包括三角函数、指数函数、对数函数、幂函数等。</li><li>time.h：日期和时间函数，包括获取当前时间函数、时间格式化函数、计时函数等。</li><li>stdlib.h：常用的函数，包括动态内存分配函数、字符串转换函数、系统调用函数等。</li><li>ctype.h：字符处理函数，包括字符分类函数、字符转换函数等。</li><li>assert.h：调试宏，用于在程序中检查错误和异常情况。</li><li>errno.h：错误码定义，用于表示函数执行过程中的错误信息。</li></ul><h3 id="宏定义">3.2 宏定义</h3><p>宏定义是C语言中常用的一种预处理指令，用于在编译时将某些代码段替换为指定的文本内容。标准语法为<code>#define 宏名 替换文本</code>其中，宏名是用户自定义的宏名称，替换文本是指在编译时需要替换的文本内容。当程序中出现该宏名称时，编译器会将其替换为指定的文本内容，从而达到代码重用的效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="type">double</span> radius = <span class="number">10.0</span>;</span><br><span class="line"><span class="type">double</span> area = PI * radius * radius;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> max = MAX(a, b);</span><br></pre></td></tr></table></figure><p>宏定义并非真正意义上的函数调用，而是将代码中的某些部分替换为指定的文本内容。因此，在使用宏定义时，需要特别注意其替换内容是否合法，以及是否会产生意料之外的副作用。</p><h2 id="数据结构">4.数据结构</h2><p>这里只给出简约版提供复习用。</p><h3 id="链表">4.1 链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">// 节点数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedList</span> &#123;</span></span><br><span class="line">    Node* head;         <span class="comment">// 头结点指针</span></span><br><span class="line">    Node* tail;         <span class="comment">// 尾结点指针</span></span><br><span class="line">    <span class="type">int</span> length;         <span class="comment">// 链表长度</span></span><br><span class="line">&#125; LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(LinkedList* <span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈">4.2 栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *data; <span class="comment">// 存储栈元素的数组</span></span><br><span class="line">    <span class="type">int</span> top;   <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="type">int</span> size;  <span class="comment">// 栈的大小</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈的初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(Stack *s, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    s-&gt;data = (<span class="type">int</span> *) <span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    s-&gt;size = size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个栈可以实现动态分配内存。</p><h3 id="队">4.3 队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_QUEUE_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_QUEUE_SIZE];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(Queue *q)</span> &#123;</span><br><span class="line">    q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    q-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树">4.4 树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义二叉树节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;复习一下C语言的进阶应用。&lt;/p&gt;
&lt;p&gt;基础篇：&lt;a
href=&quot;https://splendidwave.github.io/2023/04/22/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E5%9F%BA%E7%A1%80%E7%AF%87/&quot;&gt;C语言复习-基础篇&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90/"/>
    
    
    <category term="嵌入式开发" scheme="https://splendidwave.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="C语言" scheme="https://splendidwave.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言复习-基础篇</title>
    <link href="https://splendidwave.github.io/2023/04/22/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>https://splendidwave.github.io/2023/04/22/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2023-04-22T08:02:01.000Z</published>
    <updated>2023-05-05T10:56:53.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>简单复习一下C语言。</p><p>进阶篇：<ahref="https://splendidwave.github.io/2023/04/23/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E8%BF%9B%E9%98%B6%E7%AF%87/">C语言复习-进阶篇</a></p><span id="more"></span><h2 id="c程序的构成">1.C程序的构成</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> <span class="comment">//头文件、预处理</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;      <span class="comment">//定义主函数（主函数只能有一个）</span></span><br><span class="line">  <span class="comment">//定义变量（C语言的变量要定义后才能使用）</span></span><br><span class="line">  <span class="comment">//程序主体</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello word\n&quot;</span>); <span class="comment">//输出结果（每一行结束都要有分号）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译过程：源程序(.c)--编译--&gt;目标程序(.obj)--链接--&gt;可执行程序(.exe)</p><h2 id="关键字">2.关键字</h2><p>大部分内容参考自知乎文章<ahref="https://zhuanlan.zhihu.com/p/37908790">C语言中32个关键字详解</a></p><h3 id="基本数据类型5个">2.1 基本数据类型（5个）</h3><p>注：括号内字节数指在32位arm处理器下</p><ul><li>void：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果</li><li>char：字符型类型数据，属于整型数据的一种（1个字节）</li><li>int：整型数据，通常为编译器指定的机器字长(4个字节)</li><li>float：单精度浮点型数据，属于浮点数据的一种(4个字节)</li><li>double：双精度浮点型数据，属于浮点数据的一种（8个字节）</li></ul><p>注：C中没有string类型，要使用需要头文件里定义<code>#include&lt;string.h&gt;</code>,C++里的定义是<code>#include&lt;string&gt;</code>，字符串的结尾为<code>'\0'</code></p><p>注：指针都是4个字节</p><h3 id="修饰关键字4个">2.2 修饰关键字（4个）</h3><ul><li>short：修饰int，短整型数据，可省略被修饰的int（2个字节）</li><li>long：修饰int，长整形数据，可省略被修饰的int（4个字节 long long8个字节）</li><li>signed：修饰整型数据，有符号数据类型</li><li>unsigned：修饰整型数据，无符号数据类型</li></ul><h3 id="复杂类型关键字5个">2.3 复杂类型关键字（5个）</h3><ul><li>struct：结构体声明 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义数据类型，一些类型集合组成的一个类型</span></span><br><span class="line"><span class="comment">//语法   struct 类型名称  &#123;成员列表&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//分数</span></span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;s3;</span><br></pre></td></tr></table></figure></li><li>union：共用体声明 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个联合变量（共用体）的长度等于各成员中最长的长度</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">StateMachine</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> character;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="type">char</span> *str;</span><br><span class="line"><span class="type">double</span> <span class="built_in">exp</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//StateMachine 的空间大小就是double 数据类型的大小</span></span><br><span class="line"><span class="comment">//在C++里，union 的成员默认属性页为public。</span></span><br><span class="line"><span class="comment">//union 主要用来压缩空间。如果一些数据不可能在同一时间同时被用到，则可以使用union。</span></span><br><span class="line"><span class="comment">//一种常见的手法是使用union判断存储方式是大端还是小端。</span></span><br></pre></td></tr></table></figure></li><li>enum：枚举声明 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">season</span> &#123;</span> spring, summer, autumn, winter &#125;;</span><br><span class="line"><span class="comment">//默认情况下spring为0，summer为1，依此类推。也可以自行赋值</span></span><br><span class="line"><span class="comment">//可以默认安排值，主要是阅读方便</span></span><br></pre></td></tr></table></figure></li><li>typedef：声明类型别名</li><li>sizeof：得到特定类型或特定类型变量的大小</li></ul><h3 id="存储级别关键字6个">2.4 存储级别关键字（6个）</h3><ul><li>auto：指定为自动变量，由编译器自动分配及释放。通常在栈上分配</li><li>static：指定为静态变量，分配在静态变量区。修饰函数时，指定函数作用域为文件内部。</li><li>register：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数</li><li>extern：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的对象的一个“引用”</li><li>const：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//在防御性编程中可以多用const</span><br></pre></td></tr></table></figure></li><li>volatile：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//volatile通常用于如下三种情况</span><br><span class="line">//1.程序使用RTOS，多线程中都会读写的全局变量</span><br><span class="line">//2.中断和主函数中都要读写的全局变量</span><br><span class="line">//3.单片机的寄存器定义</span><br></pre></td></tr></table></figure></li></ul><h3 id="跳转结构关键字4个">2.5 跳转结构关键字（4个）</h3><ul><li>return：用在函数体中，返回特定值（或者是void值，即不返回值）</li><li>continue：结束当前循环，开始下一轮循环</li><li>break：跳出当前循环或switch结构</li><li>goto：无条件跳转语句</li></ul><h3 id="分支结构关键字5个">2.6 分支结构关键字（5个）</h3><ul><li>if：条件语句</li><li>else：条件语句否定分支（与if连用）</li><li>switch：开关语句（多重分支语句）</li><li>case：开关语句中的分支标记</li><li>default：开关语句中的“其他”分治，可选</li></ul><h3 id="循环结构关键字3个">2.7 循环结构关键字（3个）</h3><ul><li>for：for(1;2;3)4;的执行顺序为1-&gt;2-&gt;4-&gt;3-&gt;2...循环，其中2为循环条件</li><li>do：do 1 while(2);的执行顺序是1-&gt;2-&gt;1...循环，2为循环条件</li><li>while：while(1) 2;的执行顺序是1-&gt;2-&gt;1...循环，1为循环条件</li></ul><h2 id="输入输出">3.输入输出</h2><h3 id="转义字符表">3.1 转义字符表</h3><table><thead><tr class="header"><th>转义字符</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>\'</code></td><td>单引号</td></tr><tr class="even"><td><code>\"</code></td><td>双引号</td></tr><tr class="odd"><td><code>\\</code></td><td>反斜杠</td></tr><tr class="even"><td><code>\n</code></td><td>换行符</td></tr><tr class="odd"><td><code>\r</code></td><td>回车符</td></tr><tr class="even"><td><code>\t</code></td><td>制表符</td></tr><tr class="odd"><td><code>\b</code></td><td>退格符</td></tr><tr class="even"><td><code>\f</code></td><td>换页符</td></tr><tr class="odd"><td><code>\v</code></td><td>垂直制表符</td></tr><tr class="even"><td><code>\a</code></td><td>响铃符</td></tr><tr class="odd"><td><code>\0</code></td><td>空字符</td></tr></tbody></table><h3 id="printf函数">3.2 printf()函数</h3><p>这个函数用于将格式化的字符串输出到标准输出流（通常是终端）。printf()函数的常见用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!&quot;</span>);  <span class="comment">// 输出简单的字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My age is %d&quot;</span>, age);  <span class="comment">// 输出格式化的字符串</span></span><br></pre></td></tr></table></figure><p>其中，%d是一个占位符，用于表示将要输出的变量的数据类型。例如，上面的代码中，%d表示将要输出一个整数类型的变量age。</p><p>下面是类型符号及其含义 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%d - 整型格式说明符，用于输出整数值。</span><br><span class="line">%f - 浮点型格式说明符，用于输出浮点数值。</span><br><span class="line">%c - 字符型格式说明符，用于输出单个字符。</span><br><span class="line">%s - 字符串格式说明符，用于输出字符串值。</span><br><span class="line">%p - 指针型格式说明符，用于输出内存地址。</span><br><span class="line">%x 或 %X - 十六进制格式说明符，用于以十六进制格式输出整数值。</span><br><span class="line">%o - 八进制格式说明符，用于以八进制格式输出整数值。</span><br><span class="line">%e 或 %E - 科学计数法格式说明符，用于以科学计数法格式输出浮点数值。</span><br><span class="line">%g 或 %G - 自动格式说明符，根据输出变量的大小决定使用 %f 或 %e 格式。</span><br></pre></td></tr></table></figure></p><p>通过在百分号后面加指令可以控制固定精度输出，如<code>%.2f</code>指输出小数点后2位的浮点数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="type">float</span> pi = <span class="number">3.1415926535</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi = %.3f\n&quot;</span>, pi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi = %.*f\n&quot;</span>, <span class="number">3</span>, pi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi = %g\n&quot;</span>, pi);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">pi = <span class="number">3.142</span></span><br><span class="line">pi = <span class="number">3.142</span></span><br><span class="line">pi = <span class="number">3.14159</span></span><br></pre></td></tr></table></figure></p><h3 id="scanf函数">3.3 scanf()函数</h3><p>这个函数用于从标准输入流中读取数据。scanf()函数的常见用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);  <span class="comment">// 读取一个整数类型的变量</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;score);  <span class="comment">// 读取一个浮点数类型的变量</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);  <span class="comment">// 读取一个字符串类型的变量</span></span><br></pre></td></tr></table></figure><p>scanf()函数中的%符号也是一个占位符，用于表示将要读取的变量的数据类型。&amp;符号用于表示将要读取的变量的地址。在使用scanf()函数时，需要注意数据类型匹配和错误处理等问题。</p><h3 id="getchar函数和putchar函数">3.4 getchar()函数和putchar()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = getchar();  <span class="comment">// 读取一个字符</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>);  <span class="comment">// 输出一个字符</span></span><br></pre></td></tr></table></figure><p>getchar()函数会等待用户输入一个字符，并将该字符作为返回值返回，而putchar()函数则将给定的字符输出到标准输出流。</p><h3 id="gets函数和puts函数">3.5 gets()函数和puts()函数</h3><p>gets()函数用于从标准输入流中读取一行字符串，直到遇到换行符为止。</p><p>puts()函数则将给定的字符串输出到标准输出流，并在字符串末尾自动添加一个换行符。它们的常见用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">gets(str);  <span class="comment">// 读取一行字符串</span></span><br><span class="line"><span class="built_in">puts</span>(str);  <span class="comment">// 输出字符串并添加一个换行符</span></span><br></pre></td></tr></table></figure><p>gets()函数的安全性不高，容易引发缓冲区溢出等安全问题，因此建议使用fgets()函数代替gets()函数进行字符串输入。</p><h3 id="文件读写">3.6 文件读写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);  <span class="comment">// 打开文件</span></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File does not exist.&quot;</span>);  <span class="comment">// 检查文件是否打开成功</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);  <span class="comment">// 如果文件打开失败，则终止程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">fgets(str, <span class="number">100</span>, fp);  <span class="comment">// 从文件中读取一行字符串</span></span><br><span class="line">fclose(fp);  <span class="comment">// 关闭文件</span></span><br></pre></td></tr></table></figure><h2 id="符号运算优先级">4.符号运算优先级</h2><table><thead><tr class="header"><th>优先级</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr class="odd"><td>1</td><td>( )</td><td>左右</td></tr><tr class="even"><td>2</td><td>! ~ -</td><td>右到左</td></tr><tr class="odd"><td>3</td><td>* / %</td><td>左到右</td></tr><tr class="even"><td>4</td><td>+ -</td><td>左到右</td></tr><tr class="odd"><td>5</td><td>&lt;&lt; &gt;&gt;</td><td>左到右</td></tr><tr class="even"><td>6</td><td>&lt; &lt;= &gt; &gt;=</td><td>左到右</td></tr><tr class="odd"><td>7</td><td>== !=</td><td>左到右</td></tr><tr class="even"><td>8</td><td>&amp;</td><td>左到右</td></tr><tr class="odd"><td>9</td><td>^</td><td>左到右</td></tr><tr class="even"><td>10</td><td>|</td><td>左到右</td></tr><tr class="odd"><td>11</td><td>&amp;&amp;</td><td>左到右</td></tr><tr class="even"><td>12</td><td>||</td><td>左到右</td></tr><tr class="odd"><td>13</td><td>? :</td><td>右到左</td></tr><tr class="even"><td>14</td><td>= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;=</td><td>右到左</td></tr></tbody></table><h2 id="数组">5.数组</h2><p>在C语言中，数组是一组相同数据类型的元素的集合。数组中的每个元素都可以通过下标来访问，下标从0开始计数。数组的定义方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type array_name[array_size];</span><br></pre></td></tr></table></figure><p>其中，type表示数组中元素的数据类型，array_name表示数组的名称，array_size表示数组中元素的个数。在数组中，第一个元素的下标为0，最后一个元素的下标为<code>array_size-1</code>。可以通过下标来访问数组中的元素。</p><h2 id="指针">6.指针</h2><p>在C语言中，指针是一种特殊的变量类型，它可以存储变量的地址。指针的定义方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type *pointer_name;</span><br></pre></td></tr></table></figure><p>其中，type表示指针所指向变量的数据类型，pointer_name表示指针的名称。指针变量需要指向某个内存地址才能使用，可以通过取地址运算符<code>&amp;</code>来获取变量的地址，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;  <span class="comment">// 将指针p指向变量a的地址</span></span><br><span class="line"><span class="type">int</span> b = *p;  <span class="comment">// 将b赋值为指针p所指向的变量的值</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = a;  <span class="comment">// 将指针p指向数组a的第一个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));  <span class="comment">// 通过指针访问数组中的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;简单复习一下C语言。&lt;/p&gt;
&lt;p&gt;进阶篇：&lt;a
href=&quot;https://splendidwave.github.io/2023/04/23/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E8%BF%9B%E9%98%B6%E7%AF%87/&quot;&gt;C语言复习-进阶篇&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90/"/>
    
    
    <category term="嵌入式开发" scheme="https://splendidwave.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="C语言" scheme="https://splendidwave.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>统计学习(7)--最大熵模型</title>
    <link href="https://splendidwave.github.io/2023/01/04/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(7)--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <id>https://splendidwave.github.io/2023/01/04/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(7)--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</id>
    <published>2023-01-04T08:10:03.000Z</published>
    <updated>2023-04-19T07:37:27.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>支持向量机的学习的目标也是在特征空间中找到一个分离超平面，能将实例分到不同的类。不同与感知机的解有无穷多个，线性可分支持向量机利用间隔最大化求最优分离超平面，解是唯一的。</p><span id="more"></span><h2 id="间隔">1.间隔</h2><p>一般来说，一个点距离分离超平面的远近可以表示分类预测的确信程度。在超平面确定的情况下，点<spanclass="math inline">\(x_i\)</span>与超平面的距离可以表示为函数</p><p><span class="math display">\[\left|\frac{1}{\|w\|_{2}} \cdot\left(w \cdot x_i+b\right)\right|\]</span></p><p>定义函数间隔（functional margin）为下式</p><p><span class="math display">\[\hat{\gamma}_{i}=y_{i}\left(w \cdot x_{i}+b\right)\]</span></p><p>记函数间隔<spanclass="math inline">\(\hat{\gamma}_{i}\)</span>的最小值为<spanclass="math inline">\(\hat{\gamma}\)</span>，函数间隔可以表示分类预测的正确性及准确度。对超平面的法向量添加约束，就可以得到几何间隔（geometricmargin），定义如下</p><p><span class="math display">\[\gamma_{i}=y_{i}\left(\frac{w}{\|w\|} \cdot x_{i}+\frac{b}{\|w\|}\right)\]</span></p><h3 id="最大间隔分离">1.1 最大间隔分离</h3><p>最大间隔具有存在性和唯一性，训练数据集的样本点中与分离超平面距离最近的样本点的实例称为支持向量（supportvector），在决定分离超平面时只有支持向量起作用，而其他实例点并不起作用。如果移动支持向量将改变所求的解；但是如果在间隔边界以外移动其他实例点，甚至去掉这些点，则解是不会改变的。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/01/20230104162422.png"alt="支持向量" /><figcaption aria-hidden="true">支持向量</figcaption></figure><h3 id="硬间隔">1.2 硬间隔</h3><p>硬间隔(hardmargin)：假定训练样本在样本空间或特征空间中是线性可分的，即存在一个超平面能将不同类的样本完全划分开。</p><p>对于硬间隔分类，可以将问题转化为优化问题，即求</p><p><span class="math display">\[\max _{w, b} \quad  \hat{\gamma}_{i}\]</span></p><p><span class="math display">\[\text { s.t. }  y_{i}\left(\frac{w}{\|w\|} \cdotx_{i}+\frac{b}{\|w\|}\right) \geqslant \hat{\gamma}, \quad i=1,2,\cdots, N\]</span></p><p>使用几何间隔来替代间隔函数，这样对超平面的参数<spanclass="math inline">\(w,b\)</span>的缩放就不影响结果，可以令几何最小间隔<spanclass="math inline">\(\hat{\gamma}=1\)</span>，将所求表达式转换为如下形式</p><p><span class="math display">\[\max _{w, b} \frac{1}{\|w\|}\]</span></p><p><span class="math display">\[\text { s.t. } \quad y_{i}\left(w \cdot x_{i}+b\right) \geqslant 1,\quad i=1,2, \cdots, N\]</span></p><p>可以进一步可以变为求最小值优化</p><p><span class="math display">\[\min _{w, b} \frac{1}{2}\|w\|^{2}\]</span></p><p><span class="math display">\[\text { s.t. } \quad y_{i}\left(w \cdot x_{i}+b\right)-1 \geqslant 0,\quad i=1,2, \cdots, N\]</span></p><h3 id="软间隔">1.3 软间隔</h3><p>实际中训练数据的不等式约束并不能都成立。并不能满足硬间隔，这就需要修改硬间隔最大化，使其成为软间隔最大化。</p><p>为了解决这个问题，可以对每个样本点<spanclass="math inline">\((x_i,y_i)\)</span>引进一个松弛变量<spanclass="math inline">\(\xi_{\mathrm{i}} \geq0\)</span>，使函数间隔加上松弛变量大于等于1。这样，约束条件变为</p><p><span class="math display">\[y_{i}\left(w \cdot x_{i}+b\right) \geqslant 1-\xi_{i}\]</span></p><h2 id="对偶算法">2.对偶算法</h2><h3 id="对偶关系证明">2.1 对偶关系证明</h3><p>使用拉格朗日乘子法引入对偶算法，注意这里要用小于0的约束条件</p><p><span class="math display">\[L(w, b, \lambda)=\frac{1}{2}\|w\|^{2}+\sum_{i=1}^{N} \lambda_{i}(1-y_{i}\left(w \cdot x_{i}+b\right))\]</span></p><p>其中<spanclass="math inline">\(\lambda\)</span>是拉格朗日乘子，要求大于等于0</p><p>原问题就转化为</p><p><span class="math display">\[\max _{\lambda} \min _{w, b}  L(w, b, \lambda)\]</span></p><p><span class="math display">\[\text { s.t. } \lambda_{i} \geqslant 0\]</span></p><p>这里解释一下取极大极小值的意义，。先将<spanclass="math inline">\(\frac{1}{2}\|w\|^{2}\)</span>记为<spanclass="math inline">\(f(w)\)</span>,后一项记为<spanclass="math inline">\(\lambda g(w,b)\)</span> <spanclass="math display">\[\begin{align}\max _{\lambda}\min _{w, b}  L(w, b, \lambda) &amp;=\max_{\lambda}\min_{w, b}  f(w)+ \max_{\lambda}\min_{w, b} \lambdag(w,b)\nonumber \\&amp;= \min_{w} f(w) +  \max_{\lambda}\min_{w, b} \lambda g(w,b)\nonumber\end{align}\]</span></p><p>因为<span class="math inline">\(y_{i}\left(w \cdotx_{i}+b\right)\geqslant 1\)</span>，所以<spanclass="math inline">\(g(w,b)\)</span>小于等于0，上式后一项的最大值就是0，即</p><p><span class="math display">\[\max _{\lambda}\min _{w, b}  L(w, b, \lambda) =\min_{w}\frac{1}{2}\|w\|^{2}\]</span></p><p>和原式等价。</p><p>有些视频和书上最大最小符号前后是换位的，在该问题下是等价的，因为有<spanclass="math inline">\(g(w,b)\)</span>小于等于0，所以</p><p><span class="math display">\[\max_{\lambda} L(w,b,\lambda) = f(w)\]</span></p><p>所以有</p><p><span class="math display">\[\min_{w,b} f(w) = \min_{w,b} \max_{\lambda} L(w,b,\lambda) = \max_{\lambda}\min _{w, b} L(w, b, \lambda)\]</span></p><h3 id="拉格朗日求解">2.2 拉格朗日求解</h3><p>将拉格朗日函数分别对<span class="math inline">\(w,b\)</span>求导</p><p><span class="math display">\[\nabla_{w} L(w, b, \lambda)=w-\sum_{i=1}^{N} \lambda_{i} y_{i} x_{i}=0\]</span></p><p><span class="math display">\[\nabla_{b} L(w, b, \lambda)=\sum_{i=1}^{N} \lambda_{i} y_{i}=0\]</span></p><p>所以有</p><p><span class="math display">\[w=\sum_{i=1}^{N} \lambda_{i} y_{i} x_{i}\]</span></p><p><span class="math display">\[\sum_{i=1}^{N} \lambda_{i} y_{i}=0\]</span></p><p>将上式回代<span class="math inline">\(L(w, b, \lambda)\)</span>得</p><p><span class="math display">\[\begin{aligned}L(w, b,  \lambda) &amp; =\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N}\lambda_{i} \lambda_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)\\&amp;-\sum_{i=1}^{N} \lambda_{i} y_{i}\left(\left(\sum_{j=1}^{N}\lambda_{j} y_{j} x_{j}\right) \cdot x_{i}+b\right)+\sum_{i=1}^{N}\lambda_{i} \\&amp; =-\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \lambda_{i}\lambda_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)+\sum_{i=1}^{N}\lambda_{i}\end{aligned}\]</span></p><p>这就是<span class="math inline">\(\min _{w, b} L(w, b,\lambda)\)</span>，接下来对它求极大值</p><p>即求负的极小值</p><p><span class="math display">\[\min _{\lambda} \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \lambda_{i}\lambda_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)+\sum_{i=1}^{N}\lambda_{i}\]</span></p><p><span class="math display">\[\begin{array}{ll}\text { s.t. } &amp; \sum_{i=1}^{N} \lambda_{i} y_{i}=0 \\&amp; \lambda_{i} \geqslant 0, \quad i=1,2, \cdots, N\end{array}\]</span></p><!-- ## 3.线性支持向量机## 4.非线性支持向量机## 5.SMO --><h2 id="参考资料">参考资料</h2><p>[1] 《统计学习方法》 李航</p><p>[2] <ahref="https://www.cnblogs.com/mo-wang/p/4775548.html">【整理】深入理解拉格朗日乘子法（LagrangeMultiplier) 和KKT条件</a></p><p>[3] <ahref="https://www.bilibili.com/video/BV1Hs411w7ci/?p=2&amp;spm_id_from=333.880.my_history.page.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">机器学习-白板推导系列(六)-支持向量机SVM（SupportVector Machine）</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;支持向量机的学习的目标也是在特征空间中找到一个分离超平面，能将实例分到不同的类。不同与感知机的解有无穷多个，线性可分支持向量机利用间隔最大化求最优分离超平面，解是唯一的。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="统计学习" scheme="https://splendidwave.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>统计学习(6)--逻辑斯谛回归</title>
    <link href="https://splendidwave.github.io/2022/12/26/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(6)--%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92/"/>
    <id>https://splendidwave.github.io/2022/12/26/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(6)--%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92/</id>
    <published>2022-12-26T01:46:03.000Z</published>
    <updated>2022-12-30T09:13:46.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>逻辑斯谛回归模型利用了逻辑斯谛方程的对数特性，将特征参数映射到[0，1]之间，将问题转换为概率预测，从而实现判别。</p><span id="more"></span><h2 id="逻辑斯谛方程">1.逻辑斯谛方程</h2><p>学过数学建模的应该都知道，逻辑斯谛方程最早提出是用于人口增长模型。下面进行一个简单的推导。</p><p>假设人口随时间的函数是<spanclass="math inline">\(W(t)\)</span>，人口增长率为<spanclass="math inline">\(\beta\)</span>，则人口增长的微分方程为</p><p><span class="math display">\[\frac{\mathrm{d} W(t)}{\mathrm{d} t}  = \beta W(t)\]</span></p><p>解得</p><p><span class="math display">\[W(t) = \exp （\beta t + C）\]</span></p><p>这种指数爆炸型增长是不太可能发生的，毕竟资源是有限的，所以人口增长应该还要和生物容量<spanclass="math inline">\(K\)</span>有关，再重新写出微分方程,这里的<spanclass="math inline">\(\beta\)</span>和上面的可能存在数值上的差异。</p><p><span class="math display">\[\frac{\mathrm{d} W(t)}{\mathrm{d} t}  = \beta W(t) (K-W(t))\]</span></p><p>这就是逻辑斯谛方程的微分形式，其实这个方程虽然是推猜出来的，但其蕴含了一定的自然规律，所以他从人口模型应用到了其他各个领域，这点和傅里叶变换不谋而合。</p><h2 id="逻辑斯谛分布">2.逻辑斯谛分布</h2><p>现在我不关心数量了，我更想知道现在的人口占总容量的多少，记比例为<spanclass="math inline">\(P(t)\)</span>我们有<spanclass="math inline">\(P(t)=W(t)/K\)</span></p><p>对于P(t)有</p><p><span class="math display">\[\begin{align}\frac{\mathrm{d} P(t)}{\mathrm{d} t}  &amp;= \frac{\mathrm{d}(W(t)/K)}{\mathrm{d} t} \\&amp;= \frac{\beta}{K}W(t)(K-W(t)) \\&amp;= K\beta P(t)[1-P(t)]\end{align}\]</span></p><p>等式就变成了微分方程 <span class="math display">\[\frac{1}{P[1-P]} P \mathrm{d} P =  C * \mathrm{d} t\]</span> 其中C是常数</p><p>解方程得</p><p><span class="math display">\[P = \frac{\exp{(\alpha+\beta t)}}{1+\exp{(\alpha+\beta t)}}\tag{式1}\]</span></p><p>其中<span class="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\beta\)</span>是常数，令<spanclass="math inline">\(x = \alpha+\beta t\)</span></p><p>将上式函数绘制出来就如下图</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221230151405.png"alt="逻辑斯谛分布" /><figcaption aria-hidden="true">逻辑斯谛分布</figcaption></figure><p>P的物理意义是占比，也就是说它的取值范围在<spanclass="math inline">\([0-1]\)</span>之间，这和概率不谋而合，将这个函数视作概率密度函数，可以得到逻辑斯谛分布函数方程和图如下</p><p><span class="math display">\[F(x)=P(X \leqslant x)=\frac{1}{1+\mathrm{e}^{-(x-\mu) / \gamma}}\]</span></p><p><span class="math display">\[f(x)=F^{\prime}(x)=\frac{\mathrm{e}^{-(x-\mu) /\gamma}}{\gamma\left(1+\mathrm{e}^{-(x-\mu) / \gamma}\right)^{2}}\]</span></p><p>其中<span class="math inline">\(\mu\)</span>为位置参数，<spanclass="math inline">\(\gamma&gt;0\)</span>是形状参数。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221230151747.png"alt="分布函数" /><figcaption aria-hidden="true">分布函数</figcaption></figure><h2 id="二项逻辑斯谛回归模型">3.二项逻辑斯谛回归模型</h2><p>对于二分类问题，使用统计学习中常用的<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>来代替式1的<spanclass="math inline">\(\beta\)</span>和<spanclass="math inline">\(\alpha\)</span>,可以得到</p><p><span class="math display">\[P = \frac{\exp (w \cdot x+b)}{1+\exp (w \cdot x+b)}\]</span></p><p>我们人为假定这个P是实例x在参数<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>条件下分类为1的概率，毕竟参数是可以训练的，那么有</p><p><span class="math display">\[P(Y=0 \mid x)=\frac{1}{1+\exp (w \cdot x+b)}\]</span></p><p>两者的和为1，使用训练集训练数据后，对于新实例，只需要计算两者的概率让后进行归类即可。</p><p>模型的参数可以使用极大似然估计法来得到，设</p><p><span class="math display">\[P(Y=1 \mid x)=\pi(x), \quad P(Y=0 \mid x)=1-\pi(x)\]</span></p><p>似然函数为</p><p><span class="math display">\[\prod_{i=1}^{N}\left[\pi\left(x_{i}\right)\right]^{y_{i}}\left[1-\pi\left(x_{i}\right)\right]^{1-y_{i}}\]</span></p><p>对数似然函数为</p><p><span class="math display">\[\begin{aligned}L(w) &amp; =\sum_{i=1}^{N}\left[y_{i} \log\pi\left(x_{i}\right)+\left(1-y_{i}\right) \log\left(1-\pi\left(x_{i}\right)\right)\right] \\&amp; =\sum_{i=1}^{N}\left[y_{i} \log\frac{\pi\left(x_{i}\right)}{1-\pi\left(x_{i}\right)}+\log\left(1-\pi\left(x_{i}\right)\right)\right] \\&amp; =\sum_{i=1}^{N}\left[y_{i}\left(w \cdot x_{i}\right)-\log\left(1+\exp \left(w \cdot x_{i}\right)\right]\right.\end{aligned}\]</span></p><p>对<spanclass="math inline">\(L(w)\)</span>用梯度下降法求极大值即可得到估计值。</p><p>最后给出多项逻辑斯谛回归的公式</p><p><span class="math display">\[P(Y=k \mid x)=\frac{\exp \left(w_{k} \cdot x\right)}{1+\sum_{k=1}^{K-1}\exp \left(w_{k} \cdot x\right)}, \quad k=1,2, \cdots, K-1\]</span></p><h2 id="参考资料">参考资料</h2><p>[1] 《统计学习方法》 李航</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;逻辑斯谛回归模型利用了逻辑斯谛方程的对数特性，将特征参数映射到[0，1]之间，将问题转换为概率预测，从而实现判别。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="统计学习" scheme="https://splendidwave.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>统计学习(5)--决策树</title>
    <link href="https://splendidwave.github.io/2022/12/18/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(5)--%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>https://splendidwave.github.io/2022/12/18/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(5)--%E5%86%B3%E7%AD%96%E6%A0%91/</id>
    <published>2022-12-18T01:12:03.000Z</published>
    <updated>2023-01-07T13:32:23.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>决策树是一种基本的分类和回归方法，其具有可读性好，分类快等优点。在西瓜书中，决策树就作为例子引入了机器学习，说明了树模型是适合于新手入门学习的内容。本文会从基本概念逐一展开介绍几种决策树的基本算法。<span id="more"></span></p><h2 id="什么是决策树">1.什么是决策树</h2><p>分类决策树是一种描述对实例进行分类的树形结构，正如书中西瓜好不好的决策判别。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221218092612.png"alt="决策树判断西瓜是好瓜还是坏瓜" /><figcaption aria-hidden="true">决策树判断西瓜是好瓜还是坏瓜</figcaption></figure><p>人可以同个经验来判别好坏瓜的条件，那对于机器来说，要如何实现并构造决策树呢？不可避免的我们需要一个判别依据，好在信息论里能够给我们一些启发。</p><h2 id="信息熵">2.信息熵</h2><p>信息熵是用来衡量一个体系的不确定度的物理量，熵这个词也是借用的热力学，信息熵越大，不确定性越强。计算公式如下</p><p><span class="math display">\[H(X)=-\sum_{i=1}^{M} P\left(x_{i}\right) \log _{2} P\left(x_{i}\right)\tag{1.1}\]</span></p><p>如果不太清楚这个概念可以通过该链接去了解一下<ahref="https://splendidwave.github.io/2022/08/20/2022-8/%E4%BF%A1%E6%81%AF%E9%87%8F%E5%92%8C%E4%BF%A1%E6%81%AF%E7%86%B5/">信息量和信息熵</a></p><p>在理解信息熵这个概念后，这里再补充一个<strong>条件熵</strong>，它指的是在某一条件Y下体系具有的信息熵。公式如下</p><p><span class="math display">\[H(X \mid Y)=-\sum_{i=1}^{M} P(x_i \mid Y) \log _{2} P(x_i \mid Y)\tag{1.2}\]</span></p><p>显然系统的条件熵要比信息熵要小一些，因为条件Y的发生让系统更加确定了一些，它们差值不妨就叫做<strong>信息增益</strong>。公式如下</p><p><span class="math display">\[I(X, Y)=H(X)-H(X \mid Y)\tag{1.3}\]</span></p><h2 id="判别条件">2.判别条件</h2><p>有了以上几个量化概念，我们就可以用来量化决策树。</p><p>可以看一个具体的例子，有一副去掉大小王的扑克牌(52张)，我从中随机抽取一张，想让机器狗旺财来帮我判别它是<strong>红色还是黑色</strong>。旺财无法直接识别颜色，它只能看见点数和花色,所以它需要用决策树的方法来处理这个问题。</p><p>旺财计算了一下该问题的信息熵</p><p><span class="math display">\[\begin{align}H(X) &amp; = -\sum_{i=1}^{M} P\left(x_{i}\right) \log _{2}P\left(x_{i}\right)\nonumber\\&amp; = \frac{1}{2} + \frac{1}{2} \nonumber \\&amp; = 1 \nonumber\end{align}\]</span></p><h3 id="使用点数决策-y_1">2.1 使用点数决策 <spanclass="math inline">\(Y_1\)</span></h3><p>它决定先试试点数，<strong>决策条件为点数大于等于10的都是红色</strong>。</p><p>那么条件熵为</p><p><span class="math display">\[H(X \mid Y_1) = (\frac{4}{13}+\frac{9}{13})\cdot(\frac{1}{4}\log_{2}{4}-\frac{3}{4}\log_{2}\frac{3}{4}) \approx 0.811\]</span></p><p>好像这个条件并没有起到任何帮助，信息增益为<spanclass="math inline">\(I(X, Y_1)=0.189\)</span></p><h3 id="使用花色决策-y_2">2.2 使用花色决策 <spanclass="math inline">\(Y_2\)</span></h3><p>旺财改变了策略，<strong>红桃的牌都是红色</strong>。</p><p>红桃牌的概率是1/4且全是红色 那么条件熵为</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200707.jpg"alt="决策2" /><figcaption aria-hidden="true">决策2</figcaption></figure><p><span class="math display">\[H(X \mid Y_2) = \frac{1}{4} \cdot 0 + \frac{3}{4} \cdot 0.91829 \approx0.689\]</span></p><p>信息增益为<span class="math inline">\(I(X,Y_2)=0.311\)</span>，看起来好了一些。</p><h3 id="花色决策2.0-y_3">2.3 花色决策2.0 <spanclass="math inline">\(Y_3\)</span></h3><p>旺财注意到上述决策中左节点的信息熵已经是0了，可以停止优化，而右节点的信息熵接近父节点的信息熵，说明优化空间很大，于是它对右节点再采策略认为<strong>方片也是红的</strong>。</p><p>毫无疑问信息信息增益达到了最大，旺财完美地完成了任务。</p><h2 id="id3算法">3.ID3算法</h2><p>ID 是 IterativeDichotomiser的缩写，迭代二分器/二叉树，虽然决策树不一定是二叉树，但通常情况下是二分的，3大概是第三代的意思吧。</p><p>上述这种以<strong>信息增益作为特征选择的度量</strong>，使用自顶向下的贪心算法遍历决策树空间的算法即为ID3算法。</p><p>通俗的讲该算法就是每一步都选择可以实现信息增益最大的特征作为该节点的分类条件直到特征用完或者分类结束。</p><p>程序流程图就放在后面给，现在来看看ID3算法优缺点。</p><h3 id="id3的优点">3.1 ID3的优点</h3><ol type="1"><li>简单，只需要算信息熵就完了。</li><li>鲁棒性强，不容易受到噪声的影响</li><li>搜索空间完整，基本上会遍历所有特征</li></ol><h3 id="id3的缺点">3.2 ID3的缺点</h3><ol type="1"><li>ID3算法会去选择可取值类别多的特征，这是信息熵的计算方法导致的，分得越细，确定性就会越高。</li><li>只能计算离散值</li><li>无法处理信息缺失</li><li>容易过拟合，因为它会遍历所有特征</li></ol><h2 id="c4.5算法">4.C4.5算法</h2><p>ID3 算法的发明人RossQuinlan也意识到了这些缺点，有问题就解决呗，ID3会对多分类有个偏好，这是因为信息增益的计算方式导致的，为了解决这一问题，必须将判别条件改变。</p><p>为此分裂信息的定义被提出，计算公式如下：</p><p><span class="math display">\[SplitInfo_A(D)=-\sum_{i=1}^{n} \frac{\left|D_{i}\right|}{|D|} \log _{2}\frac{\left|D_{i}\right|}{|D|}\tag{4.1}\]</span></p><p>其中D是数据集，<spanclass="math inline">\(D_i\)</span>是D在特征A下的第i个分类子集。可以看出分裂信息也特征的类别越多值就会越大。</p><p>所以只要将信息增益除以分裂信息就可以得到一个消除倾向的判别条件，我们称为<strong>信息增益率</strong>，计算公式如下：</p><p><span class="math display">\[\operatorname{GainRatio}(D,A)=\frac{I(D,A)}{\operatorname{SplitInfo_A}(D)} \tag{4.2}\]</span></p><p>对于连续的特征值，可以选择遍历这些值找到信息增益最大的分界点来实现对值的二分离散化。</p><p>信息缺失可以选择补上期望值，过拟合就采用剪枝的方法来完成。</p><p>这样问题就解决了不少，但这类算法还是存在硬伤。一是算法只能用于分类，二是构造过程需要反复遍历，比较大小，还是对数运算，算法效率低。</p><h2 id="cart3算法">5.CART3算法</h2><h3 id="不如换个判别条件">5.1 不如换个判别条件</h3><p>既然对数运算费时，不如直接抛开熵这个数值条件，重新找一个判别依据，公式如下</p><p><span class="math display">\[\operatorname{Gini}(D)=\sum_{k=1}^{K}\frac{\left|C_{k}\right|}{|D|}\left(1-\frac{\left|C_{k}\right|}{|D|}\right)=1-\sum_{k=1}^{K}p_{k}^{2} \tag{5.1}\]</span></p><p>我们称它为基尼系数，其中k为类别，<spanclass="math inline">\(p_k\)</span>是k类别的概率，它可以识别当前集合的纯度。来看一个具体例子，当k只能取两个值时，如红色牌的概率为<spanclass="math inline">\(p_1\)</span> 黑色牌概率为<spanclass="math inline">\(p_2\)</span>，而且有<spanclass="math inline">\(p_1=1-p_2\)</span>，代入式(5.1)可得基尼系数是一个关于<spanclass="math inline">\(p_1\)</span>的二次函数，关系如下图</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200727.jpg"alt="基尼系数" /><figcaption aria-hidden="true">基尼系数</figcaption></figure><p>当集合中只有红色时，即概率<spanclass="math inline">\(p=1\)</span>，这时基尼系数为0，当红黑参半时，基尼系数会达到最大。由此可见，基尼系数越小，代表集合纯度越高。</p><p>我们可以以此为参考依据，遍历特征，选出加权基尼系数最小的分类方法作为策略。同时CART3永远对数据二分，离散连续一视同仁，二叉树的便捷性也是显而易见的。</p><h3 id="谁说树只能分类">5.2 谁说树只能分类</h3><p>CART树全名是Classification and RegressionTree，这说明它既能分类也能回归，回归树的构建本质上是用<strong>平方误差最小化准则</strong>进行特征选择，去生成二叉树。</p><p>其判别的条件又不是基尼系数了，而是最小均方差值，公式如下</p><p><span class="math display">\[\min_{j, s}\left[\min_{c_{1}} \sum_{x_{i} \in R_{1}(j,s)}\left(y_{i}-c_{1}\right)^{2}+\min_{c_2} \sum_{x_{i} \in R_{2}(j,s)}\left(y_{i}-c_{2}\right)^{2}\right] \tag{5.2}\]</span></p><p>其中因为特征是连续值，该公式的意思是选择第j个特征的s为切分点，这样集合就分为了<spanclass="math inline">\(R_1\)</span>和<spanclass="math inline">\(R_2\)</span>，使得两个区域的label值和该划分区域的值c平方和最小。得到j和s作为划分的依据，其中<spanclass="math inline">\(c_1\)</span>、<spanclass="math inline">\(c_2\)</span>取集合的均值： <spanclass="math display">\[c_{1}=\frac{1}{N_{1}} \sum_{x_{i} \in R_{1}} y_{i}, \quadc_{2}=\frac{1}{N_{2}} \sum_{x_{i} \in R_{2}} y_{i}\]</span></p><p>回归树但看公式可能有些困难，最好找道例题或者自己敲遍代码加强理解。另外cart算法也容易过拟合，需要配合减枝。</p><h2 id="随机森林">6.随机森林</h2><p>树看起来内容差不多了，但有很多树的时候，就形成了森林。为什么需要很多树？这是因为我们在处理问题时可能会不知道那些特征是有用的，那些特征是没有用的，为此不妨多训练几颗树，让每个树的特征随机选取。最后通过统计所有树的输出结果少数服从多数得到答案。</p><p>随机森林的结构简单而高效，当不知道用什么算法时不妨试试随机森林。而且这类集成学习的方法也不单单适用于决策树，同时也可以集成神经网络。</p><h2 id="boosting算法">7.Boosting算法</h2><p>Boosting是提升的意思，Boosting算法是通过把弱学习器加强成强学习器。一个典型的例子是GBDT算法</p><p>GBDT全称是Gradient Boosting DecisionTree，它利用CART的回归树作为弱学习器。这里只给出实现思路，具体公式暂不呈现。</p><p>我们引入一个残差的概念，它指的是模型的预测值和真实值的差距。当我们训练了一个树，它的输出结果会与真实值存在残差，我们可以再训练一个树来预测残差，当然这个预测残差的树也必然会与真实残差存在一个残差。不过没关系，我们可以套娃，套到结果可以接受的样子，大概的思路类似梯度下降法，同时公式也是用的一阶导数（负梯度）来近似残差。</p><p>另外还有XGBoost算法，XG是ExtremeGradient的意思，XGBoost在GBDT的基础上又做了改进，使用了二阶导数的信息，同时又加了一个正则项来防止过拟合。</p><h2 id="参考资料">参考资料</h2><p>[1] 《统计学习方法》 李航</p><p>[2] 《机器学习》 周志华</p><p>[3] 知乎文章 <ahref="https://zhuanlan.zhihu.com/p/399549773">零基础一文读懂树模型：从决策树到LightGBM</a></p><p>[4] 知乎文章 <ahref="https://zhuanlan.zhihu.com/p/158633779">【预估排序】Xgboost、GBDT、CART等树模型联系和区别（超级详细）</a></p><p>[5] CSDN文章 <ahref="https://blog.csdn.net/weixin_45834080/article/details/103036401">对ID3算法的理解及其优缺点</a></p><p>[6] b站视频 <ahref="https://www.bilibili.com/video/BV1VA411A7AQ?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">决策树算法例题</a></p><p>[7] b站视频 <ahref="https://www.bilibili.com/video/BV1ar4y137GD?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">[5分钟学算法]#03 决策树 小明毕业当行长</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;决策树是一种基本的分类和回归方法，其具有可读性好，分类快等优点。在西瓜书中，决策树就作为例子引入了机器学习，说明了树模型是适合于新手入门学习的内容。本文会从基本概念逐一展开介绍几种决策树的基本算法。</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="统计学习" scheme="https://splendidwave.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用python进行科研绘图入门--共用坐标、全局字体</title>
    <link href="https://splendidwave.github.io/2022/12/14/2022-12/%E4%BD%BF%E7%94%A8python%E8%BF%9B%E8%A1%8C%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE%E5%85%A5%E9%97%A8--%E5%85%B1%E7%94%A8%E5%9D%90%E6%A0%87%E3%80%81%E5%85%A8%E5%B1%80%E5%AD%97%E4%BD%93/"/>
    <id>https://splendidwave.github.io/2022/12/14/2022-12/%E4%BD%BF%E7%94%A8python%E8%BF%9B%E8%A1%8C%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE%E5%85%A5%E9%97%A8--%E5%85%B1%E7%94%A8%E5%9D%90%E6%A0%87%E3%80%81%E5%85%A8%E5%B1%80%E5%AD%97%E4%BD%93/</id>
    <published>2022-12-14T06:11:33.000Z</published>
    <updated>2022-12-14T06:22:13.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>python绘图技巧备忘录</p><p>使用Matplotlib，以代码呈现为主</p><p>字体修改，公用x轴坐标 <span id="more"></span></p><h2 id="全局字体修改">1. 全局字体修改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import rcParams</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">    &quot;font.family&quot;:&#x27;serif&#x27;,</span><br><span class="line">    &quot;font.size&quot;: 35,</span><br><span class="line">    &quot;mathtext.fontset&quot;:&#x27;stix&#x27;,</span><br><span class="line">    &quot;font.serif&quot;: [&#x27;SimSun&#x27;],</span><br><span class="line">&#125;</span><br><span class="line">rcParams.update(config)</span><br></pre></td></tr></table></figure><h2 id="局部字体">2.局部字体</h2><p>label <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.ylabel(r&#x27;Wavenumber $\left (  cm^&#123;-1&#125; \right )$&#x27;, fontdict=&#123;&#x27;family&#x27; : &#x27;Times New Roman&#x27;, &#x27;size&#x27;   : 35&#125;)</span><br></pre></td></tr></table></figure> plt自带latex语法</p><p>text <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax2.text(12,12,r&#x27;$A_g^3$&#x27;,ha = &#x27;center&#x27;,va = &#x27;bottom&#x27;,fontsize=35)</span><br></pre></td></tr></table></figure></p><h2 id="共用x坐标">3.共用x坐标</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 开启画布</span><br><span class="line">plt.figure(1)</span><br><span class="line">x_major_locator=MultipleLocator(2)#准备刻度</span><br><span class="line"># 绘制第一幅图像</span><br><span class="line">ax1=plt.gca()</span><br><span class="line">ax1.xaxis.set_major_locator(x_major_locator)</span><br><span class="line">ax1.set_yticks(np.linspace(50, 100, 11)) </span><br><span class="line">plt.plot(x2,nih,linewidth=3.0,color=&#x27;#2878b5&#x27;)</span><br><span class="line">plt.tick_params(axis=&#x27;y&#x27;,colors=&#x27;#2878b5&#x27;)</span><br><span class="line"></span><br><span class="line"># 共用坐标</span><br><span class="line">ax2 = ax1.twinx()</span><br><span class="line">ax2.set_yticks(np.linspace(0, 50, 11))</span><br><span class="line">plt.plot(x1,nil,linewidth=3.0,color=&#x27;#c82423&#x27;)</span><br><span class="line">plt.tick_params(axis=&#x27;y&#x27;,colors=&#x27;#c82423&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图如下</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221214142028.png"alt="共用x坐标" /><figcaption aria-hidden="true">共用x坐标</figcaption></figure><h2 id="参考资料">参考资料</h2><p>[1] <ahref="https://blog.csdn.net/weixin_42710615/article/details/124297710">Matplotlib文字处理</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;python绘图技巧备忘录&lt;/p&gt;
&lt;p&gt;使用Matplotlib，以代码呈现为主&lt;/p&gt;
&lt;p&gt;字体修改，公用x轴坐标</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="科研" scheme="https://splendidwave.github.io/tags/%E7%A7%91%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>统计学习(4)--朴素贝叶斯法</title>
    <link href="https://splendidwave.github.io/2022/12/10/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(4)--%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/"/>
    <id>https://splendidwave.github.io/2022/12/10/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(4)--%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/</id>
    <published>2022-12-10T11:45:03.000Z</published>
    <updated>2022-12-18T01:11:56.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>朴素贝叶斯法是基于贝叶斯定理与特征独立假设的分类方法，假设出数据集的输入输出的联合概率分布，然后基于此模型利用贝叶斯定理求出给定的输入x对应的后验概率最大的输出y。</p><span id="more"></span><h2 id="贝叶斯定理">1.贝叶斯定理</h2><p>贝叶斯学派认为概率是客观事实的可信度，事件A发生存在一个<strong>先验概率</strong><spanclass="math inline">\(P(A)\)</span></p><p>在事件A条件下事件B发生的概率记为<spanclass="math inline">\(P(B|A)\)</span>，称为<strong>似然概率</strong></p><p>相反的，在知道事件B条件下事件A发生的概率为<spanclass="math inline">\(P(A|B)\)</span>，称为<strong>后验概率</strong></p><p>他们之间存在关系</p><p><span class="math display">\[P(A \mid B)=P(A) \frac{P(B \mid A)}{P(B)}\]</span></p><h2 id="朴素贝叶斯法">2.朴素贝叶斯法</h2><p>以分类问题为例，假设要判别的数据<spanclass="math inline">\(Y\)</span>是事件A，已知新实例的特征<spanclass="math inline">\(X\)</span>为事件B，则先验概率为</p><p><span class="math display">\[P\left(Y=c_{k}\right), \quad k=1,2, \cdots, K\]</span></p><p>其中c是分类的类别一共有K种。先验概率由主观可能性认定。</p><p>在已知新实例特征的情况下，该实例为类别<spanclass="math inline">\(c_k\)</span>的可能性为后验概率<spanclass="math inline">\(P(Y=c_k \mid X = x)\)</span></p><p>根据贝叶斯公式上式可以等价于</p><p><span class="math display">\[P\left(Y=c_{k} \mid X=x\right)=\frac{P\left(X=x \mid Y=c_{k}\right)P\left(Y=c_{k}\right)}{\sum_{k} P\left(X=x \mid Y=c_{k}\right)P\left(Y=c_{k}\right)}\]</span></p><p>显然后验概率最大的最有可能是这个实例的正确分类。</p><p>朴素贝叶斯之所以前面有个朴素，是因为它假设了所有实例特征之间相互独立，根据概率论的知识，独立的事件同时发生的概率就是它们的乘积。</p><p>所以上式又可以改写为</p><p><span class="math display">\[y=f(x)=\arg \max _{c_{i}} \frac{P\left(Y=c_{k}\right) \prod_{j}P\left(X^{(j)}=x^{(j)} \mid Y=c_{k}\right)}{\sum_{k}P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} \midY=c_{k}\right)}\]</span></p><p>由于上式中的分母都是相同的，而且只要求最大值而不是准确值，所以还可以进一步简化为</p><p><span class="math display">\[y=\arg \max _{c_{k}} P\left(Y=c_{k}\right) \prod_{j}P\left(X^{(j)}=x^{(j)} \mid Y=c_{k}\right)\]</span></p><p>值得一提的是，后验概率最大化等价于期望风险最小化。</p><h2 id="极大似然估计法">3.极大似然估计法</h2><p>我们现在只要知道先验概率和条件概率，就可以估计出新实例是属于哪一类的了。</p><p>某一类别的先验概率可以用训练集中该类的数量占总数量的比例来似然估计，即</p><p><span class="math display">\[P\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N}I\left(y_{i}=c_{k}\right)}{N}, k=1,2, \cdots, K\]</span></p><p>其中N是样本总量，I是判别函数。</p><p>同理条件概率也可以同个数数获得，当第j个特征<spanclass="math inline">\(x^{(j)}\)</span>的可能取值为<spanclass="math inline">\({a_{j1},a_{j2},...,a_{js}}\)</span>时</p><p><span class="math display">\[P\left(X^{(j)}=a_{j l} \mid Y=c_{k}\right)=\frac{\sum_{i=1}^{N}I\left(x_{i}^{(j)}=a_{j l}, y_{i}=c_{k}\right)}{\sum_{i=1}^{N}I\left(y_{i}=c_{k}\right)}\]</span></p><h2 id="贝叶斯估计">4.贝叶斯估计</h2><p>极大似然估计符合人类对样本的直观感受，但可能会因为数据集的问题出现要估计的概率值为0的情况，这可能会影响到后面的计算结果。</p><p>为此引入贝叶斯估计，条件概率的贝叶斯估计是</p><p><span class="math display">\[P_{\lambda}\left(X^{(j)}=a_{j l} \midY=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(j)}=a_{j l},y_{i}=c_{k}\right)+\lambda}{\sum_{i=1}^{N}I\left(y_{i}=c_{k}\right)+S_{j} \lambda}\]</span></p><p>其中<span class="math inline">\(\lambda \ge0\)</span>等价于在随机变量的各个取值中都赋予一个正数，为1时，称为拉普拉斯平滑。<spanclass="math inline">\(S_{j} \lambda\)</span>是为了加上分子中<spanclass="math inline">\(\lambda\)</span>后使概率和仍为1.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;朴素贝叶斯法是基于贝叶斯定理与特征独立假设的分类方法，假设出数据集的输入输出的联合概率分布，然后基于此模型利用贝叶斯定理求出给定的输入x对应的后验概率最大的输出y。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="统计学习" scheme="https://splendidwave.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>统计学习(3)--k近邻和k均值</title>
    <link href="https://splendidwave.github.io/2022/11/25/2022-11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(3)--k%E8%BF%91%E9%82%BB%E5%92%8Ck%E5%9D%87%E5%80%BC/"/>
    <id>https://splendidwave.github.io/2022/11/25/2022-11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(3)--k%E8%BF%91%E9%82%BB%E5%92%8Ck%E5%9D%87%E5%80%BC/</id>
    <published>2022-11-25T05:02:03.000Z</published>
    <updated>2022-12-10T11:02:18.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>k-NN和k-mean介绍</p><span id="more"></span><h2 id="k近邻算法">1.k近邻算法</h2><p>k近邻法（k-nearest neighbor，k-NN）是一种基本分类与回归方法。</p><p>k近邻法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。</p><p>具体对于新的实例x，在训练集中找到与之相邻的k个实例，这k个实例的多数属于哪一类，就把这个实例分到哪一类中。当k为1时，称为最近邻算法。</p><h3 id="k近邻模型">2.k近邻模型</h3><p>k近邻的算法非常简单，主要在于距离度量、k值和分类决策三者的选取。</p><ol type="1"><li>度量距离<ol type="1"><li>欧氏距离</li><li>Lp距离（Lp distance）</li><li>Minkowski距离（Minkowski distance）</li></ol></li><li>k值<ol type="1"><li>选小会比较敏感</li><li>增大意味着整体模型变得简单</li></ol></li><li>分类决策<ol type="1"><li>多数表决等价于经验风险最小化</li></ol></li></ol><h3 id="kd树">3.kd树</h3><p>k近邻没有给出一个显式的表达式，而是每一次判定都是需要计算所有点到实例的距离，然后选取最近的k个点表决。所以当总量N越来越大时，算法会变得越来越慢。</p><p>为实现快速k近邻搜索，可以采用特殊结构存储，称为kd树。kd树是二叉树，表示对k维空间的一个划分（partition）。构造kd树相当于不断地用垂直于坐标轴的超平面将k维空间切分，构成一系列的k维超矩形区域。kd树的每个结点对应于一个k维超矩形区域。</p><h4 id="构造">3.1 构造</h4><p>输入：实例</p><p>输出：kd树</p><p>具体构造方式如下：</p><p>输入k维空间数据集：</p><p><span class="math display">\[\mathrm{T}=\left\{\mathrm{x}_{1}, \mathrm{x}_{2}, \ldots,\mathrm{x}_{\mathrm{N}}\right\}\]</span></p><p>其中</p><p><span class="math display">\[x_{i}=\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots,x_{i}^{(k)}\right)^{\mathrm{T}} , i  =1,2, \ldots, \mathrm{N}\]</span></p><ol type="1"><li>构造根节点</li></ol><p>选取<spanclass="math inline">\(x^{(1)}\)</span>为坐标轴（这里也可以从方差最大的开始选），以所有数据的<spanclass="math inline">\(x^{(1)}\)</span>特征的中位数作为切分点，生出深度为1的左右子节点。左小右大。</p><ol start="2" type="1"><li>重复分割</li></ol><p>对深度为j的节点，选取<spanclass="math inline">\(x^{(l)}\)</span>为切分坐标轴，<spanclass="math inline">\(l=j(mod\enspace k)+1\)</span></p><p>生成j+1的左右子节点。</p><ol start="3" type="1"><li>直到两个子区域没有实例</li></ol><h4 id="搜索">3.2 搜索</h4><p>输入：kd树，目标x</p><p>输出：x的最近邻点</p><ol type="1"><li><p>从根节点出发递归地向下访问kd树。若目标点x当前维的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点。直到子结点为叶结点为止。</p></li><li><p>记当前叶节点为最近点</p></li><li><p>检查另一子结点对应的区域是否与以目标点为球心、以目标点与“当前最近点”间的距离为半径的超球体相交。如果相交，移动到另一个子结点进行递归最近邻搜索；如果不相交，向上回退。如果存在更近点则更新最近点。</p></li></ol><p>(4)退回根节点后的最近点即为最近点。</p><h2 id="k-mean">4.k-mean</h2><p>k-means是一种聚类算法，是无监督学习算法。它将训练数据分为k组，每一组是一个簇，随机选择k个实例作为初始的聚类中心点，对于每一个实例，计算它和这k个聚类中心的距离，然后把它分配到与它距离最近的聚类中心所在的簇中去；计算每个簇中所有实例的平均值，作为新的聚类中心点，以此往复，直至聚类中心点不再发生明显变化。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;k-NN和k-mean介绍&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="统计学习" scheme="https://splendidwave.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>统计学习(2)--感知机</title>
    <link href="https://splendidwave.github.io/2022/11/23/2022-11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(2)--%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <id>https://splendidwave.github.io/2022/11/23/2022-11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(2)--%E6%84%9F%E7%9F%A5%E6%9C%BA/</id>
    <published>2022-11-23T02:56:02.000Z</published>
    <updated>2022-12-10T11:55:12.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>感知机</p><span id="more"></span><h2 id="感知机的定义">1.感知机的定义</h2><p>对于一个输入空间，如果存在一个超平面将实例分为正负两类，那么可以认为输入空间的输出空间可以通过如下函数实现。</p><p><span class="math display">\[f(x)=\operatorname{sign}(w^T \cdot x+b)\]</span></p><p>该模型被称为感知机模型，其中<spanclass="math inline">\(w^T\)</span>和<spanclass="math inline">\(b\)</span>是感知机模型参数，线性方程</p><p><span class="math display">\[w^T \cdot x+b\]</span></p><p>是在特征空间中的一个超平面，其中<spanclass="math inline">\(w\)</span>是超平面的法向量，b是超平面的截距。</p><p><spanclass="math inline">\(\operatorname{sign}\)</span>是符号函数</p><p><span class="math display">\[\operatorname{sign}(x)=\left\{\begin{array}{ll}+1, &amp; x \geqslant 0 \\-1, &amp; x&lt;0\end{array}\right.\]</span></p><h2 id="感知机学习策略">2.感知机学习策略</h2><h3 id="损失函数">2.1 损失函数</h3><p>感知机损失函数的一个自然选择是误分类点的总数，但这样损失函数不是参数<spanclass="math inline">\(w\)</span>、<spanclass="math inline">\(b\)</span>连续可导函数，不容易优化。</p><p>另一个选择是点到超平面S的总距离。</p><p>记空间中点为<span class="math inline">\(X^{(i)}\)</span>，超平面为<span class="math inline">\(w^T \cdot X+b\)</span>，空间中的任意一点到平面的距离 =该点到平面任意一点的向量在平面的法向量上的投影。</p><p><span class="math display">\[\begin{array}{l}D=\left|\frac{w}{\|w\|_{2}} \cdot\left(X^{(i)}-X^{(0)}\right)\right| \\=\left|\frac{1}{\|w\|_{2}} \cdot\left(w^{T} \cdot X^{(i)}-w^{T} \cdotX^{(0)}\right)\right| \\=\left|\frac{1}{\|w\|_{2}} \cdot\left(w^{T} \cdotX^{(i)}+b\right)\right|\end{array}\]</span></p><p>其中<span class="math inline">\(X^{(0)}\)</span>是超平面上的点。</p><p>对于误分类数据<span class="math inline">\(\left(x_{i},y_{i}\right)\)</span>来说，</p><p><span class="math display">\[-y_{i}\left(w^T \cdot x_{i}+b\right)&gt;0\]</span></p><p>假设误分类点集合为<spanclass="math inline">\(M\)</span>,那么所有误分类点到超平面的总距离为</p><p><span class="math display">\[-\frac{1}{\|w\|} \sum_{x_{i} \in M} y_{i}\left(w^T \cdot x_{i}+b\right)\]</span></p><p>不考虑常数<spanclass="math inline">\(\frac{1}{\|w\|}\)</span>,即可得到感知机学习的损失函数。这里省略转置，下同。</p><p><span class="math display">\[L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdot x_{i}+b\right)\]</span></p><p>该损失函数就是感知机的经验风险函数。</p><h3 id="随机梯度下降">2.2 随机梯度下降</h3><p>对于感知机模型来说最优化方法是随机梯度下降法，损失函数如下</p><p><span class="math display">\[\min _{w, b} L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdotx_{i}+b\right)\]</span></p><p>梯度计算如下</p><p><span class="math display">\[\nabla_{w} L(w, b)=-\sum_{x_{j} \in M} y_{i} x_{i} \\\]</span></p><p><span class="math display">\[\nabla_{b} L(w, b)=-\sum_{x_{i} \in M} y_{i}\]</span></p><p>为此选取更新策略为</p><p><span class="math display">\[\begin{array}{c}w \leftarrow w+\eta y_{i} x_{i} \\b \leftarrow b+\eta y_{i}\end{array}\]</span></p><h2 id="收敛性证明">3.收敛性证明</h2><p>将超平面简记为<spanclass="math inline">\(\hat{w}\cdot\hat{x}\)</span></p><p>设训练集线性可分，则存在一个超平面<spanclass="math inline">\(\hat{w}_{opt}\cdot\hat{x}\)</span>使得训练集完全正确分开，令<spanclass="math inline">\(\|\hat{w}_{opt}\|=1\)</span>, 那么对有限的<spanclass="math inline">\(i=1,2,...,N\)</span>均有</p><p><span class="math display">\[y_{i}\left(\hat{w}_{\text {opt }} \cdot\hat{x}_{i}\right)=y_{i}\left(w_{\text {opt }} \cdot x_{i}+b_{\text {opt}}\right) \geqslant \gamma \tag{式1}\]</span></p><p>其中</p><p><span class="math display">\[\gamma=\min _{i}\left\{y_{i}\left(w_{\mathrm{opt}} \cdotx_{i}+b_{\mathrm{opt}}\right)\right\}\]</span></p><p>根据更新公式</p><p><span class="math display">\[\begin{array}{l}w_{k} \leftarrow w_{k-1}+\eta y_{i} x_{i} \\b_{k} \leftarrow b_{k-1}+\eta y_{i}\end{array}\]</span></p><p>可得</p><p><span class="math display">\[\hat{w}_{k}=\hat{w}_{k-1}+\eta y_{i} \hat{x}_{i}\]</span></p><p>假设初始值为<span class="math inline">\(\hat{w}_0 =0\)</span>时,需要k次迭代达到最优值，有</p><p><span class="math display">\[\begin{aligned}\hat{w}_k\cdot\hat{w}_{\text{opt}} &amp; = (\hat{w}_{k-1}+\eta y_{i}\hat{x}_{i})\cdot\hat{w}_{\text{opt}} \\&amp; = \hat{w}_{k-1} \cdot \hat{w}_{\mathrm{opt}}+\eta y_{i}\hat{w}_{\mathrm{opt}} \cdot \hat{x}_{i} \\&amp; \geqslant  \hat{w}_{k-1} \cdot \hat{w}_{\mathrm{opt}}+ \eta \gamma\\&amp; \geqslant \cdots \\&amp; \geqslant  \hat{w}_{0} \cdot \hat{w}_{\mathrm{opt}}+ k\eta \gamma\\&amp;  =  k\eta \gamma\end{aligned}\]</span></p><p>另外有</p><p><span class="math display">\[\begin{aligned}\left\|\hat{w}_{k}\right\|^{2} &amp;=\left\|\hat{w}_{k-1}\right\|^{2}+2\eta y_{i} \hat{w}_{k-1} \cdot\hat{x}_{i}+\eta^{2}\left\|\hat{x}_{i}\right\|^{2} \\&amp;\leqslant\left\|\hat{w}_{k-1}\right\|^{2}+\eta^{2}\left\|\hat{x}_{i}\right\|^{2}\\&amp; \leqslant\left\|\hat{w}_{k-1}\right\|^{2}+\eta^{2} R^{2} \\&amp; \leqslant\left\|\hat{w}_{k-2}\right\|^{2}+2 \eta^{2} R^{2} \\&amp; \leqslant \cdots \\&amp; \leqslant k \eta^{2} R^{2}\end{aligned}\]</span></p><p>结合上述两式可得不等式</p><p><span class="math display">\[k \eta \gamma \leqslant \hat{w}_{k} \cdot \hat{w}_{\mathrm{opt}}\leqslant\left\|\hat{w}_{k}\right\|\left\|\hat{w}_{\mathrm{opt}}\right\|\leqslant \sqrt{k} \eta R\]</span></p><p>即对于k有</p><p><span class="math display">\[k \leqslant\left(\frac{R}{\gamma}\right)^{2}\]</span></p><p>该不等式的意义指出如果空间线性可分，迭代次数是有上界的。</p><h2 id="感知机学习算法的对偶形式">4.感知机学习算法的对偶形式</h2><p>在初始值为0的时候，对于N次迭代后参数<spanclass="math inline">\(w\)</span>、<spanclass="math inline">\(b\)</span>分别为</p><p><span class="math display">\[w=\sum_{i=1}^{N} \alpha_{i} y_{i} x_{i} \tag{式2}\]</span></p><p><span class="math display">\[b=\sum_{i=1}^{N} \alpha_{i} y_{i}\]</span></p><p>其中<span class="math inline">\(\alpha_{i} =\mathrm{n}_{\mathrm{i}}\eta\)</span>，<spanclass="math inline">\(\eta\)</span>为学习率，当<spanclass="math inline">\(\eta=1\)</span>时，<spanclass="math inline">\(\alpha_{i}\)</span>就代表了第<spanclass="math inline">\(i\)</span>个实例由于误分而进行更新的次数。通常这个点会越接近分离超平面，因为这些点比较难被分类，它们对学习结果的影响最大。</p><p>使用(式2)代替损失函数的<spanclass="math inline">\(w\)</span>值，可得对偶形式的训练条件为</p><p>当</p><p><span class="math display">\[y_{i}\left(\sum_{j=1}^{N} \alpha_{j} y_{j} x_{j} \cdot x_{i}+b\right)\leqslant 0\tag{式3}\]</span></p><p>则</p><p><span class="math display">\[\alpha_{i} \leftarrow \alpha_{i}+\eta\]</span></p><p><span class="math display">\[b \leftarrow b+\eta y_{i}\]</span></p><p>由于(式3)中出现了大量内积形式的训练实例，可以预先将训练集的实例计算出来并储存为Gram矩阵</p><p>Gram矩阵的定义是</p><p><span class="math display">\[G=A^{T} A=\left[\begin{array}{c}\mathbf{a}_{1}^{T} \\\mathbf{a}_{2}^{T} \\\vdots \\\mathbf{a}_{n}^{T}\end{array}\right]\left[\begin{array}{llll}\mathbf{a}_{1} &amp; \mathbf{a}_{2} &amp; \cdots &amp; \mathbf{a}_{n}\end{array}\right]\\=\left[\begin{array}{cccc}\mathbf{a}_{1}^{T} \mathbf{a}_{1} &amp; \mathbf{a}_{1}^{T}\mathbf{a}_{2} &amp; \cdots &amp; \mathbf{a}_{1}^{T} \mathbf{a}_{n} \\\mathbf{a}_{2}^{T} \mathbf{a}_{1} &amp; \mathbf{a}_{2}^{T}\mathbf{a}_{2} &amp; \cdots &amp; \mathbf{a}_{2}^{T} \mathbf{a}_{n} \\\mathbf{a}_{n}^{T} \mathbf{a}_{1} &amp; \mathbf{a}_{n}^{T}\mathbf{a}_{2} &amp; \cdots &amp; \mathbf{a}_{n}^{T} \mathbf{a}_{n}\end{array}\right]\]</span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;感知机&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="统计学习" scheme="https://splendidwave.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>统计学习(1)--定义速查</title>
    <link href="https://splendidwave.github.io/2022/11/18/2022-11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(1)--%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://splendidwave.github.io/2022/11/18/2022-11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(1)--%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2022-11-18T07:01:02.000Z</published>
    <updated>2023-04-19T07:48:52.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>统计学习/机器学习基本名词解释</p><span id="more"></span><h2 id="人工智能artificial-intelligence-ai">人工智能(ArtificialIntelligence, AI)</h2><p>人工智能指拥有类似与人类的自主思考甚至学习的计算机程序或系统。可分为弱人工智能和强人工智能。</p><h2 id="统计学习statistical-learning">统计学习(StatisticalLearning)</h2><p>统计学习是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。也被称为统计机器学习(statisticalmachine learning)。</p><p>统计学习是机器学习的数学基础。</p><h2 id="机器学习分类">机器学习分类</h2><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210192601.png"alt="思维导图" /><figcaption aria-hidden="true">思维导图</figcaption></figure><h2 id="机器学习流程">机器学习流程</h2><ol type="1"><li>获取数据</li><li>数据洞见与可视化</li><li>数据清洗与预处理</li><li>模型选择与训练</li><li>调整模型</li><li>启动监控与维护系统</li></ol><h2 id="输入空间输出空间特征空间">输入空间、输出空间、特征空间</h2><p>输入与输出所有可能取值的集合分别称为输入空间（inputspace）与输出空间（output space）。这里的空间通常属于欧式空间。</p><p>输入空间的具体输入是一个实例(instance)，通常使用特征向量(featurevector)表示。特征向量所在的空间称为特征空间(feature space)。</p><p>输入变量与输出变量均为连续变量的预测问题称为回归问题；输出变量为有限个离散变量的预测问题称为分类问题；输入变量与输出变量均为变量序列的预测问题称为标注问题。</p><h2 id="符号表示">符号表示</h2><p>在习惯上将输入变量记作X，输出变量记作Y，输入输出变量的取值用小写字母x/y表示。向量通常为列向量</p><p>输入实例x的特征向量记作</p><p><span class="math display">\[x=\left(x^{(1)}, x^{(2)}, \cdots, x^{(i)}, \cdots,x^{(n)}\right)^{\mathrm{T}}\]</span></p><p>其中<span class="math inline">\(x^{(i)}\)</span>表示<spanclass="math inline">\(x\)</span>的<spanclass="math inline">\(i\)</span>个特征，如果是下标<spanclass="math inline">\(x_i\)</span>则表示这是第<spanclass="math inline">\(i\)</span>个变量。</p><p>监督学习训练数据由输入(或特征向量)与输出对构成，通常表示为 <spanclass="math display">\[T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right),\cdots,\left(x_{N}, y_{N}\right)\right\}\]</span></p><h2 id="统计学习三要素">统计学习三要素</h2><p><strong>方法＝模型＋策略＋算法</strong></p><h3 id="模型">模型</h3><p>称由<strong>决策函数</strong>表示的模型为非概率模型，由<strong>条件概率</strong>表示的模型为概率模型。</p><p>所有模型构成的空间称为假设空间(hypothesis space)</p><h3 id="策略">策略</h3><p><strong>损失函数</strong>，使用损失函数(代价函数)度量模型一次预测的好坏（loss function / cost function）</p><p>常用的损失函数有以下几种： 1. 0-1损失函数</p><p><span class="math display">\[L(Y, f(X))=\left\{\begin{array}{ll}1, &amp; Y \neq f(X) \\0, &amp; Y=f(X)\end{array}\right.\]</span></p><ol start="2" type="1"><li>平方损失函数</li></ol><p><span class="math display">\[L(Y, f(X))=(Y-f(X))^{2}\]</span></p><ol start="3" type="1"><li>绝对损失函数</li></ol><p><span class="math display">\[L(Y, f(X))=|Y-f(X)|\]</span></p><ol start="4" type="1"><li>对数损失函数/对数似然损失函数</li></ol><p><span class="math display">\[L(Y, P(Y \mid X))=-\log P(Y \mid X)\]</span></p><p>损失函数值越小，模型就越好。因此可以计算以下损失函数的数学期望</p><p><span class="math display">\[R_{\exp }(f)=E_{P}[L(Y, f(X))]=\int_{xy} L(y, f(x)) P(x, y) \mathrm{d} x\mathrm{~d} y\]</span></p><p>其中<span class="math inline">\(P(x,y)\)</span>服从<spanclass="math inline">\((X,Y)\)</span>的联合概率分布，<spanclass="math inline">\(R_{\exp }(f)\)</span> 被称为风险函数（riskfunction）或 期望损失（expected loss）或<strong>期望风险</strong>。</p><p>但由于联合分布未知，这里需要使用训练集的平均损失<spanclass="math inline">\(R_{\text {emp}}\)</span>来近似估计期望风险，公式如下</p><p><span class="math display">\[R_{\text {emp }}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i},f\left(x_{i}\right)\right)\]</span></p><p>它被称为<strong>经验风险</strong></p><h3 id="算法">算法</h3><p>算法是指学习模型的<strong>具体计算方法</strong>，习可以利用已有的最优化算法，有时也需要开发独自的最优化算法。</p><h2id="经验风险最小化empirical-risk-minimizationerm">经验风险最小化(empiricalrisk minimization，ERM)</h2><p>当样本容量足够大时，经验风险最小化能保证有很好的学习效果，在现实中被广泛采用。公式为</p><p><span class="math display">\[\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i},f\left(x_{i}\right)\right)\]</span></p><p>其中<span class="math inline">\(\mathcal{F}\)</span>为假设空间</p><h2id="结构风险最小化structural-risk-minimizationsrm">结构风险最小化(structuralrisk minimization，SRM)</h2><p>经验风险最小化的准确度取决于样本，为了防止过拟合，提出了结构风险最小化，结构风险最小化等价于正则化（regularization），定义为</p><p><span class="math display">\[R_{\mathrm{sm}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i},f\left(x_{i}\right)\right)+\lambda J(f)\]</span></p><p>其中<spanclass="math inline">\(J(f)为模型的复杂度\)</span>$是系数通常大于0</p><h2 id="模型的训练与评估">模型的训练与评估</h2><h3 id="训练误差与测试误差">训练误差与测试误差</h3><p>数据集通常分为训练集和测试集，在选定损失函数后，训练误差和测试误差成为学习方法评估的标准。</p><p>训练误差的大小，对判断给定的问题是不是一个容易学习的问题是有意义的，但本质上不重要。测试误差反映了学习方法对未知的测试数据集的预测能力，是学习中的重要概念。显然，给定两种学习方法，测试误差小的方法具有更好的预测能力，是更有效的方法。通常将学习方法对未知数据的预测能力称为泛化能力（generalizationability）</p><h3 id="过拟合">过拟合</h3><p>如果一味追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高。这种现象称为过拟合（over-fitting）。过拟合是指学习时选择的模型所包含的参数过多，以致于出现这一模型对已知数据预测得很好，但对未知数据预测得很差的现象。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210192722.png"alt="训练误差与测试误差" /><figcaption aria-hidden="true">训练误差与测试误差</figcaption></figure><h3 id="正则化">正则化</h3><p>为对抗过拟合的情况，一个典型的方法是引入正则化（regularization），正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大。一般形式如下</p><p><span class="math display">\[\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i},f\left(x_{i}\right)\right)+\lambda J(f)\]</span></p><p>其中第一项是经验风险，第二项是正则化项，<spanclass="math inline">\(\lambda\)</span>是两者关系系数，其值大于0</p><p>通常会使用2范数来作为正则项</p><p><span class="math display">\[L(w)=\frac{1}{N} \sum_{i=1}^{N}\left(f\left(x_{i} ;w\right)-y_{i}\right)^{2}+\frac{\lambda}{2}\|w\|^{2}\]</span></p><p>其中<span class="math inline">\(w\)</span>是特征向量，<spanclass="math inline">\(\|w\|^2\)</span>是向量<spanclass="math inline">\(w\)</span>的2范数</p><h3 id="交叉验证">交叉验证</h3><p>如果给定的样本数据充足，进行模型选择的一种简单方法是随机地将数据集切分成三部分，分别为训练集（trainingset）、验证集（validation set）和测试集（test set）。</p><p>但是，在许多实际应用中数据是不充足的。为了选择好的模型，可以采用交叉验证方法。可以重复多少使用数据。</p><ol type="1"><li><p>简单交叉验证随机将数据分为训练集(通常为70%)和测试集(通常为30%)。</p></li><li><p>S折交叉验证（S-fold cross validation）首先随机地将已给数据切分为S个互不相交的大小相同的子集；然后利用S-1个子集的数据训练模型，利用余下的子集测试模型；将这一过程对可能的S种选择重复进行；最后选出S次评测中平均测试误差最小的模型。</p></li><li><p>留一交叉验证（leave-one-out cross validation）将S折的S取为N，这里N是数据集的总容量。</p></li></ol><h2 id="生成模型与判别模型">生成模型与判别模型</h2><ol type="1"><li>生成模型</li></ol><p>生成方法（generativeapproach）由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型：</p><p><span class="math display">\[P(Y \mid X)=\frac{P(X, Y)}{P(X)}\]</span></p><p>模型表示了给定输入X产生输出Y的生成关系。典型的生成模型有：朴素贝叶斯法和隐马尔可夫模型</p><ol start="2" type="1"><li>判别模型</li></ol><p>判别方法（discriminativeapproach）直接学习决策函数f(X)或者条件概率分布P(Y|X)作为预测的模型，即判别模型。</p><p>典型的判别模型包括：k近邻法、感知机、决策树、逻辑斯谛回归模型、最大熵模型、支持向量机。</p><h2 id="问题分类">问题分类</h2><h3 id="分类问题">分类问题</h3><p>算法从数据中学习一个分类模型或分类决策函数，称为分类器（classifier）。分类器对新的输入进行输出的预测（prediction），称为分类（classification）。可能的输出称为类（class）。</p><p>评价分类器性能的指标一般是分类准确率（accuracy）也就是损失函数为0-1损失函数时测试集上的准确率。</p><p>分类最常见的是二分问题，当然其他分类其实也可以归为多个二分问题。对于二类分类问题常用的评价指标是精确率（precision）与召回率（recall）。将关注的类记为<strong>正类</strong>，其他类为<strong>负类</strong>，根据模型判别的对错可以分为四种情况，将他们出现的总是记为如下符号</p><p>TP——将正类预测为正类数； FN——将正类预测为负类数；FP——将负类预测为正类数； TN——将负类预测为负类数。</p><p><strong>精准率</strong>的定义为</p><p><span class="math display">\[P=\frac{T P}{T P+F P}\]</span></p><p><strong>召回率</strong>的定义为</p><p><span class="math display">\[R=\frac{T P}{T P+F N}\]</span></p><p><strong><spanclass="math inline">\(F_1\)</span>值</strong>是，精准率和召回率的调和均值</p><p><span class="math display">\[\frac{2}{F_1}=\frac{1}{P}+\frac{1}{R}\]</span></p><p><span class="math display">\[F_1=\frac{2 T P}{2 T P+F P+F N}\]</span></p><p><strong>混淆矩阵</strong>（ConfusionMatrix），又称为可能性矩阵或错误矩阵。是分类结果的一个可视化表现。形如</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210192755.png"alt="混淆矩阵" /><figcaption aria-hidden="true">混淆矩阵</figcaption></figure><h3 id="标注问题">标注问题</h3><p>标注（tagging）可以认为是分类问题的一个推广，输入是一组序列，输出也是一组序列。</p><h3 id="回归问题">回归问题</h3><p>回归（regression）用于预测输入变量（自变量）和输出变量（因变量）之间的关系，特别是当输入变量的值发生变化时，输出变量的值随之发生的变化。</p><p>回归学习最常用的损失函数是平方损失函数，在此情况下，回归问题可以由著名的最小二乘法（leastsquares）求解。</p><h2 id="梯度下降法">梯度下降法</h2><p>梯度下降法（Gradientdescent）是迭代法的一种，利用求偏导的方法更新参数，实现找到极值。公式如下</p><p><span class="math display">\[w_{i+1}=w_{i}-\alpha * \frac{d L}{d w_{i}}\]</span></p><p>其中<spanclass="math inline">\(\alpha\)</span>是学习率，其值影响迭代的速度，过大可能导致不收敛，过小收敛速度慢，且可能会陷入局部最优解。</p><p>批量梯度下降（Batch GradientDescent，BGD）每一次迭代会对所有样本进行计算，具有全局性，但计算量大</p><p>随机梯度下降（Stochastic GradientDescent，SGD）随机梯度下降是每次迭代使用一个样本来对参数进行更新，速度快但准确度可能会下降</p><p>小批量梯度下降（Mini-Batch Gradient Descent,MBGD）中和上述两者特性</p><h2 id="感知机">感知机</h2><p>感知机（perceptron）是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，其通过一个超平面分离，输出取+1和–1二值。</p><p>单个感知机不能处理异或问题，多个感知机可以构成神经网络。</p><h2 id="支持向量机">支持向量机</h2><p>支持向量机的学习的目标也是在特征空间中找到一个分离超平面，能将实例分到不同的类。不同与感知机的解有无穷多个，线性可分支持向量机利用间隔最大化求最优分离超平面，解是唯一的。</p><p>支持向量机可以通过变换处理非线性分类问题。</p><h2 id="k近邻算法">k近邻算法</h2><p>k近邻法（k-nearest neighbor，k-NN）是一种基本分类与回归方法。</p><p>k近邻法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。</p><p>具体对于新的实例x，在训练集中找到与之相邻的k个实例，这k个实例的多数属于哪一类，就把这个实例分到哪一类中。当k为1时，称为最近邻算法。</p><h2 id="k-mean">k-mean</h2><p>k-means是一种聚类算法，是无监督学习算法。它将训练数据分为k组，每一组是一个簇，随机选择k个实例作为初始的聚类中心点，对于每一个实例，计算它和这k个聚类中心的距离，然后把它分配到与它距离最近的聚类中心所在的簇中去；计算每个簇中所有实例的平均值，作为新的聚类中心点，以此往复，直至聚类中心点不再发生明显变化。</p><h2 id="朴素贝叶斯">朴素贝叶斯</h2><p>朴素贝叶斯对实际问题进行了简化假设，利用概率最大这一符合人脑对事物的判断的方法实现对输入实例的分类。</p><h2 id="决策树">决策树</h2><p>分类决策树从根节点开始对实例的某个特征进行测试判别，然后将实例分配到对应节点，反复递归最终实现实例的全部分类。</p><p>决策树的特性决定了它会倾向于多分类，为此需要使用剪枝或修改判别依据来优化模型。</p><h2 id="逻辑斯谛回归">逻辑斯谛回归</h2><p>逻辑斯谛回归模型利用了逻辑斯谛方程的对数特性，将特征参数映射到[0，1]之间，将问题转换为概率预测，从而实现判别。</p><h2 id="最大熵">最大熵</h2><p>最大熵原理是概率模型学习的一个准则。其观点认为熵最大的模型就是最好的模型。</p><!-- ## 提升## EM算法## 隐马尔可夫模型## 条件随机场 -->]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;统计学习/机器学习基本名词解释&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="统计学习" scheme="https://splendidwave.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>opencv-python学习(6)--六个图像处理小项目</title>
    <link href="https://splendidwave.github.io/2022/10/29/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(6)--%E5%85%AD%E4%B8%AA%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    <id>https://splendidwave.github.io/2022/10/29/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(6)--%E5%85%AD%E4%B8%AA%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%B0%8F%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-10-29T07:47:32.000Z</published>
    <updated>2022-12-10T12:06:50.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>opencv的python图像处理学习笔记</p><p>转像素画、转字符画、图片九宫格、图片蒙太奇、幻影坦克、证件照裁剪。</p><p>部分代码参考互联网。 <span id="more"></span></p><h2 id="图像转像素画">1.图像转像素画</h2><p>效果如下</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200353.png"alt="可莉像素" /><figcaption aria-hidden="true">可莉像素</figcaption></figure><p>实现原理是通过将图片缩小10倍，然后用最邻近插值放大回原来的尺寸。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 图片像素化</span><br><span class="line">def pixel_image(self):</span><br><span class="line">    img = self.image.copy()</span><br><span class="line">    rows, cols = img.shape[:2]</span><br><span class="line">    img = cv2.resize(img,(cols//10,rows//10))</span><br><span class="line">    img = cv2.resize(img,(cols,rows),interpolation=cv2.INTER_NEAREST)</span><br><span class="line">    win_name = &quot;pixel&quot;</span><br><span class="line">    UIFunctions.wait_key(self,img,win_name)</span><br></pre></td></tr></table></figure><p>其中<code>wait_key</code>函数内容是用opencv打开图片，然后接受一些保存等指令的函数。</p><h2 id="图片转字符画">2.图片转字符画</h2><p>效果图</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200413.jpg"alt="字符画" /><figcaption aria-hidden="true">字符画</figcaption></figure><p>原理是把图片转为灰度，然后根据灰度值将像素替换为对应字重的字符最后保存为txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 转为字符画</span><br><span class="line">def character_image(self):</span><br><span class="line">    img = UIFunctions.trun_gray(self,self.image)</span><br><span class="line">    rows, cols = img.shape[:2]</span><br><span class="line">    rows = rows//2</span><br><span class="line">    img = cv2.resize(img,(cols,rows))</span><br><span class="line">    lstChars = self.config.get(&#x27;General&#x27;,&#x27;file_character_list&#x27;)</span><br><span class="line">    output = self.config.get(&#x27;General&#x27;,&#x27;file_save_path&#x27;) + &quot;\\character.txt&quot;</span><br><span class="line">    g2c = 256/len(lstChars)</span><br><span class="line">    </span><br><span class="line">    txt = &quot;&quot;</span><br><span class="line">    for i in range(rows):</span><br><span class="line">        for j in range(cols):</span><br><span class="line">            txt += lstChars[int(img[i,j]/g2c)]</span><br><span class="line">        txt += &#x27;\n&#x27;</span><br><span class="line"></span><br><span class="line">    with open(output, &#x27;w&#x27;) as f:</span><br><span class="line">        f.write(txt)</span><br><span class="line">    QMessageBox.information(None, &#x27;提示&#x27;, &#x27;character.txt输出成功&#x27;,QMessageBox.Ok)</span><br></pre></td></tr></table></figure><p>为了表现效果，这里将高缩了一半。output是文件路径，lstChars是自定义的字符。上图使用的字符串是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$B8&amp;WM*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|1?-_+~&lt;&gt;i!lI,^`.</span><br></pre></td></tr></table></figure><p>注意把字重大的放前面。</p><h2 id="图片九宫格">3.图片九宫格</h2><p>图片九宫格是发朋友圈常用的一种格式，该项目可以辅助将一张图片切割成9张。</p><p>效果</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200430.png"alt="图片九宫格" /><figcaption aria-hidden="true">图片九宫格</figcaption></figure><p>这个没啥说的就是切一下图片,因为懒得pip没用PIL库就直接对数组操作了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 九宫格</span><br><span class="line">def ninegrid_image(self):</span><br><span class="line">    # 切片函数</span><br><span class="line">    def cut_image(img,width):</span><br><span class="line">        box_list = []</span><br><span class="line">        if len(img.shape) == 2:</span><br><span class="line">            for i in range(0, 3):</span><br><span class="line">                for j in range(0, 3):</span><br><span class="line">                    box = img[i * width:(i+1) * width, j * width : (j + 1) * width]</span><br><span class="line">                    box_list.append(box)</span><br><span class="line">        elif len(img.shape) == 3:</span><br><span class="line">            for i in range(0, 3):</span><br><span class="line">                for j in range(0, 3):</span><br><span class="line">                    box = img[i * width:(i+1) * width, j * width : (j + 1) * width,:]</span><br><span class="line">                    box_list.append(box)</span><br><span class="line">        return box_list</span><br><span class="line"></span><br><span class="line">    img = self.image.copy()</span><br><span class="line">    value, ok = QInputDialog.getInt(self, &quot;输入窗口&quot;, &quot;请输入裁剪后的边值像素(正方形):&quot;, 300, 0, 2000, 100)</span><br><span class="line">    if ok:</span><br><span class="line">        value = int(value)*3</span><br><span class="line">        img = cv2.resize(img,(value,value))</span><br><span class="line">        box_list = cut_image(img,value//3)</span><br><span class="line">        for i,box in enumerate(box_list):</span><br><span class="line">            save_name = self.config.get(&#x27;General&#x27;,&#x27;file_save_path&#x27;) + &#x27;\\ninegrid_image\\&#x27; + str(i+1)+&#x27;.png&#x27;</span><br><span class="line">            cv2.imwrite(save_name,box)</span><br><span class="line">        QMessageBox.information(None, &#x27;提示&#x27;, &#x27;ninegrid_image输出成功&#x27;,QMessageBox.Ok)</span><br></pre></td></tr></table></figure><h2 id="图片蒙太奇">4.图片蒙太奇</h2><p>图片蒙太奇是指用一组图片去组合成一张大图的艺术效果。</p><p>图片有点大，放本地打开后再截图的图。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200548.jpg"alt="蒙太奇" /><figcaption aria-hidden="true">蒙太奇</figcaption></figure><p>代码主要参考CSDN<ahref="https://blog.csdn.net/Galen_xia/article/details/107955374">蒙太奇照片制作(Opencv+Python)</a></p><p>原理是缩放待处理图片，然后匹配区块和图片的直方图找到最合适的，最后做一个融合让效果变好些。</p><p>理论上图库内容丰富越好。</p><h2 id="幻影坦克">5.幻影坦克</h2><p>幻影坦克是现代互联网图片表示的艺术，缩略图上看是一张图，但实际点开就变成了另一张，常见于贴吧。</p><p>效果图</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200449.jpg"alt="幻影坦克" /><figcaption aria-hidden="true">幻影坦克</figcaption></figure><p>原理参考b站小迷糊老师的视频《<ahref="https://www.bilibili.com/video/BV1kV411v7fR/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">幻影坦克基础版</a>》</p><p>简单讲就是利用背景白色和黑色来叠加出不一样的图片。</p><p>灰度处理方面借用了《<ahref="https://blog.csdn.net/WinkySpeed/article/details/127079909">基于OpenCV实现的灰度图幻影坦克</a>》一文的思路</p><p>代码 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 幻影坦克</span><br><span class="line">def mirage_tank_image(self):</span><br><span class="line">    inside_pic = np.uint8(self.image.copy() * 0.35)</span><br><span class="line">    h,w = inside_pic.shape[:2]</span><br><span class="line">    get_filename_path, ok = QFileDialog.getOpenFileName(self,&quot;选取表图&quot;,self.config.get(&#x27;General&#x27;,&#x27;file_open_path&#x27;))</span><br><span class="line">    if ok:</span><br><span class="line">        out_pic = cv2.imread(get_filename_path)</span><br><span class="line">        # 调整表图大小 与里图一致</span><br><span class="line">        out_pic = cv2.resize(out_pic,(w,h))</span><br><span class="line">        # 如果强度小于100 拉到100</span><br><span class="line">        out_pic[out_pic&lt;100] = 100</span><br><span class="line">        # 转变为灰度图</span><br><span class="line">        inside_pic = UIFunctions.trun_gray(self,inside_pic)</span><br><span class="line">        out_pic = UIFunctions.trun_gray(self,out_pic)</span><br><span class="line">        # 建立新的画布 </span><br><span class="line">        new_pic = np.zeros((h,w,4), np.uint8)</span><br><span class="line">        # print(new_pic.shape)</span><br><span class="line">        # 遍历图片 套用公式</span><br><span class="line">        for i in range(h):</span><br><span class="line">            for j in range(w):</span><br><span class="line">                alpha = 255 - (out_pic[i,j]-inside_pic[i,j])</span><br><span class="line">                if alpha == 0:</span><br><span class="line">                    alpha = 1</span><br><span class="line">                p_new = np.uint8(255*inside_pic[i,j]/alpha)</span><br><span class="line">                new_pic[i,j,0] = p_new</span><br><span class="line">                new_pic[i,j,1] = p_new</span><br><span class="line">                new_pic[i,j,2] = p_new</span><br><span class="line">                new_pic[i,j,3] = alpha</span><br><span class="line">        win_name = &quot;tank&quot;</span><br><span class="line">        UIFunctions.wait_key(self,new_pic,win_name)</span><br></pre></td></tr></table></figure></p><h2 id="证件照处理">6.证件照处理</h2><p>如果你对证件照态度比较随便的话，可以直接用手机背靠墙拍一张，然后用这个方法处理，直接用打印机打印出来。</p><p>效果图</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200512.jpg"alt="证件照" /><figcaption aria-hidden="true">证件照</figcaption></figure><p>原理是建立对应大小的画布，然后把图片处理成1或2寸的，贴到对应位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"># 证件照处理</span><br><span class="line">def certificate_image(self):</span><br><span class="line">    # 1寸大小</span><br><span class="line">    WIDTH_1IN = 295</span><br><span class="line">    HEIGHT_1IN = 413</span><br><span class="line">    # 2寸大小</span><br><span class="line">    WIDTH_2IN = 413</span><br><span class="line">    HEIGHT_2IN = 626</span><br><span class="line">    # 5寸大小</span><br><span class="line">    WIDTH_5IN = 1500</span><br><span class="line">    HEIGHT_5IN = 1050</span><br><span class="line">    # 非全景6寸照片</span><br><span class="line">    WIDTH_6IN = 1950</span><br><span class="line">    HEIGHT_6IN = 1300</span><br><span class="line">    def cut_photo(photo,choice):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        将照片按照比例进行裁剪并缩放成1寸、2寸</span><br><span class="line">        :param photo: 待处理的照片</span><br><span class="line">        :param choice: &lt;int&gt; 1代表1寸，2代表2寸</span><br><span class="line">        :return: 处理后的照片</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        h,w = photo.shape[:2]</span><br><span class="line">        rate = h / w</span><br><span class="line">        if choice == 1:</span><br><span class="line">            if rate &lt; (HEIGHT_1IN/WIDTH_1IN):</span><br><span class="line">                cut = int((w - int(h / HEIGHT_1IN * WIDTH_1IN)) / 2)</span><br><span class="line">                cut_p = photo[:,cut:w-cut,:]</span><br><span class="line">            else:</span><br><span class="line">                cut = int((h - int(w / WIDTH_1IN * HEIGHT_1IN)) / 2)</span><br><span class="line">                cut_p = photo[cut:w-cut,:,:]</span><br><span class="line">            return cv2.resize(cut_p, (WIDTH_1IN, HEIGHT_1IN))</span><br><span class="line">        if choice == 2:</span><br><span class="line">            if rate &lt; (HEIGHT_2IN/WIDTH_2IN):</span><br><span class="line">                cut = int((w - int(h / HEIGHT_2IN * WIDTH_2IN)) / 2)</span><br><span class="line">                cut_p = photo[:,cut:w-cut,:]</span><br><span class="line">            else:</span><br><span class="line">                cut = int((h - int(w / WIDTH_2IN * HEIGHT_2IN)) / 2)</span><br><span class="line">                cut_p = photo[cut:w-cut,:,:]</span><br><span class="line">            return cv2.resize(cut_p, (WIDTH_2IN, HEIGHT_2IN))</span><br><span class="line"></span><br><span class="line">    # 5寸照排版1</span><br><span class="line">    def layout_photo_5_1(photo):</span><br><span class="line">        photo = cut_photo(photo,1)</span><br><span class="line">        img = np.ones((HEIGHT_5IN,WIDTH_5IN, 3), np.uint8)*255</span><br><span class="line">        img[HEIGHT_5IN//2,:,:] = 128            # 横线</span><br><span class="line">        img[:,int(WIDTH_5IN*0.25),:] = 128      # 竖线1</span><br><span class="line">        img[:,int(WIDTH_5IN*0.5),:] = 128      # 竖线2</span><br><span class="line">        img[:,int(WIDTH_5IN*0.75),:] = 128      # 竖线3</span><br><span class="line">        # 确定位置放上图片</span><br><span class="line">        focus_point = [0.125 * WIDTH_5IN,0.25 * HEIGHT_5IN]</span><br><span class="line">        start_point = [focus_point[0] - 0.5 * WIDTH_1IN, focus_point[1] - 0.5 * HEIGHT_1IN]</span><br><span class="line">        end_point = [focus_point[0] + 0.5 * WIDTH_1IN, focus_point[1] + 0.5 * HEIGHT_1IN]</span><br><span class="line">        for i in range(0,2):</span><br><span class="line">            for j in range(0,4):</span><br><span class="line">                img[int(start_point[1]+0.5*i*HEIGHT_5IN):int(end_point[1]+0.5*i*HEIGHT_5IN),int(start_point[0]+j*WIDTH_5IN/4):int(end_point[0]+j*WIDTH_5IN/4),:] = photo</span><br><span class="line">        return img</span><br><span class="line">    # 5寸混合排版2</span><br><span class="line">    def layout_photo_5_mix(photo):</span><br><span class="line">        photo1 = cut_photo(photo,1)</span><br><span class="line">        photo2 = cut_photo(photo,2)</span><br><span class="line">        photo2 = np.rot90(photo2)</span><br><span class="line">        img = np.ones((HEIGHT_5IN,WIDTH_5IN, 3), np.uint8)*255</span><br><span class="line">        img[HEIGHT_5IN//2,:,:] = 128            # 横线</span><br><span class="line">        img[:,int(WIDTH_5IN*0.25),:] = 128      # 竖线1</span><br><span class="line">        img[:,int(WIDTH_5IN*0.5),:] = 128      # 竖线2</span><br><span class="line">        # 确定位置放上1寸图片</span><br><span class="line">        focus_point = [0.125 * WIDTH_5IN,0.25 * HEIGHT_5IN]</span><br><span class="line">        start_point = [focus_point[0] - 0.5 * WIDTH_1IN, focus_point[1] - 0.5 * HEIGHT_1IN]</span><br><span class="line">        end_point = [focus_point[0] + 0.5 * WIDTH_1IN, focus_point[1] + 0.5 * HEIGHT_1IN]</span><br><span class="line">        for i in range(0,2):</span><br><span class="line">            for j in range(0,2):</span><br><span class="line">                img[int(start_point[1]+0.5*i*HEIGHT_5IN):int(end_point[1]+0.5*i*HEIGHT_5IN),int(start_point[0]+j*WIDTH_5IN/4):int(end_point[0]+j*WIDTH_5IN/4),:] = photo1</span><br><span class="line">        # 确定位置放上2寸图片</span><br><span class="line">        focus_point2 = [0.75 * WIDTH_5IN, 0.25 * HEIGHT_5IN]</span><br><span class="line">        start_point2 = [focus_point2[0] - 0.5 * HEIGHT_2IN, focus_point2[1] - 0.5 * WIDTH_2IN]</span><br><span class="line">        end_point2 = [focus_point2[0] + 0.5 * HEIGHT_2IN, focus_point2[1] + 0.5 * WIDTH_2IN]</span><br><span class="line">        img[int(start_point2[1]):int(end_point2[1]),int(start_point2[0]):int(end_point2[0]),:] = photo2</span><br><span class="line">        img[int(start_point2[1]+ 0.5 * HEIGHT_5IN):int(end_point2[1]+ 0.5 * HEIGHT_5IN),int(start_point2[0]):int(end_point2[0]),:] = photo2</span><br><span class="line">        return img</span><br><span class="line">    # 6寸混合排版1</span><br><span class="line">    def layout_photo_6_mix(photo):</span><br><span class="line">        photo1 = cut_photo(photo,1)</span><br><span class="line">        photo2 = cut_photo(photo,2)</span><br><span class="line">        photo1 = np.rot90(photo1)</span><br><span class="line">        img = np.ones((HEIGHT_6IN,WIDTH_6IN, 3), np.uint8)*255</span><br><span class="line">        img[HEIGHT_6IN//2,:,:] = 128            # 横线1</span><br><span class="line">        img[HEIGHT_6IN//4,:WIDTH_6IN//2,:] = 128 # 横线2</span><br><span class="line">        img[int(HEIGHT_6IN*0.75),:WIDTH_6IN//2,:] = 128 # 横线2</span><br><span class="line">        img[:,int(WIDTH_6IN*0.25),:] = 128      # 竖线1</span><br><span class="line">        img[:,int(WIDTH_6IN*0.5),:] = 128      # 竖线2</span><br><span class="line">        img[:,int(WIDTH_6IN*0.75),:] = 128      # 竖线3</span><br><span class="line">        # 确定位置放上1寸图片</span><br><span class="line">        focus_point = [0.125 * WIDTH_6IN, 0.125 * HEIGHT_6IN]</span><br><span class="line">        start_point = [focus_point[0] - 0.5 * HEIGHT_1IN, focus_point[1] - 0.5 * WIDTH_1IN]</span><br><span class="line">        end_point = [focus_point[0] + 0.5 * HEIGHT_1IN, focus_point[1] + 0.5 * WIDTH_1IN]</span><br><span class="line">        for i in range(0,4):</span><br><span class="line">            for j in range(0,2):</span><br><span class="line">                img[int(start_point[1]+0.25*i*HEIGHT_6IN):int(end_point[1]+0.25*i*HEIGHT_6IN),int(start_point[0]+j*WIDTH_6IN/4):int(end_point[0]+j*WIDTH_6IN/4),:] = photo1</span><br><span class="line">        # 确定位置放上2寸图片</span><br><span class="line">        focus_point2 = [0.625 * WIDTH_6IN, 0.25 * HEIGHT_6IN]</span><br><span class="line">        start_point2 = [focus_point2[0] - 0.5 * WIDTH_2IN, focus_point2[1] - 0.5 * HEIGHT_2IN]</span><br><span class="line">        end_point2 = [focus_point2[0] + 0.5 * WIDTH_2IN, focus_point2[1] + 0.5 * HEIGHT_2IN]</span><br><span class="line">        for i in range(0,2):</span><br><span class="line">            for j in range(0,2):</span><br><span class="line">                img[int(start_point2[1]+0.5*i*HEIGHT_6IN):int(end_point2[1]+0.5*i*HEIGHT_6IN),int(start_point2[0]+j*WIDTH_6IN/4):int(end_point2[0]+j*WIDTH_6IN/4),:] = photo2</span><br><span class="line"></span><br><span class="line">        return img</span><br><span class="line"></span><br><span class="line">    img = self.image.copy()</span><br><span class="line">    items = (&#x27;1寸&#x27;, &#x27;2寸&#x27;, &#x27;5寸(8*1寸)&#x27;, &#x27;5寸(4*1寸+2*2寸)&#x27;, &#x27;6寸(8*1寸+4*2寸)&#x27;)</span><br><span class="line">    item,ok = QInputDialog.getItem(self,&quot;区域分割&quot;,&quot;选择需要分成几块&quot;,items,3,False)</span><br><span class="line">    if ok:</span><br><span class="line">        if item == &#x27;1寸&#x27;:</span><br><span class="line">            img = cut_photo(img,1)</span><br><span class="line">        elif item == &#x27;2寸&#x27;:</span><br><span class="line">            img = cut_photo(img,2)</span><br><span class="line">        elif item == &#x27;5寸(8*1寸)&#x27;:</span><br><span class="line">            img = layout_photo_5_1(img)</span><br><span class="line">        elif item == &#x27;5寸(4*1寸+2*2寸)&#x27;:</span><br><span class="line">            img = layout_photo_5_mix(img)</span><br><span class="line">        elif item == &#x27;6寸(8*1寸+4*2寸)&#x27;:</span><br><span class="line">            img = layout_photo_6_mix(img)</span><br><span class="line"></span><br><span class="line">        win_name = &quot;ID photo&quot;</span><br><span class="line">        UIFunctions.wait_key(self,img,win_name)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;opencv的python图像处理学习笔记&lt;/p&gt;
&lt;p&gt;转像素画、转字符画、图片九宫格、图片蒙太奇、幻影坦克、证件照裁剪。&lt;/p&gt;
&lt;p&gt;部分代码参考互联网。</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://splendidwave.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv-python学习(5)--傅里叶变换与小波变换</title>
    <link href="https://splendidwave.github.io/2022/10/25/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(5)--%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/"/>
    <id>https://splendidwave.github.io/2022/10/25/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(5)--%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/</id>
    <published>2022-10-25T04:51:22.000Z</published>
    <updated>2022-12-10T12:03:31.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>opencv的python图像处理学习笔记</p><p>从空间基的角度介绍小波变换</p><span id="more"></span><h2 id="信号的数学表示">1. 信号的数学表示</h2><p>人类探索自然的工具是数学，为此探索的第一步就是将现实中的事物映射到数学上。</p><p>函数就是很好的工具，甚至可以将抽象的数学用图像的方法在坐标系中表示出来。比如一个阶跃信号，被表示为了一个幅值随时间变化的函数。它可以在平面直角坐标系中表示出来，其中横坐标代表时间，纵坐标是幅值。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200322.jpg"alt="阶跃信号" /><figcaption aria-hidden="true">阶跃信号</figcaption></figure><h2 id="距离与度量空间">2.距离与度量空间</h2><p>上面这图是使用Matlab绘制的，看着是连续的线，但实际上只是先绘制了一些离散的点，然后连接成线的。</p><p>平面上的点<spanclass="math inline">\(p_1\)</span>由两个坐标构成，一个是时间<spanclass="math inline">\(x_1\)</span>，一个是幅值<spanclass="math inline">\(y_1\)</span></p><p>平面集合中的两个元素<spanclass="math inline">\(p_1,p_2\)</span>，在数学上可以引入<strong>距离</strong>的概念，定义为<spanclass="math inline">\(d(p_1,p_2)\)</span>,该距离函数被称为空间集合上的度量，<strong>有距离函数的空间集合就称为度量空间。</strong></p><p>这里为便于理解就不给出严格的数学定义，下同。</p><h2 id="范数与赋范空间">3.范数与赋范空间</h2><p>有了度量函数就可以度量距离了，但是对于单个点的距离或者说是向量还没有办法度量。</p><p>如果你认为和零点的距离不就是向量的距离吗，那非常好，这个空间的范数就已经被定义了，<strong>拥有范数函数的空间集合就称为赋范空间。</strong></p><p>显而易见赋范空间应该包含于度量空间。</p><h2 id="线性空间内积空间与正交性">4.线性空间、内积空间与正交性</h2><p>线性空间的概念就非常熟悉了，满足加法的交换律结合律，乘法的分配律等就是线性空间，线性空间的好处在于任何一个元素都可以使用一组基来线性表示。</p><p>对于一个线性赋范空间，如果赋予它内积的运算，它就被称为内积空间，这个运算的数学上的意义是为了能将矢量转换为标量，显而易见内积空间应该包含于线性赋范空间。</p><p>当两个向量的内积为0时，这两个向量相互正交，如果一组基两两正交，则称这组基是正交基。</p><h2 id="希尔伯特空间">5.希尔伯特空间</h2><p>对于上图信号所处的空间来说，是一个简单的二维线性内积空间，其中维度就是指需要多少个值来描述空间中的一个元素。</p><p>因为它的坐标集合是实数集，所以这个空间又是完备的，有限维度的完备内积空间被数学家称为欧几里德空间。（完备性要求度量空间中的所有柯西序列都收敛于该空间的一点）</p><p>一个有限维度的空间只能表达低于该维度的函数，比如在平面直角坐标系中只能表示一维函数，曲面就需要在三维欧几里德空间中才能画出来。</p><p>维度是一方面的局限，另一个可以简化问题的决策在于基的选择。同样是二维的欧几里德空间，表示一个半径为1的圆，使用<span class="math inline">\(x\)</span>,<spanclass="math inline">\(y\)</span>方向的单位向量作为基底，可以写作<spanclass="math inline">\(x^2+y^2=1\)</span>，而在极坐标下只需要写<spanclass="math inline">\(r=1\)</span></p><p>假如有一个空间是无限维的，同时有很多基底供你选择，这样一个空间是不是很棒呢？实际上这也是科学家一直在努力的方向。一个维度不受限的欧几里德空间被称为希尔伯特空间。</p><h2 id="傅里叶变换与短时傅里叶变换">6.傅里叶变换与短时傅里叶变换</h2><p>希尔伯特空间维度是任意的n维，坐标轴的取值也可以从实数拓展到虚数，人类无法想象这个空间，但数学可以将它抽象出来。为方便理解，我们还是以欧几里德空间来想象它。</p><p>有了希尔伯特空间算是解决的第一个问题，无限维的好处是特征有无限多，任何的低维信号在希尔伯特空间都可以映射成向量。现在需要选取一些合适的基，最好的最容易理解和接受的基仍然是沿着假想中的坐标轴的单位向量。</p><p>其次是傅里叶提出的三角函数正交基，三角函数的正交性证明感兴趣的可以见参考资料<ahref="#refer-anchor-1"><sup>[4]</sup></a></p><p>傅里叶变换的本质就是在希尔伯特空间换了一组基来表示一个信号。为了区分，把以时间方向为基的表示称为时域表示，三角函数基称为频域表示。这一对表示有着非常有意思的性质，他们互为倒空间，在时域上极短的信号体现在频域上就是无限长，反过来也一样。</p><p>傅里叶变换很好用，但同时也有它的局限性，因为过多关注了频域，对于时域的信息反而获取不到。对于特定的情况，傅里叶变换后的信号可能没这么容易获取信息。</p><p>比如对于一个频率随时间变换的信号，出来的图像如图，上图表示时域信号，下图为频域信号</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210195716.jpg"alt="傅里叶变换的局限" /><figcaption aria-hidden="true">傅里叶变换的局限</figcaption></figure><p>可以看出频谱除了有4个比较明显的峰外还有许多振荡，而且没法体现出在时域信号中频率随时间变化这一显著的特点。</p><p>所以为了解决这一问题，短时傅里叶变换被提了出来。既然时间信息丢失了，那就补上，短时傅里叶变换和傅里叶变换唯一的区别在于多了一个窗口函数，用一个窗函数去框选时域信号，然后对这一部分再做傅里叶变换，这体现在空间中就是多了一个维度，用热力图来表示如下。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210195656.jpg"alt="短时傅里叶变换" /><figcaption aria-hidden="true">短时傅里叶变换</figcaption></figure><p>短时傅里叶变换就很明显的表现出了时间上的频率变换，但问题在于要怎么知道这个窗口选多大才是合理的，选大了就会出现和傅里叶变换一样的问题出现时域信息丢失，选小了会让频域上的分辨率降低，这里倒是有点测不准原理的感觉了。</p><h2 id="小波变换">7.小波变换</h2><p>不知道该多大的窗口那不如把窗口也变为可变的，不过这样一来，维度又会多了一维，在三维空间里就显得失去了直观性。再往深了考虑的解决方法是使用自适应短时傅里叶变换，使用算法来让窗口自适应信号。</p><p>不过也可以换个角度思考，现在陷入瓶颈的原因还是在于使用了两个互为倒空间的基，出现了测不准的问题，如果重新在希尔伯特空间选择一个基，是否就能够解决这个问题。</p><p>首先波这个概念很好，有了波才引出了频域，我们希望保留它。其次加窗的想法也很好，它保留了时域的信息，这两者都是有物理意义的。这样我们是否能够使用一个小范围的波来作为基呢？起个名字就叫小波，用<spanclass="math inline">\(\psi(t)\)</span>来表示。，样子大概如下。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200305.png"alt="小波" /><figcaption aria-hidden="true">小波</figcaption></figure><p>当然这只是一个概念图，光有一个波可构不成希尔伯特空间的基。</p><p>好在我们是在线性空间里讨论的，只要一个集合能被一组已知的基完全线性表示，那这个集合也是一组基。这里完全线性表示的意思是用上了所有的元素才能表示全。</p><p>所以只要加上尺度变换<spanclass="math inline">\(\frac{1}{\sqrt{a}}\psi(\frac{t}{a})\)</span>,这样随着a的变换，在时域上看是变胖变瘦，在频域上看是遍历所有频率。前面的系数是为了归一化，同样为了方便处理，我们人为将小波在时域上的积分设置为0，这样就和三角函数相统一了。</p><p>解决了基的问题，好像顺带也把频域的特性提取问题解决了，因为小波基底的选择就是借用的波的概念，下一步是让波在时域上动起来，这个也很好处理，只要用初中学的函数平移就行。以小波为基底的变换就叫小波变换。下面直接给出函数<spanclass="math inline">\(f(t)\)</span>小波变换的完整公式。</p><p><span class="math display">\[W T(a, \tau)=\frac{1}{\sqrt{a}} \int_{-\infty}^{\infty} f(t) *\psi\left(\frac{t-\tau}{a}\right) d t\]</span></p><p>实际上小波不一定长得和上图一样，尺度变换也可以用其他方法表示，记作<spanclass="math inline">\(\phi(t)\)</span></p><p>小波的函数<spanclass="math inline">\(\psi(t)\)</span>被称为母小波，尺度函数<spanclass="math inline">\(\phi(t)\)</span>被称为父小波。确定了两者就可以愉快地进行小波变换了！</p><h2 id="参考资料">参考资料</h2><p>[1] <ahref="https://www.bilibili.com/video/BV1ce4y1p7jF/?spm_id_from=333.880.my_history.page.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">卷积神经网络的底层是傅里叶变换，傅里叶变换的底层是希尔伯特空间坐标</a></p><p>[2] <ahref="https://www.zhihu.com/question/332144499/answer/731866608">希尔伯特空间、内积空间的定义有什么关系和区别？</a></p><p>[3] <ahref="https://blog.csdn.net/weixin_36811328/article/details/81207753">欧几里得空间与希尔伯特空间</a></p><div id="refer-anchor-1"></div><p>[4] <ahref="https://www.bilibili.com/video/BV1Et411R78v/?from=search&amp;seid=7859464741790869886&amp;spm_id_from=333.337.0.0&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">纯干货数学推导_傅里叶级数与傅里叶变换_Part1_三角函数的正交性</a></p><p>[5] <ahref="https://zhuanlan.zhihu.com/p/143510464">Matlab中短时傅里叶变换spectrogram和stft的用法</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;opencv的python图像处理学习笔记&lt;/p&gt;
&lt;p&gt;从空间基的角度介绍小波变换&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://splendidwave.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv-python学习(4)--形态学与图像分割</title>
    <link href="https://splendidwave.github.io/2022/10/23/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(4)--%E5%BD%A2%E6%80%81%E5%AD%A6%E4%B8%8E%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    <id>https://splendidwave.github.io/2022/10/23/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(4)--%E5%BD%A2%E6%80%81%E5%AD%A6%E4%B8%8E%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/</id>
    <published>2022-10-23T08:57:32.000Z</published>
    <updated>2022-10-28T11:19:54.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>opencv的python图像处理学习笔记</p><span id="more"></span><h2 id="形态学处理">1.形态学处理</h2><h3 id="腐蚀">1.1 腐蚀</h3><p>原理：遍历原图像的每一个像素，然后用核的中心点对准当前正在遍历的这个像素，然后取当前结构元素所覆盖下的原图对应区域内的所有像素的最小值，用这个最小值替换当前像素值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = np.ones((3, 3), np.uint8)</span><br><span class="line">dst = cv2.erode(src, k, iterations=3)</span><br></pre></td></tr></table></figure><p>iterations是迭代次数，越多腐蚀力度越大</p><h3 id="膨胀">1.2 膨胀</h3><p>原理与腐蚀相同，改为使用最大值替换当前像素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = np.ones((3, 3), np.uint8)</span><br><span class="line">dst = cv2.dilate(src, k, iterations=3)</span><br></pre></td></tr></table></figure><h3 id="开运算与闭运算">1.3 开运算与闭运算</h3><p>先进行腐蚀再进行膨胀就叫做开运算</p><p>先膨胀在腐蚀就是闭运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = np.ones((3, 3), np.uint8)</span><br><span class="line">dst = cv2.morphologyEx(src,cv2.MORPH_OPEN,k)</span><br></pre></td></tr></table></figure><p>cv2.MORPH_OPEN：指定为开运算</p><p>cv2.MORPH_CLOSE：指定为闭运算</p><p>cv2.MORPH_GRADIENT 梯度运算（膨胀减去腐蚀）</p><p>cv2.MORPH_TOPHAT 礼帽 = 原始-开运算</p><p>cv2.MORPH_BLACKHAT 黑帽 = 闭运算-原始</p><h2 id="图像分割">2.图像分割</h2><h3 id="基于阈值的分割方法">2.1 基于阈值的分割方法</h3><ol type="1"><li>固定阈值分割&gt;这是最简单的分割方法，大于某一阈值就提取出来，但该方法使用范围也非常的窄。</li><li>直方图双峰法&gt;灰度直方图通常由双峰属性，两个峰值之间的最小值通常可以认为是最优的二值化分界点。</li><li>迭代阈值图像分割 &gt;1. 选取终止步长dt &gt;2. 选取初始阈值T0 &gt;3.使用T分割图像分为G1、G2两组 &gt;4. 统计G1、G2的平均灰度m1、m2 &gt;5.新阈值为<span class="math inline">\(T=(m1+m2)/2\)</span> &gt;6.重复iii-v直到新阈值变动值小于dt</li><li>OTSU法（最大类间方差法/大津法）&gt;通过计算分割阈值的最大类间方差得到最合适的分割阈值，公式参考<ahref="https://blog.csdn.net/weixin_44842748/article/details/115827607">【图像分割】自适应阈值图像分割方法（最大类间差法与最大熵法）</a></li><li>最大熵法 &gt;同上，基于最大熵选取阈值</li></ol><h3 id="基于边缘检测的分割方法">2.2 基于边缘检测的分割方法</h3><p>锐化空间滤波器内容见上一篇博客，使用锐化算子可以检测出边缘并进行分割。</p><h3 id="基于区域的分割方法">2.3 基于区域的分割方法</h3><ol type="1"><li>区域生长法&gt;根据统一物体区域的像素相似性来聚集像素点达到区域生长的方法。</li><li>区域分裂合并法&gt;将图像任意分成若干互不相交的区域，按准则对这些区域进行分裂合并。差不多是生长法的逆过程。</li><li>分水岭法&gt;分水岭是用三维方法具象化二维图片，将灰度看着是海拔。模拟水淹没地形的过程，通过修建水坝的方式分割区域。</li></ol><h3 id="基于深度学习的分割方法">2.4 基于深度学习的分割方法</h3><p>K-MeansClustering（k聚类）是一种非监督学习算法，对于给定样本集，按照距离大小划分为k个簇。</p><p>opencv提供的api</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compactness, labels, (centers) = cv2.kmeans(data, K, bestLabels, criteria, attempts, centers)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>data：输入的样本数据，必须是按行组织样本，每一行为一个样本数据，列表示样本的维度。</li><li>K：最终的簇的数目。</li><li>bestLabels：预设的分类标签或者None。</li><li>criteria：迭代停止的模式选择，这是一个含有三个元素的元组型数。格式为（type,max_iter, epsilon）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其中type有如下模式：</span><br><span class="line">cv2.TERM_CRITERIA_EPS ：精确度（误差）满足epsilon，则停止。</span><br><span class="line">cv2.TERM_CRITERIA_MAX_ITER：迭代次数超过max_iter，则停止。</span><br><span class="line">cv2.TERM_CRITERIA_EPS+cv2.TERM_CRITERIA_MAX_ITER：两者结合，满足任意一个结束。</span><br></pre></td></tr></table></figure><ul><li>attempts：重复试验kmeans算法次数，将会返回最好的一次结果。</li><li>centers：初始中心选择： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.KMEANS_RANDOM_CENTERS：每次随机选择初始中心</span><br></pre></td></tr></table></figure></li></ul><p>返回值：</p><ul><li>compactness：密度，返回每个点到相应重心的距离的平方和。</li><li>labels：结果标记，每个成员被标记为分组的序号，如 0,1,2,3,4…等。</li><li>centers：由聚类的中心的描述信息(可能是坐标，也可能是色彩值)组成的数组。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#K-means均值聚类</span><br><span class="line">Z = img.reshape((-1, 3))</span><br><span class="line">Z = np.float32(Z)      #转化数据类型</span><br><span class="line">c = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)</span><br><span class="line">k = 4  # 聚类个数</span><br><span class="line">ret, label, center = cv2.kmeans(Z, k, None, c, 10, cv2.KMEANS_RANDOM_CENTERS)</span><br><span class="line">center = np.uint8(center)</span><br><span class="line">res = center[label.flatten()]</span><br><span class="line">output_img = res.reshape((img.shape))</span><br></pre></td></tr></table></figure><h3 id="opencv的人脸检测">3. opencv的人脸检测</h3><p>既然都提到图像分割和机器学习，这就不得不试一试人脸检测了。opencv有自带的训练好的数据，调一下库还是很快就能实现出来。</p><p>主要是使用分类器和检测多脸 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 加载人脸特征，该文件在 python安装目录\Lib\site-packages\cv2\data 下</span><br><span class="line">face_cascade = cv2.CascadeClassifier(&#x27;haarcascade_frontalface_default.xml&#x27;)</span><br><span class="line">faces = face_cascade.detectMultiScale(img, scaleFactor, minNeighbors, minSize,maxSize)</span><br><span class="line"></span><br><span class="line"># image表示的是要检测的输入图像</span><br><span class="line"># scaleFactor表示每次图像尺寸减小的比例</span><br><span class="line"># minNeighbors表示检测到多少次才算是目标</span><br><span class="line"># minSize为目标的最小尺寸 元组</span><br><span class="line"># maxSize为目标最大尺寸 元组</span><br><span class="line"># 除了image其他都可以不输入</span><br></pre></td></tr></table></figure></p><p>工程实例 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 人脸检测</span><br><span class="line">def facefind(self):</span><br><span class="line">   # 读入图片并转换为灰度</span><br><span class="line">   img = self.image</span><br><span class="line">   gray = UIFunctions.trun_gray(self,img)</span><br><span class="line">   # 加载人脸特征，该文件在 python安装目录\Lib\site-packages\cv2\data 下</span><br><span class="line">   face_cascade = cv2.CascadeClassifier(r&#x27;modules\haarcascade_frontalface_default.xml&#x27;)</span><br><span class="line">   faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=4, minSize=(20, 20))</span><br><span class="line">   # 绘制矩形框</span><br><span class="line">   for (x, y, w, h) in faces:</span><br><span class="line">      cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2)</span><br><span class="line">   win_name = &quot;face&quot;</span><br><span class="line">   UIFunctions.wait_key(self,img,win_name)</span><br></pre></td></tr></table></figure></p><h2 id="参考资料">参考资料</h2><p>[1] <ahref="https://blog.csdn.net/weixin_45848575/article/details/125420149">python-opencv图像处理-腐蚀和膨胀</a></p><p>[2] <ahref="https://blog.csdn.net/fengdu78/article/details/124011203">【深度学习】基于区域生长的图像分割算法！</a></p><p>[3]https://blog.csdn.net/weixin_53598445/article/details/123730985</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;opencv的python图像处理学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://splendidwave.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv-python学习(3)--加噪与空间滤波</title>
    <link href="https://splendidwave.github.io/2022/10/19/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(3)--%E5%8A%A0%E5%99%AA%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2/"/>
    <id>https://splendidwave.github.io/2022/10/19/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(3)--%E5%8A%A0%E5%99%AA%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2/</id>
    <published>2022-10-19T08:57:32.000Z</published>
    <updated>2022-12-10T11:56:00.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>opencv的python图像处理学习笔记</p><span id="more"></span><h2 id="图像噪声">1.图像噪声</h2><p>图像噪声是指存在于图像数据中的不必要的或多余的干扰信息。有些噪声严重影响了图片的质量，因此在图片预处理的过程中需要先将图片的噪声去除。</p><p>噪声通常是随机过程，需要具备一定的概率论相关知识才能更好的理解。</p><p>常见的噪声有如下几种：椒盐/高斯/泊松/散斑，下面给出使用python对图片加噪的方法。部分代码参考<ahref="https://blog.csdn.net/sinat_29957455/article/details/123977298">csdn文章python使用opencv对图像添加(高斯/椒盐/泊松/斑点)噪声</a></p><h3 id="椒盐噪声">1.1 椒盐噪声</h3><p>这个名字起的色香味俱全，椒盐噪声实际上指的是两种颜色的噪声，黑点为椒，白点为盐。在图片上的分布通常是随机的，就像是撒了胡椒和盐在图片上，由此得名。</p><p><strong>产生的原因</strong>通常是<strong>脉冲干扰</strong>或者<strong>传感器内部错误</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 加椒盐噪声</span><br><span class="line">def add_pepper_and_salt(self):</span><br><span class="line">    # 获取数量和椒盐比</span><br><span class="line">    amount = float(self.config.get(&quot;Noisy&quot;,&quot;noise_ratio&quot;))</span><br><span class="line">    p_vs_s = float(self.config.get(&quot;Noisy&quot;,&quot;pepper_vs_salt&quot;))</span><br><span class="line">    noisy_img = np.copy(self.image)</span><br><span class="line">    num_pepper = np.ceil(amount * noisy_img.size * p_vs_s)</span><br><span class="line">    num_salt = np.ceil(amount * noisy_img.size * (1. - p_vs_s))</span><br><span class="line">    #设置添加pepper噪声</span><br><span class="line">    coords = [np.random.randint(0, i - 1, int(num_pepper)) for i in self.image.shape]</span><br><span class="line">    noisy_img[tuple(coords)] = 0</span><br><span class="line">    #设置添加salt噪声</span><br><span class="line">    coords = [np.random.randint(0, i - 1, int(num_salt)) for i in self.image.shape]</span><br><span class="line">    noisy_img[tuple(coords)] = 255</span><br><span class="line">    # 展示</span><br><span class="line">    win_name = &quot;pepper&amp;salt&quot;</span><br><span class="line">    UIFunctions.wait_key(self,noisy_img,win_name)</span><br></pre></td></tr></table></figure><h3 id="高斯噪声">1.2 高斯噪声</h3><p>高斯噪声是一种非常常见的噪声，很多噪声都是服从正态分布的，他们被统一称为高斯噪声。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 加高斯噪声</span><br><span class="line">def add_gauss_noisy(self):</span><br><span class="line">    img = self.image</span><br><span class="line">    #获取均值和标准差</span><br><span class="line">    mean = float(self.config.get(&quot;Noisy&quot;,&quot;guass_mean&quot;))</span><br><span class="line">    sigma = float(self.config.get(&quot;Noisy&quot;,&quot;guass_sigma&quot;))</span><br><span class="line">    #生成高斯分布的噪声</span><br><span class="line">    gauss = np.random.normal(mean,sigma,img.shape)</span><br><span class="line">    #给图片添加高斯噪声</span><br><span class="line">    noisy_img = img + gauss</span><br><span class="line">    #设置图片添加高斯噪声之后的像素值的范围</span><br><span class="line">    noisy_img = np.uint8(np.clip(noisy_img,a_min=0,a_max=255))</span><br><span class="line">    # 展示</span><br><span class="line">    win_name = &quot;gauss_noisy&quot;</span><br><span class="line">    UIFunctions.wait_key(self,noisy_img,win_name)</span><br></pre></td></tr></table></figure><h3 id="泊松噪声">1.3 泊松噪声</h3><p>泊松噪声又称散粒噪声，适合于描述单位时间内随机事件发生的次数的概率分布。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 加泊松噪声</span><br><span class="line">def add_poisson_noisy(self):</span><br><span class="line">    img = self.image</span><br><span class="line">    lam = float(self.config.get(&quot;Noisy&quot;,&quot;poisson_lambda&quot;))</span><br><span class="line">    # 生成泊松分布的噪声</span><br><span class="line">    poisson = np.random.poisson(lam=lam,size=img.shape).astype(dtype=&#x27;uint8&#x27;)</span><br><span class="line">    noisy_img = img + poisson</span><br><span class="line">    noisy_img = np.uint8(np.clip(noisy_img,a_min=0,a_max=255))</span><br><span class="line">    # 展示</span><br><span class="line">    win_name = &quot;poisson_noisy&quot;</span><br><span class="line">    UIFunctions.wait_key(self,noisy_img,win_name)</span><br></pre></td></tr></table></figure><h3 id="散斑噪声">1.4 散斑噪声</h3><p>散斑的英文是Speckle，产生的原因通常是干涉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 加散斑噪声</span><br><span class="line">def add_speckle_noisy(self):</span><br><span class="line">    img = self.image</span><br><span class="line">    speckle = np.random.randn(*img.shape)</span><br><span class="line">    #给图片添加speckle噪声</span><br><span class="line">    noisy_img = img + img * speckle</span><br><span class="line">    #归一化图像的像素值</span><br><span class="line">    noisy_img = np.uint8(np.clip(noisy_img,a_min=0,a_max=255))</span><br><span class="line">    # 展示</span><br><span class="line">    win_name = &quot;speckle_noisy&quot;</span><br><span class="line">    UIFunctions.wait_key(self,noisy_img,win_name)</span><br></pre></td></tr></table></figure><h2 id="平滑空间滤波器">2.平滑空间滤波器</h2><h3 id="原理">2.1 原理</h3><p>滤波一词源于频域，指筛选掉一部分频率的波。但因为空域和频域是可以通过傅里叶变换相互转换的，所以在空间中对图像进行一些操作在频域上看起来就是滤波(如平滑操作对应于频域的低通滤波)。而且二者各有优劣，所以在空域上对图片进行处理统一称为空间滤波。</p><p>平滑滤波器的主要原理是针对每一个像素点对一个核内的数据进行对应处理实现平滑效果。有点类似与卷积但不完全是。</p><h3 id="均值滤波">2.2 均值滤波</h3><p>对核取平均值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.GaussianBlur(img,size)</span><br></pre></td></tr></table></figure><p>img 原图像</p><p>size 核大小，通常为奇数，如(3，3)</p><h3 id="高斯滤波">2.3 高斯滤波</h3><p>对核高斯加权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.GaussianBlur(src,ksize,sigmaX,sigmaY)</span><br><span class="line">cv2.GaussianBlur(img,(5,5),0,0)</span><br></pre></td></tr></table></figure><p>sigmaX,sigmaY分别表示X,Y方向的标准偏差。如果两者都为零，则根据内核大小计算它们。</p><h3 id="中值滤波">2.4 中值滤波</h3><p>取核内的中位数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.medianBlur(img, k)</span><br><span class="line">cv2.medianBlur(img,3)</span><br></pre></td></tr></table></figure><p>k 为方框的尺寸</p><h2 id="锐化空间滤波器">3.锐化空间滤波器</h2><h3 id="原理-1">3.1 原理</h3><p>通过找到灰度变换明显的区域，强化该范围像素。</p><p>这里涉及到寻找一个跳变（边缘）的过程，所以可以采用求导的方法。一阶导或者二阶导（拉普拉斯算子）</p><p>因为是寻找边缘，所以还可以用来进行腐蚀，膨胀，边缘检测等操作。</p><h3 id="sobel">3.2 sobel</h3><p>索贝尔算子方法简单、处理速度快，被广泛应用于边缘提取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=5)</span><br></pre></td></tr></table></figure><p>其中第二个参数是数据类型，第3、4个参数是dx,dy表示水平方向/竖直方向，要求两者只能有一个为1，另一个为0,第5个值表示核的大小</p><h3 id="scharr">3.3 scharr</h3><p>当索贝尔算子的第五个参数为-1时，就变成了夏尔算子,scharr是sobel的一个增强，如下图</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210195546.png"alt="scharr 和 sobel" /><figcaption aria-hidden="true">scharr 和 sobel</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.Scharr(img, cv2.CV_64F, 0, 1)</span><br></pre></td></tr></table></figure><h3 id="laplace">3.4 laplace</h3><p>拉普拉斯算子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.Laplacian(self.image, cv2.CV_64F)</span><br></pre></td></tr></table></figure><h3 id="canny">3.5 canny</h3><p>Canny算法年代久远，但可以说它是边缘检测的一种标准算法，而且仍在广泛使用。</p><p>Canny边缘检测算法可以分为以下5个步骤： 1. 高斯滤波来平滑图像去除噪声2. 找寻图像的强度梯度 3. 应用非最大抑制（non-maximumsuppression）技术来消除边误检 4.应用双阈值的方法来决定可能的（潜在的）边界 5. 利用滞后技术来跟踪边界</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.Canny(img, lowThreshold, highThreshold)</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><p>[1]https://blog.csdn.net/weixin_40922285/article/details/102801633</p><p>[2] https://baike.baidu.com/item/canny%E7%AE%97%E6%B3%95/8439208</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;opencv的python图像处理学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://splendidwave.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>numpy库使用多个元素的数组的真值不明确问题</title>
    <link href="https://splendidwave.github.io/2022/10/19/2022-10/numpy%E5%BA%93%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E7%9C%9F%E5%80%BC%E4%B8%8D%E6%98%8E%E7%A1%AE%E9%97%AE%E9%A2%98/"/>
    <id>https://splendidwave.github.io/2022/10/19/2022-10/numpy%E5%BA%93%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E7%9C%9F%E5%80%BC%E4%B8%8D%E6%98%8E%E7%A1%AE%E9%97%AE%E9%A2%98/</id>
    <published>2022-10-19T02:57:32.000Z</published>
    <updated>2022-10-22T08:07:32.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>ValueError: The truth value of an array with more than one element isambiguous. Use a.any() or a.all()</p><span id="more"></span><h2 id="问题">问题</h2><p>总所周知，numpy库可以使用布尔值索引，这对加快python的矩阵处理速度起到了很大的作用。比如在图像处理中使用矩阵掩膜的方法<code>out_img[input == i] = xxx</code>可以快速对满足条件的值赋值（比如应用在直方图均衡）。</p><p>同时使用<code>np.where(condition, x, y)</code>的方法可以更快得同时处理满足条件和不满足条件的情况,满足修改为x，不满足修改为y。</p><p>但使用二维矩阵的俩个条件时就会报错，如要让大于等于era1和小于era2的值赋255，不满足服0<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layer = np.where((layer&gt;=era1) and (layer&lt;era2),255,0)</span><br><span class="line">ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()</span><br></pre></td></tr></table></figure></p><p>当然用<code>a&lt;x&lt;b</code>的条件也是不行的。</p><h2 id="解决方法">解决方法</h2><ol type="1"><li><p>使用运算符号代替逻辑运算，把“or”改为“+”或“|”，“and”改为“*”或“&amp;”在python中True是1，False是0，条件判断都是返回一个布尔值矩阵，在使用运算符号就可以实现矩阵的逻辑运算。</p></li><li><p>使用位运算<code>np.bitwise_and()</code>numpy库自带了一个计算位运算的函数，使用这个也可以实现矩阵逻辑运算</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;ValueError: The truth value of an array with more than one element is
ambiguous. Use a.any() or a.all()&lt;/p&gt;</summary>
    
    
    
    <category term="解决方案" scheme="https://splendidwave.github.io/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv-python学习(2)--灰度变换与直方图</title>
    <link href="https://splendidwave.github.io/2022/10/17/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(2)--%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%9B%B4%E6%96%B9%E5%9B%BE/"/>
    <id>https://splendidwave.github.io/2022/10/17/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(2)--%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%9B%B4%E6%96%B9%E5%9B%BE/</id>
    <published>2022-10-17T04:17:32.000Z</published>
    <updated>2022-12-10T11:40:59.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>opencv的python图像处理学习笔记</p><span id="more"></span><h2 id="灰度变换">1.灰度变换</h2><h3 id="灰度化">1.1 灰度化</h3><p>灰度化是将图片由RGB三通道转为只有灰度的单通道图片。</p><p>改变颜色空间使用<code>cvtColor(input_image, flag)</code>BGR↔︎灰色和BGR↔︎HSV的转换比较常用，这里主要看灰度图</p><p>cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def trun_gray(img):</span><br><span class="line">    try:</span><br><span class="line">        depth = img.shape[2]</span><br><span class="line">        if depth == 3:</span><br><span class="line">            return cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    except IndexError:</span><br><span class="line">        return img</span><br></pre></td></tr></table></figure><h3 id="二值化">1.2 二值化</h3><p>二值化是将图片矩阵转为只有0和255的图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv2.threshold(src, thresh, maxval, type)</span><br><span class="line"></span><br><span class="line">ret,binary = cv2.threshold(img,0,255,cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br></pre></td></tr></table></figure><p>传入源图片src，阈值thresh，最大值maxval，参数type，cv2.THRESH_OTSU指使用OTSU算法自动获取阈值，THRESH_BINARY等参数见下</p><p>返回ret是OTSU算法得到的阈值，binary是二值化后的图片</p><table><thead><tr class="header"><th style="text-align: center;">名称</th><th style="text-align: center;">含意</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">cv2.THRESH_BINARY</td><tdstyle="text-align: center;">像素灰度值小于阈值全为0,大于阈值全为255</td></tr><tr class="even"><td style="text-align: center;">cv2.THRESH_BINARY_INV</td><tdstyle="text-align: center;">像素灰度值小于阈值全为255,大于阈值全为0</td></tr><tr class="odd"><td style="text-align: center;">cv2.THRESH_TRUNC</td><tdstyle="text-align: center;">像素灰度值小于阈值不变,大于阈值变为阈值</td></tr><tr class="even"><td style="text-align: center;">cv2.THRESH_TOZERO</td><tdstyle="text-align: center;">像素灰度值小于阈值不做任何改变,大于阈值全为0</td></tr><tr class="odd"><td style="text-align: center;">cv2.THRESH_TOZERO_INV</td><tdstyle="text-align: center;">像素灰度值小于阈值全为0,大于阈值不做任何改变</td></tr></tbody></table><h3 id="图像反转">1.3 图像反转</h3><p>图像反转又称反色变换，记原图像矩阵为r，灰度范围为[0，L-1]</p><p>反转后图像公式如下 <span class="math display">\[s =  L-1-r\]</span></p><p>如果是二值图就相当于黑白反转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def image_inverse(x):</span><br><span class="line">    value_max = np.max(x)</span><br><span class="line">    y = value_max - x</span><br><span class="line">    return y</span><br></pre></td></tr></table></figure><h3 id="对数变换">1.4 对数变换</h3><p>通用变换规律 <span class="math display">\[s = c \cdot \ln(1+r)\]</span></p><p>其中加1是为了确保输出的值都大于0 对数通常以e为底。</p><p>变换是为了让图片的动态显示范围更直观，在实际展示时还要注意归一化。一个典型的用处就是展示傅里叶频谱图，频谱的低频值比较重要。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 归一化映射函数</span><br><span class="line">def normImg(self,x):</span><br><span class="line">    return  cv2.normalize(x,None,0,255,cv2.NORM_MINMAX)</span><br><span class="line"></span><br><span class="line">def log_image(self):</span><br><span class="line">  img = self.image</span><br><span class="line">  log = np.uint8(self.normImg(self,np.log(1.0 + img)))</span><br></pre></td></tr></table></figure></p><h3 id="伽马变换">1.5 伽马变换</h3><p>伽马变换又称幂律变换，可以提升暗部细节，对过白或过暗的图片进行矫正。</p><p>基本形式为</p><p><span class="math display">\[s = c (r + \epsilon)^\gamma\]</span></p><p>其中补偿系数<span class="math inline">\(\epsilon\)</span>一般为0</p><p>同样伽马变换也要注意映射到指定范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def gamma_image(self):</span><br><span class="line">  img = self.image</span><br><span class="line">  gamma = np.power(img, eps)</span><br><span class="line">  gamma = np.uint8(normImg(self,gamma))</span><br></pre></td></tr></table></figure><p><strong><spanclass="math inline">\(\gamma\)</span>大于1是增强暗度，小于1是增强亮度。</strong></p><h3 id="分段线性变换">1.6 分段线性变换</h3><h4 id="对比度拉伸">1.6.1 对比度拉伸</h4><p>没啥好说的，就是再映射</p><h4 id="灰度级分层">1.6.2 灰度级分层</h4><p>当只对某一范围的灰度感兴趣时，我们可以将该区域设置为白色或黑色，其他保持不变或变为另一种颜色。这样可以提取出想要的信息。</p><h4 id="比特屏幕分层">1.6.3 比特屏幕分层</h4><p>对于256级的8位灰度图，将每一位的灰度拆分出来，生成对应的二值图像，并将不同层次的灰度二值图像组合可以在不损失图像精度的前提下降低图像存储空间。</p><p>第1位，二值图像灰度值为1的灰度级区间为[2^0, 2^1) , 即 [0, 2);</p><p>第2位，二值图像灰度值为1的灰度级区间为[2^1, 2^2), 即 [2, 4);</p><p>...</p><p>第8位，二值图像灰度值为1的灰度级区间为[2^7, 2^8), 即 [128, 256)。</p><h2 id="直方图">2.直方图</h2><h3 id="opencv中的直方图">2.1 opencv中的直方图</h3><p>直方图是指把像素值（通常为[0,255]）的像素点个数统计出来画成直方图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 展示直方图</span><br><span class="line">def show_image_hist(self):</span><br><span class="line">    if len(self.image.shape) == 2:</span><br><span class="line">        # hist = cv2.calcHist([self.image],[0],None,[256],[0,256])</span><br><span class="line">        plt.hist(self.image.ravel(),256); </span><br><span class="line">    else:</span><br><span class="line">        color = (&#x27;b&#x27;,&#x27;g&#x27;,&#x27;r&#x27;)</span><br><span class="line">        for i,col in enumerate(color): </span><br><span class="line">            histr = cv2.calcHist([self.image],[i],None,[256],[0,256]) </span><br><span class="line">            plt.plot(histr,color = col) </span><br><span class="line">            plt.xlim([0,256])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>其中<code>.ravel()</code>是将矩阵拍成一维数组</p><p><code>cv2.calcHist(images,channels,mask,histSize,ranges)</code>是opencv的直方图接口，api参数如下</p><ul><li>images：原图像 当传入函数时应用中括号[]括起来，如[img]</li><li>channels：如果输入图像是灰度图，它的值就是[0]；如果是彩色图，传入的参数可以是[0],[1],[2]，分别对应通道B、G、R</li><li>mask：掩膜图像。统计整张图像的直方图就把它设置为None。当统计图像某一部分的直方图时，需要自己制作一个掩膜图像</li><li>histsize：BIN的数目。用中括号[]括起来，如[256]</li><li>ranges：像素值范围，通常为[0, 256]</li></ul><p>直方图均衡化也可以作为提高图像对比度的一个手段。下面给出一个opencv自带的均衡函数<code>dst = cv2.equalizeHist(img)</code>但通常这样操作效果不是很好，还需要考虑全局的信息，为解决该问题，需要使用<strong>自适应的直方图均衡化</strong>。该方法会将图片切成小块，进行均衡。但直接这样会让噪声也扩撒，所以在切成小块前要先把超过对比度上限的像素点均匀分散到其他bins上。</p><p>自适应直方图均衡化的opencvAPI是<code>cv2.createCLAHE(clipLimit, tileGridSize)</code></p><ul><li>clipLimit：对比度限制，默认是40</li><li>tileGridSize：分块的大小，默认为8*8</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个自适应均衡化的对象，并应用于图像</span><br><span class="line">clahe = cv.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))</span><br><span class="line">cl1 = clahe.apply(img)</span><br></pre></td></tr></table></figure><h3 id="直方图均衡原理">2.2 直方图均衡原理</h3><p>以灰度图像为例，它的直方图（不同灰度的像素点个数统计）的积分和为总像素点的个数，图像的灰度变量记为r。然后在其经过一个灰度变换<spanclass="math inline">\(T(r)\)</span>后，我们记为s，可知s的总像素个数应该与r相同，也就是说s的直方图积分等于r的直方图积分。同时将s和r归一化（横坐标由[0,L-1]映射到[0,1]，直方图的面积设置为1），这条定理也应该成立，公式如下：</p><p><span class="math display">\[\int_{0}^{b} p_{s}(s) d s=\int_{0}^{a} p_{r}(r) d r\]</span></p><p>其中<span class="math inline">\(a=b=1\)</span>,<spanclass="math inline">\(p_s\)</span>和<spanclass="math inline">\(p_r\)</span>分别为s和r的直方图函数，因为已经进行了归一化，它们的积分(面积)为1，这样也可以将<spanclass="math inline">\(p\)</span>看做是图像的概率密度分布函数。反正在计算机眼里，图片只是一些随机分布的噪点罢了。</p><p>另一方面，如果灰度变化函数是单调递增的函数，那么当<spanclass="math inline">\(b=T(a)\)</span>时，该公式也应当成立。给一个直观的参考图。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210194032.png"alt="灰度变化后直方图的关系" /><figcaption aria-hidden="true">灰度变化后直方图的关系</figcaption></figure><p>将上式改为微分形式(两边对s求导)有：</p><p><span class="math display">\[p_{s}(s)=\frac{p_{r}(r) d r}{d s}\]</span></p><p>想要让变化后的图片实现直方图均衡，即让<spanclass="math inline">\(p_s\)</span>恒等于1，代入可得</p><p><span class="math display">\[p_{r}(r)=\frac{d s}{d r}\]</span></p><p>两边再对r积分得到</p><p><span class="math display">\[s=\int_{0}^{x} p_{r}(r) d r\]</span></p><p>再将积分转换为离散的像素点的求和，最后别忘记了反归一化</p><p><span class="math display">\[s_{k}=(L-1)*\sum_{i=0}^{k} p_{r}(i)\]</span></p><p>这样我们就得到了输出图像灰度变量s，利用直方图巧妙地得到了灰度变化函数。再通过灰度变化函数对原图的像素点进行操作即可得到输出图像。</p><h3 id="直方图规定化">2.3 直方图规定化</h3><p>有时候均衡不是我们想要达到的目的，比如一个哥特风的cos照，均衡化后反而变亮了，失去了原有的风格。但原图拍摄的又比较暗，无法看清细节。所以我现在希望能将目标图像的直方图转变为我想要的直方图以实现图像变换的效果。</p><p>下面简单介绍原理，我们知道对于归一化的图像灰度变量a有</p><p><span class="math display">\[s=T(a) = \int_{0}^{x} p_{a}(a) d a\]</span></p><p>其中s是归一化平衡化直方图的灰度变量，它的概率密度函数恒为1 <spanclass="math inline">\(T\)</span>是a到s的灰度变换函数。</p><p>那同样对于我们需要的目标图像的灰度变量b，它所对应的平衡直方图也应该是s</p><p><span class="math display">\[s=G(b) = \int_{0}^{x} p_{b}(b) d b\]</span></p><p>其中<span class="math inline">\(G\)</span>是b到s的灰度变换函数。</p><p>这里理一下思路：</p><p>我们现在可以从目标图像B的灰度直方图中得出灰度变换函数<spanclass="math inline">\(G\)</span>、还可以从原图像A中得到均衡后的图像<spanclass="math inline">\(A^{&#39;}\)</span>，并且已知目标图像B的均衡后的图像<spanclass="math inline">\(B^{&#39;}\)</span>有<spanclass="math inline">\(B^{&#39;}=A^{&#39;}\)</span></p><p>现在的问题明确了，只要知道了<spanclass="math inline">\(G^{-1}\)</span>就可以由<spanclass="math inline">\(B^{&#39;}\)</span>获得目标图像B。但问题在于这个反函数没有这么容易求。不过在工程上倒是有一个近似方法，利用<spanclass="math inline">\(G\)</span>可以将[0,L-1]范围的像素先做一个映射表。然后通过遍历均衡后图像的像素点通过查表法映射回去。虽然不知道函数，但对于离散值，这样的计算也是足够了。</p><h2 id="参考资料">参考资料</h2><p>[1] https://blog.csdn.net/XWMRHZZ/article/details/124393745</p><p>[2] https://blog.csdn.net/my_cat__/article/details/125477831</p><p>[3] opencv官方手册</p><p>[4] https://blog.csdn.net/m0_47472749/article/details/114223563</p><p>[5] https://blog.csdn.net/gg13213/article/details/123671416</p><p>[6] <ahref="https://www.bilibili.com/video/BV1RF41177xo?share_source=copy_web&amp;vd_source=4ed37bc2c316b34de1f0a37e789af272">【手写图像处理库4】别再说数学理论鼓噪无味了，概率论的典型应用，直方图均衡化，一键完成对比度增强，懒人神器，数字图像处理，冈萨雷斯</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;opencv的python图像处理学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://splendidwave.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv-python学习(1)--读写与缩放</title>
    <link href="https://splendidwave.github.io/2022/10/11/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(1)--%E8%AF%BB%E5%86%99%E4%B8%8E%E7%BC%A9%E6%94%BE/"/>
    <id>https://splendidwave.github.io/2022/10/11/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(1)--%E8%AF%BB%E5%86%99%E4%B8%8E%E7%BC%A9%E6%94%BE/</id>
    <published>2022-10-11T09:27:32.000Z</published>
    <updated>2022-10-20T01:50:22.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>opencv的python图像处理学习笔记</p><span id="more"></span><h2 id="安装和导入">1.安装和导入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br></pre></td></tr></table></figure><h2 id="读取与显示">2.读取与显示</h2><p>读取图片 img = cv2.imread (filename,flags=None)</p><p>路径要全英文，图像路径错误不会报错会返回None</p><p>读取到了返回的是numpy.ndarray对象 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># -1表示保持原有的格式不变</span><br><span class="line"># 0表示将图像调整为单通道的灰度图像</span><br><span class="line"># 1表示将图像调整为3通道的BGR通道。为默认值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img=cv2.imread(&quot;test.jpg&quot;)</span><br><span class="line">img=cv2.imread(&quot;test.jpg&quot;,0)</span><br></pre></td></tr></table></figure></p><p>展示图片 cv.imshow(“窗口名字”,被读取的图片)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 显示一个可以调大小的窗口</span><br><span class="line">cv2.namedWindow(&quot;image&quot;,cv2.WINDOW_FREERATIO)</span><br><span class="line"></span><br><span class="line"># cv2.WINDOW_NORMAL# 用户可以改变这个窗口大小</span><br><span class="line"># cv2.WINDOW_AUTOSIZE# 窗口大小自动适应图片大小，并且不可手动更改。   </span><br><span class="line"># cv2.WINDOW_FREERATIO# 自适应比例</span><br><span class="line"># cv2.WINDOW_KEEPRATIO# 保持比例</span><br><span class="line"># cv2.WINDOW_OPENGL# 窗口创建的时候会支持OpenGL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 打开一个名为“image”的窗口并展示图片</span><br><span class="line">cv2.imshow(&quot;image&quot;,img)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 等待结束</span><br><span class="line">cv2.waitKey(0) </span><br><span class="line"># 不加窗口会闪退，值为时间单位ms，0代表永久</span><br><span class="line">cv2.destroyAllWindows() </span><br><span class="line"># 关掉所有窗口</span><br></pre></td></tr></table></figure><p>汇总 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img=cv2.imread(&quot;hmbb.jpg&quot;)</span><br><span class="line">print(&#x27;Original Dimensions : &#x27;,img.shape) # 显示图片大小等参数</span><br><span class="line"># cv2.namedWindow(&quot;image&quot;,cv2.WINDOW_FREERATIO)</span><br><span class="line">cv2.imshow(&quot;image&quot;,img)</span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h3 id="缩放">3.缩放</h3><p>cv2.resize()</p><p>快速使用 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = cv.resize(img,(width,height))</span><br><span class="line"># 默认双线性插值</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">resize(InputArray src, OutputArray dst, Size dsize, </span><br><span class="line">        double fx=0, double fy=0, int interpolation=INTER_LINEAR )</span><br><span class="line"></span><br><span class="line">InputArray src ：输入，原图像</span><br><span class="line">OutputArray dst： 输出，缩放后的图像</span><br><span class="line"></span><br><span class="line">dsize：输出图像的大小，要元组类型，两个元素xy。</span><br><span class="line"></span><br><span class="line">fx：width方向的缩放比例</span><br><span class="line">fy：height方向的缩放比例</span><br><span class="line"></span><br><span class="line">interpolation：指定插值方法</span><br><span class="line"></span><br><span class="line">INTER_NEAREST - 最邻近插值</span><br><span class="line">INTER_LINEAR - 双线性插值(默认)</span><br><span class="line">INTER_CUBIC - 4x4像素邻域内的双立方插值</span><br><span class="line">INTER_LANCZOS4 - 8x8像素邻域内的Lanczos插值</span><br></pre></td></tr></table></figure><p>图片缩放函数</p><p>来自<ahref="https://blog.csdn.net/tzj1844400/article/details/105648680">计算机视觉图像处理-CV2与图像插值算法</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def inter(img):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    图像缩放</span><br><span class="line">    param: img</span><br><span class="line">    return: None</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    scale_percent = 30       # percent of original size</span><br><span class="line">    width = int(img.shape[1] * scale_percent / 100)</span><br><span class="line">    height = int(img.shape[0] * scale_percent / 100)</span><br><span class="line">    dim = (width, height)</span><br><span class="line">    # 双线性插值缩小</span><br><span class="line">    resized = cv2.resize(img, dim, interpolation = cv2.INTER_LINEAR)  # 缩小到0.3 </span><br><span class="line"></span><br><span class="line">    # 缩放大小</span><br><span class="line">    fx = 1.5</span><br><span class="line">    fy = 1.5</span><br><span class="line">    # 方法1：最近邻插值放大</span><br><span class="line">    nearest_resized = cv2.resize(img, dsize=None, fx=fx, fy=fy, interpolation = cv2.INTER_NEAREST)</span><br><span class="line">    # 方法2：双线性插值放大</span><br><span class="line">    linear_resized = cv2.resize(img, dsize=None, fx=fx, fy=fy, interpolation = cv2.INTER_LINEAR)</span><br><span class="line"></span><br><span class="line">    # 展示结果</span><br><span class="line">    cv2.imshow(&quot;Resized image&quot;, resized)</span><br><span class="line">    cv2.imshow(&quot;INTER_NEAREST image&quot;, nearest_resized)</span><br><span class="line">    cv2.imshow(&quot;INTER_LINEAR image&quot;, linear_resized)</span><br><span class="line">    cv2.waitKey(0)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><p>4.保存</p><p>借用官方文档的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import cv2 as cv</span><br><span class="line">img = cv.imread(&#x27;messi5.jpg&#x27;,0)</span><br><span class="line">cv.imshow(&#x27;image&#x27;,img)</span><br><span class="line">k = cv.waitKey(0)</span><br><span class="line">if k == 27: # 等待ESC退出</span><br><span class="line">    cv.destroyAllWindows()</span><br><span class="line">elif k == ord(&#x27;s&#x27;): # 等待关键字，保存和退出</span><br><span class="line">    cv.imwrite(&#x27;messigray.png&#x27;,img)</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>手册说如果是64位，需使用<code>k = cv.waitKey(0)  &amp; 0xFF</code>但实测不需要也是对的。</p><h2 id="参考资料">参考资料</h2><p>[1] https://www.cnblogs.com/luozx207/p/8611459.html</p><p>[2] https://blog.csdn.net/qq_51491920/article/details/124408811</p><p>[3] <ahref="https://blog.csdn.net/weixin_41466575/article/details/113058802">cv2.resize()原理详解</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;opencv的python图像处理学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://splendidwave.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境下配置Anaconda3管理下的python(备忘录)</title>
    <link href="https://splendidwave.github.io/2022/10/06/2022-10/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AEAnaconda3%E7%AE%A1%E7%90%86%E4%B8%8B%E7%9A%84python(%E5%A4%87%E5%BF%98%E5%BD%95)/"/>
    <id>https://splendidwave.github.io/2022/10/06/2022-10/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AEAnaconda3%E7%AE%A1%E7%90%86%E4%B8%8B%E7%9A%84python(%E5%A4%87%E5%BF%98%E5%BD%95)/</id>
    <published>2022-10-06T07:58:32.000Z</published>
    <updated>2022-12-12T08:23:26.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>在centos7下安装anaconda3并管理python</p><span id="more"></span><h2 id="安装anaconda3">1.安装Anaconda3</h2><p>在<ahref="https://www.anaconda.com/products/distribution#linux">官网</a>下载最新版或者使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.2.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure> 在镜像源上下载。</p><p>下载完成后使用<code>sh Anaconda3-5.2.0-Linux-x86_64.sh</code>进行安装</p><p>一路回车然后yes，然后会让你选择安装路径，默认为<code>当前用户/anaconda3</code></p><p>随后会问是否添加环境变量（yes），是否安装vscode（no）</p><p>最后使用<code>conda info</code>来查看是否安装成功，如果出现<code>bash: conda: command not found</code>是没加入环境变量，或者添加了没重新生效，需要到用户目录下输入<code>source .bashrc</code></p><h2 id="创建环境">2.创建环境</h2><p><code>conda create -n envname python=3.9</code></p><p>其中envname是环境名，3.9是版本号，都可以替换</p><p>如果出现创建新环境有出现<code>CondaHTTPError: HTTP 000 CONNECTION FAILED for url</code>可能是防火墙等因素的问题，建议使用<code>conda config --remove-key channels</code>命令去除换源。</p><p>使用<code>source activate</code>进入base环境，这是基础环境，不建议在这里安装库，一些conda的命令见下文。</p><p>第一次需要使用<code>source activate</code>先激活一次，然后才能使用<code>conda activate envname</code>来直接激活对应环境。</p><h2 id="编写运行python">3.编写运行python</h2><p>使用<code>touch</code>或<code>vi</code>命令创建<code>.py</code>文件</p><p>在终端使用<code>python xxx.py</code>运行</p><h2 id="换源">4.换源</h2><p>如果有换源需要可以使用下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge </span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line"></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h2 id="conda的命令">5.conda的命令</h2><h3 id="创建环境-1">5.1 创建环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n envname python=3.9</span><br></pre></td></tr></table></figure><p>其中envname代表环境名</p><h3 id="进入虚拟环境">5.2 进入虚拟环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate envname</span><br></pre></td></tr></table></figure><h3 id="退出环境">5.3 退出环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><h3 id="删除环境">5.4 删除环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n envname --all</span><br></pre></td></tr></table></figure><h3 id="查看所有环境">5.5 查看所有环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure><h3 id="查看conda版本">5.6 查看conda版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure><h3 id="更新conda">5.7 更新conda</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update conda </span><br></pre></td></tr></table></figure><h3 id="备份旧环境">5.8 备份旧环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name new_env_name --clone old_env_name</span><br></pre></td></tr></table></figure><h3 id="查看当前环境安装的包">5.9 查看当前环境安装的包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><p>[1] https://blog.csdn.net/u013898698/article/details/117958663</p><p>[2] https://blog.csdn.net/Arno_An/article/details/105229780</p><p>[3] https://www.cnblogs.com/tianlang25/p/12433025.html</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;在centos7下安装anaconda3并管理python&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="备忘录" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="Linux" scheme="https://splendidwave.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7搭建mc服务器</title>
    <link href="https://splendidwave.github.io/2022/09/01/2022-9/CentOS7%E6%90%AD%E5%BB%BAmc%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://splendidwave.github.io/2022/09/01/2022-9/CentOS7%E6%90%AD%E5%BB%BAmc%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2022-09-01T06:51:32.000Z</published>
    <updated>2022-10-06T07:56:54.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>CentOS7是一个企业级的Linux发行版本，MC是一款著名的是沙盒类游戏，中国区由网易代理，网易版虽然本体免费，但在可拓展性上远远不及java版。在服务器上运行mc可以较为方便得让多人共同游玩，前提是你有好朋友。</p><span id="more"></span><p>暑假里用阿里云上白嫖的服务器玩了一个月，现在准备转移阵地，顺便写篇备份一下如何操作的。我使用的是阿里云的服务器mc的版本是1.17.1附带安装Forge。</p><h2 id="安装java环境">1.安装JAVA环境</h2><p>连接上你的远程服务器</p><p>通过下面的命令安装jdk16</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 下载JDK安装包，也可以自己去官网下载，如果出错就运行命令 yum install wget</span><br><span class="line">wget https://img.zeruns.tech/down/Java/OpenJDK16U-jdk_x64_linux_hotspot_16.0.1_9.tar.gz</span><br><span class="line"></span><br><span class="line"># 创建安装目录</span><br><span class="line">mkdir /usr/local/java/</span><br><span class="line"></span><br><span class="line"># 解压当前目录下的JDK压缩文件</span><br><span class="line">tar -zxvf OpenJDK16U-jdk_x64_linux_hotspot_16.0.1_9.tar.gz -C /usr/local/java/</span><br></pre></td></tr></table></figure><p>通过修改<code>/etc/profile</code>文件来配置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 使用vi编辑器编辑</span><br><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 用方向键滚动光标到末尾</span><br><span class="line"># 按i进入编辑模式</span><br><span class="line"># 将下面内容复制到文件末尾</span><br><span class="line"># 按esc后用:wq保存并退出</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk-16.0.1+9</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br><span class="line"></span><br><span class="line"># 应用修改后的环境变量</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line"># 软链接程序到环境变量中</span><br><span class="line">ln -sf /usr/local/java/jdk-16.0.1+9/bin/java /usr/bin/java</span><br><span class="line"></span><br><span class="line"># 测试是否安装正常，显示 openjdk version &quot;16.0.1&quot; 则为正常</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><h2 id="端口开放">2.端口开放</h2><p>在服务器的管理端开启mc服务器的端口，一般在<code>网络与安全-&gt;安全组-&gt;配置规则</code>mc的端口号默认是25565</p><p>推荐把tcp和udp都开一下，授权对象选全0</p><h3 id="下载服务端">3.下载服务端</h3><p>这里服务端的选择有许多种,区别可以看看参考资料[2],原版是官方的纯净版，不能装mod和插件。这里说一下mod和插件的区别，两者都是放在mod文件夹下，但是mod需要服务端和客户端都装，插件只需要服务器装。</p><p><ahref="https://www.minecraft.net/en-us/download/server">官方服务端</a></p><p><ahref="https://files.minecraftforge.net/net/minecraftforge/forge/">forge</a></p><p>找到对应的版本，两者务必要一样，forge是用来拓展mod的，如果你只想玩纯净版下第一个就行了。</p><p>我这里以1.17.1版本为例，先将两者放在window的同一目录下，双击<code>forge-1.17.1-37.1.1-installer.jar</code>选择installserver,再点击三个点，选择我们现在服务器要创建的该文件夹，点击确定，开始安装。安装过程可能会比较慢，这里中间过程有问题可以参考资料[3]</p><p>完成后在mod文件夹下放入要装的mods，没有mods文件夹的话自己新建一个,先不放也没事，运行服务器后会自动生成这个mod，有需要后面可以自己加。这里要注意mod和版本的匹配。</p><p>在自己电脑上配置，这样做一是操作简便一些，另一是到时候换服务器的时候可以节省这一步，直接上传到服务器上。</p><p>如果是新版本，如1.17，服务端会放在libraies里，旧版本会出一个<code>.jar</code>文件参考资料[4]</p><p>在服务器上新建一个文件夹，把文件上传上去(最开始的两个.jar文件可以不传)。不知道怎么传的推荐搜索一下mobaxterm</p><h3 id="运行服务器">4.运行服务器</h3><p>cd到对应目录</p><p><code>user_jvm_args.txt</code> 可以自己配置一下内存大小。</p><p>运行命令 <code>./run.sh</code></p><p>如果提示没有权限，输入<code>chmod +x run.sh</code>给予权限</p><p>第一次运行会报错，同时会生成一个eula文件，这是许可文件，把这个文件中的false改为true再启动一次就可以了</p><p>运行成功后先<code>stop</code>停止服务器</p><p>然后<code>vi server.properties</code>修改配置文件，这里可以自己去查找一下各个值的意思</p><p><strong>开服！！</strong></p><p>为了让服务器能在后台能一直跑，我们需要创建一个<code>screen</code>参考资料[5]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装screen</span><br><span class="line">yum install screen</span><br><span class="line"></span><br><span class="line"># 创建一个名为MinecraftServer的screen</span><br><span class="line">screen -S MinecraftServer</span><br><span class="line"></span><br><span class="line"># 启动服务器</span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure><p>运行成功后按Ctrl + A +D，将screen挂起运行,下次进入可以使用下面命令回到screen</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">screen -ls# 查看screen，记下MinecraftServer的编号</span><br><span class="line">screen -r &lt;MinecraftServer的编号&gt;</span><br></pre></td></tr></table></figure><p>现在进入我的世界客户端，注意mod也要配置一致，然后选多人游戏，输入服务器ip即可。给予op权限需要在后台输入<code>op &lt;玩家姓名&gt;</code></p><h2 id="参考资料">参考资料</h2><p>[1] https://blog.zeruns.tech/archives/636.html</p><p>[2] https://zhuanlan.zhihu.com/p/369785741</p><p>[3]https://blog.csdn.net/leleprogrammer/article/details/126120111</p><p>[4] https://blog.csdn.net/qq_41228599/article/details/123926758</p><p>[5] https://www.cnblogs.com/shiraka/p/14532465.html</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;CentOS
7是一个企业级的Linux发行版本，MC是一款著名的是沙盒类游戏，中国区由网易代理，网易版虽然本体免费，但在可拓展性上远远不及java版。在服务器上运行mc可以较为方便得让多人共同游玩，前提是你有好朋友。&lt;/p&gt;</summary>
    
    
    
    <category term="文化娱乐" scheme="https://splendidwave.github.io/categories/%E6%96%87%E5%8C%96%E5%A8%B1%E4%B9%90/"/>
    
    <category term="折腾与游戏" scheme="https://splendidwave.github.io/categories/%E6%96%87%E5%8C%96%E5%A8%B1%E4%B9%90/%E6%8A%98%E8%85%BE%E4%B8%8E%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="Linux" scheme="https://splendidwave.github.io/tags/Linux/"/>
    
    <category term="mc" scheme="https://splendidwave.github.io/tags/mc/"/>
    
  </entry>
  
</feed>
