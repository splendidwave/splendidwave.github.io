<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SplendidWave&#39;Blog</title>
  
  <subtitle>灿 烂 的 波</subtitle>
  <link href="https://splendidwave.github.io/atom.xml" rel="self"/>
  
  <link href="https://splendidwave.github.io/"/>
  <updated>2022-10-30T09:02:40.756Z</updated>
  <id>https://splendidwave.github.io/</id>
  
  <author>
    <name>splendidwave</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>opencv-python学习(6)--六个图像处理小项目</title>
    <link href="https://splendidwave.github.io/2022/10/29/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(6)--%E5%85%AD%E4%B8%AA%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    <id>https://splendidwave.github.io/2022/10/29/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(6)--%E5%85%AD%E4%B8%AA%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%B0%8F%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-10-29T07:47:32.000Z</published>
    <updated>2022-10-30T09:02:40.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>opencv的python图像处理学习笔记</p><p>转像素画、转字符画、图片九宫格、图片蒙太奇、幻影坦克、证件照裁剪。</p><p>部分代码参考互联网。 <span id="more"></span></p><h2 id="图像转像素画">1.图像转像素画</h2><p>效果如下</p><figure><img src="kl.png" alt="可莉像素" /><figcaption aria-hidden="true">可莉像素</figcaption></figure><p>实现原理是通过将图片缩小10倍，然后用最邻近插值放大回原来的尺寸。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 图片像素化</span><br><span class="line">def pixel_image(self):</span><br><span class="line">    img = self.image.copy()</span><br><span class="line">    rows, cols = img.shape[:2]</span><br><span class="line">    img = cv2.resize(img,(cols//10,rows//10))</span><br><span class="line">    img = cv2.resize(img,(cols,rows),interpolation=cv2.INTER_NEAREST)</span><br><span class="line">    win_name = &quot;pixel&quot;</span><br><span class="line">    UIFunctions.wait_key(self,img,win_name)</span><br></pre></td></tr></table></figure><p>其中<code>wait_key</code>函数内容是用opencv打开图片，然后接受一些保存等指令的函数。</p><h2 id="图片转字符画">2.图片转字符画</h2><p>效果图</p><figure><img src="zfh.jpg" alt="字符画" /><figcaption aria-hidden="true">字符画</figcaption></figure><p>原理是把图片转为灰度，然后根据灰度值将像素替换为对应字重的字符最后保存为txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 转为字符画</span><br><span class="line">def character_image(self):</span><br><span class="line">    img = UIFunctions.trun_gray(self,self.image)</span><br><span class="line">    rows, cols = img.shape[:2]</span><br><span class="line">    rows = rows//2</span><br><span class="line">    img = cv2.resize(img,(cols,rows))</span><br><span class="line">    lstChars = self.config.get(&#x27;General&#x27;,&#x27;file_character_list&#x27;)</span><br><span class="line">    output = self.config.get(&#x27;General&#x27;,&#x27;file_save_path&#x27;) + &quot;\\character.txt&quot;</span><br><span class="line">    g2c = 256/len(lstChars)</span><br><span class="line">    </span><br><span class="line">    txt = &quot;&quot;</span><br><span class="line">    for i in range(rows):</span><br><span class="line">        for j in range(cols):</span><br><span class="line">            txt += lstChars[int(img[i,j]/g2c)]</span><br><span class="line">        txt += &#x27;\n&#x27;</span><br><span class="line"></span><br><span class="line">    with open(output, &#x27;w&#x27;) as f:</span><br><span class="line">        f.write(txt)</span><br><span class="line">    QMessageBox.information(None, &#x27;提示&#x27;, &#x27;character.txt输出成功&#x27;,QMessageBox.Ok)</span><br></pre></td></tr></table></figure><p>为了表现效果，这里将高缩了一半。output是文件路径，lstChars是自定义的字符。上图使用的字符串是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$B8&amp;WM*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|1?-_+~&lt;&gt;i!lI,^`.</span><br></pre></td></tr></table></figure><p>注意把字重大的放前面。</p><h2 id="图片九宫格">3.图片九宫格</h2><p>图片九宫格是发朋友圈常用的一种格式，该项目可以辅助将一张图片切割成9张。</p><p>效果</p><figure><img src="nine.png" alt="图片九宫格" /><figcaption aria-hidden="true">图片九宫格</figcaption></figure><p>这个没啥说的就是切一下图片,因为懒得pip没用PIL库就直接对数组操作了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 九宫格</span><br><span class="line">def ninegrid_image(self):</span><br><span class="line">    # 切片函数</span><br><span class="line">    def cut_image(img,width):</span><br><span class="line">        box_list = []</span><br><span class="line">        if len(img.shape) == 2:</span><br><span class="line">            for i in range(0, 3):</span><br><span class="line">                for j in range(0, 3):</span><br><span class="line">                    box = img[i * width:(i+1) * width, j * width : (j + 1) * width]</span><br><span class="line">                    box_list.append(box)</span><br><span class="line">        elif len(img.shape) == 3:</span><br><span class="line">            for i in range(0, 3):</span><br><span class="line">                for j in range(0, 3):</span><br><span class="line">                    box = img[i * width:(i+1) * width, j * width : (j + 1) * width,:]</span><br><span class="line">                    box_list.append(box)</span><br><span class="line">        return box_list</span><br><span class="line"></span><br><span class="line">    img = self.image.copy()</span><br><span class="line">    value, ok = QInputDialog.getInt(self, &quot;输入窗口&quot;, &quot;请输入裁剪后的边值像素(正方形):&quot;, 300, 0, 2000, 100)</span><br><span class="line">    if ok:</span><br><span class="line">        value = int(value)*3</span><br><span class="line">        img = cv2.resize(img,(value,value))</span><br><span class="line">        box_list = cut_image(img,value//3)</span><br><span class="line">        for i,box in enumerate(box_list):</span><br><span class="line">            save_name = self.config.get(&#x27;General&#x27;,&#x27;file_save_path&#x27;) + &#x27;\\ninegrid_image\\&#x27; + str(i+1)+&#x27;.png&#x27;</span><br><span class="line">            cv2.imwrite(save_name,box)</span><br><span class="line">        QMessageBox.information(None, &#x27;提示&#x27;, &#x27;ninegrid_image输出成功&#x27;,QMessageBox.Ok)</span><br></pre></td></tr></table></figure><h2 id="图片蒙太奇">4.图片蒙太奇</h2><p>图片蒙太奇是指用一组图片去组合成一张大图的艺术效果。</p><p>图片有点大，放本地打开后再截图的图。</p><figure><img src="mtg.jpg" alt="蒙太奇" /><figcaption aria-hidden="true">蒙太奇</figcaption></figure><p>代码主要参考CSDN<ahref="https://blog.csdn.net/Galen_xia/article/details/107955374">蒙太奇照片制作(Opencv+Python)</a></p><p>原理是缩放待处理图片，然后匹配区块和图片的直方图找到最合适的，最后做一个融合让效果变好些。</p><p>理论上图库内容丰富越好。</p><h2 id="幻影坦克">5.幻影坦克</h2><p>幻影坦克是现代互联网图片表示的艺术，缩略图上看是一张图，但实际点开就变成了另一张，常见于贴吧。</p><p>效果图</p><figure><img src="tank.jpg" alt="幻影坦克" /><figcaption aria-hidden="true">幻影坦克</figcaption></figure><p>原理参考b站小迷糊老师的视频《<ahref="https://www.bilibili.com/video/BV1kV411v7fR/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">幻影坦克基础版</a>》</p><p>简单讲就是利用背景白色和黑色来叠加出不一样的图片。</p><p>灰度处理方面借用了《<ahref="https://blog.csdn.net/WinkySpeed/article/details/127079909">基于OpenCV实现的灰度图幻影坦克</a>》一文的思路</p><p>代码 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 幻影坦克</span><br><span class="line">def mirage_tank_image(self):</span><br><span class="line">    inside_pic = np.uint8(self.image.copy() * 0.35)</span><br><span class="line">    h,w = inside_pic.shape[:2]</span><br><span class="line">    get_filename_path, ok = QFileDialog.getOpenFileName(self,&quot;选取表图&quot;,self.config.get(&#x27;General&#x27;,&#x27;file_open_path&#x27;))</span><br><span class="line">    if ok:</span><br><span class="line">        out_pic = cv2.imread(get_filename_path)</span><br><span class="line">        # 调整表图大小 与里图一致</span><br><span class="line">        out_pic = cv2.resize(out_pic,(w,h))</span><br><span class="line">        # 如果强度小于100 拉到100</span><br><span class="line">        out_pic[out_pic&lt;100] = 100</span><br><span class="line">        # 转变为灰度图</span><br><span class="line">        inside_pic = UIFunctions.trun_gray(self,inside_pic)</span><br><span class="line">        out_pic = UIFunctions.trun_gray(self,out_pic)</span><br><span class="line">        # 建立新的画布 </span><br><span class="line">        new_pic = np.zeros((h,w,4), np.uint8)</span><br><span class="line">        # print(new_pic.shape)</span><br><span class="line">        # 遍历图片 套用公式</span><br><span class="line">        for i in range(h):</span><br><span class="line">            for j in range(w):</span><br><span class="line">                alpha = 255 - (out_pic[i,j]-inside_pic[i,j])</span><br><span class="line">                if alpha == 0:</span><br><span class="line">                    alpha = 1</span><br><span class="line">                p_new = np.uint8(255*inside_pic[i,j]/alpha)</span><br><span class="line">                new_pic[i,j,0] = p_new</span><br><span class="line">                new_pic[i,j,1] = p_new</span><br><span class="line">                new_pic[i,j,2] = p_new</span><br><span class="line">                new_pic[i,j,3] = alpha</span><br><span class="line">        win_name = &quot;tank&quot;</span><br><span class="line">        UIFunctions.wait_key(self,new_pic,win_name)</span><br></pre></td></tr></table></figure></p><h2 id="证件照处理">6.证件照处理</h2><p>如果你对证件照态度比较随便的话，可以直接用手机背靠墙拍一张，然后用这个方法处理，直接用打印机打印出来。</p><p>效果图</p><figure><img src="zjz.jpg" alt="证件照" /><figcaption aria-hidden="true">证件照</figcaption></figure><p>原理是建立对应大小的画布，然后把图片处理成1或2寸的，贴到对应位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"># 证件照处理</span><br><span class="line">def certificate_image(self):</span><br><span class="line">    # 1寸大小</span><br><span class="line">    WIDTH_1IN = 295</span><br><span class="line">    HEIGHT_1IN = 413</span><br><span class="line">    # 2寸大小</span><br><span class="line">    WIDTH_2IN = 413</span><br><span class="line">    HEIGHT_2IN = 626</span><br><span class="line">    # 5寸大小</span><br><span class="line">    WIDTH_5IN = 1500</span><br><span class="line">    HEIGHT_5IN = 1050</span><br><span class="line">    # 非全景6寸照片</span><br><span class="line">    WIDTH_6IN = 1950</span><br><span class="line">    HEIGHT_6IN = 1300</span><br><span class="line">    def cut_photo(photo,choice):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        将照片按照比例进行裁剪并缩放成1寸、2寸</span><br><span class="line">        :param photo: 待处理的照片</span><br><span class="line">        :param choice: &lt;int&gt; 1代表1寸，2代表2寸</span><br><span class="line">        :return: 处理后的照片</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        h,w = photo.shape[:2]</span><br><span class="line">        rate = h / w</span><br><span class="line">        if choice == 1:</span><br><span class="line">            if rate &lt; (HEIGHT_1IN/WIDTH_1IN):</span><br><span class="line">                cut = int((w - int(h / HEIGHT_1IN * WIDTH_1IN)) / 2)</span><br><span class="line">                cut_p = photo[:,cut:w-cut,:]</span><br><span class="line">            else:</span><br><span class="line">                cut = int((h - int(w / WIDTH_1IN * HEIGHT_1IN)) / 2)</span><br><span class="line">                cut_p = photo[cut:w-cut,:,:]</span><br><span class="line">            return cv2.resize(cut_p, (WIDTH_1IN, HEIGHT_1IN))</span><br><span class="line">        if choice == 2:</span><br><span class="line">            if rate &lt; (HEIGHT_2IN/WIDTH_2IN):</span><br><span class="line">                cut = int((w - int(h / HEIGHT_2IN * WIDTH_2IN)) / 2)</span><br><span class="line">                cut_p = photo[:,cut:w-cut,:]</span><br><span class="line">            else:</span><br><span class="line">                cut = int((h - int(w / WIDTH_2IN * HEIGHT_2IN)) / 2)</span><br><span class="line">                cut_p = photo[cut:w-cut,:,:]</span><br><span class="line">            return cv2.resize(cut_p, (WIDTH_2IN, HEIGHT_2IN))</span><br><span class="line"></span><br><span class="line">    # 5寸照排版1</span><br><span class="line">    def layout_photo_5_1(photo):</span><br><span class="line">        photo = cut_photo(photo,1)</span><br><span class="line">        img = np.ones((HEIGHT_5IN,WIDTH_5IN, 3), np.uint8)*255</span><br><span class="line">        img[HEIGHT_5IN//2,:,:] = 128            # 横线</span><br><span class="line">        img[:,int(WIDTH_5IN*0.25),:] = 128      # 竖线1</span><br><span class="line">        img[:,int(WIDTH_5IN*0.5),:] = 128      # 竖线2</span><br><span class="line">        img[:,int(WIDTH_5IN*0.75),:] = 128      # 竖线3</span><br><span class="line">        # 确定位置放上图片</span><br><span class="line">        focus_point = [0.125 * WIDTH_5IN,0.25 * HEIGHT_5IN]</span><br><span class="line">        start_point = [focus_point[0] - 0.5 * WIDTH_1IN, focus_point[1] - 0.5 * HEIGHT_1IN]</span><br><span class="line">        end_point = [focus_point[0] + 0.5 * WIDTH_1IN, focus_point[1] + 0.5 * HEIGHT_1IN]</span><br><span class="line">        for i in range(0,2):</span><br><span class="line">            for j in range(0,4):</span><br><span class="line">                img[int(start_point[1]+0.5*i*HEIGHT_5IN):int(end_point[1]+0.5*i*HEIGHT_5IN),int(start_point[0]+j*WIDTH_5IN/4):int(end_point[0]+j*WIDTH_5IN/4),:] = photo</span><br><span class="line">        return img</span><br><span class="line">    # 5寸混合排版2</span><br><span class="line">    def layout_photo_5_mix(photo):</span><br><span class="line">        photo1 = cut_photo(photo,1)</span><br><span class="line">        photo2 = cut_photo(photo,2)</span><br><span class="line">        photo2 = np.rot90(photo2)</span><br><span class="line">        img = np.ones((HEIGHT_5IN,WIDTH_5IN, 3), np.uint8)*255</span><br><span class="line">        img[HEIGHT_5IN//2,:,:] = 128            # 横线</span><br><span class="line">        img[:,int(WIDTH_5IN*0.25),:] = 128      # 竖线1</span><br><span class="line">        img[:,int(WIDTH_5IN*0.5),:] = 128      # 竖线2</span><br><span class="line">        # 确定位置放上1寸图片</span><br><span class="line">        focus_point = [0.125 * WIDTH_5IN,0.25 * HEIGHT_5IN]</span><br><span class="line">        start_point = [focus_point[0] - 0.5 * WIDTH_1IN, focus_point[1] - 0.5 * HEIGHT_1IN]</span><br><span class="line">        end_point = [focus_point[0] + 0.5 * WIDTH_1IN, focus_point[1] + 0.5 * HEIGHT_1IN]</span><br><span class="line">        for i in range(0,2):</span><br><span class="line">            for j in range(0,2):</span><br><span class="line">                img[int(start_point[1]+0.5*i*HEIGHT_5IN):int(end_point[1]+0.5*i*HEIGHT_5IN),int(start_point[0]+j*WIDTH_5IN/4):int(end_point[0]+j*WIDTH_5IN/4),:] = photo1</span><br><span class="line">        # 确定位置放上2寸图片</span><br><span class="line">        focus_point2 = [0.75 * WIDTH_5IN, 0.25 * HEIGHT_5IN]</span><br><span class="line">        start_point2 = [focus_point2[0] - 0.5 * HEIGHT_2IN, focus_point2[1] - 0.5 * WIDTH_2IN]</span><br><span class="line">        end_point2 = [focus_point2[0] + 0.5 * HEIGHT_2IN, focus_point2[1] + 0.5 * WIDTH_2IN]</span><br><span class="line">        img[int(start_point2[1]):int(end_point2[1]),int(start_point2[0]):int(end_point2[0]),:] = photo2</span><br><span class="line">        img[int(start_point2[1]+ 0.5 * HEIGHT_5IN):int(end_point2[1]+ 0.5 * HEIGHT_5IN),int(start_point2[0]):int(end_point2[0]),:] = photo2</span><br><span class="line">        return img</span><br><span class="line">    # 6寸混合排版1</span><br><span class="line">    def layout_photo_6_mix(photo):</span><br><span class="line">        photo1 = cut_photo(photo,1)</span><br><span class="line">        photo2 = cut_photo(photo,2)</span><br><span class="line">        photo1 = np.rot90(photo1)</span><br><span class="line">        img = np.ones((HEIGHT_6IN,WIDTH_6IN, 3), np.uint8)*255</span><br><span class="line">        img[HEIGHT_6IN//2,:,:] = 128            # 横线1</span><br><span class="line">        img[HEIGHT_6IN//4,:WIDTH_6IN//2,:] = 128 # 横线2</span><br><span class="line">        img[int(HEIGHT_6IN*0.75),:WIDTH_6IN//2,:] = 128 # 横线2</span><br><span class="line">        img[:,int(WIDTH_6IN*0.25),:] = 128      # 竖线1</span><br><span class="line">        img[:,int(WIDTH_6IN*0.5),:] = 128      # 竖线2</span><br><span class="line">        img[:,int(WIDTH_6IN*0.75),:] = 128      # 竖线3</span><br><span class="line">        # 确定位置放上1寸图片</span><br><span class="line">        focus_point = [0.125 * WIDTH_6IN, 0.125 * HEIGHT_6IN]</span><br><span class="line">        start_point = [focus_point[0] - 0.5 * HEIGHT_1IN, focus_point[1] - 0.5 * WIDTH_1IN]</span><br><span class="line">        end_point = [focus_point[0] + 0.5 * HEIGHT_1IN, focus_point[1] + 0.5 * WIDTH_1IN]</span><br><span class="line">        for i in range(0,4):</span><br><span class="line">            for j in range(0,2):</span><br><span class="line">                img[int(start_point[1]+0.25*i*HEIGHT_6IN):int(end_point[1]+0.25*i*HEIGHT_6IN),int(start_point[0]+j*WIDTH_6IN/4):int(end_point[0]+j*WIDTH_6IN/4),:] = photo1</span><br><span class="line">        # 确定位置放上2寸图片</span><br><span class="line">        focus_point2 = [0.625 * WIDTH_6IN, 0.25 * HEIGHT_6IN]</span><br><span class="line">        start_point2 = [focus_point2[0] - 0.5 * WIDTH_2IN, focus_point2[1] - 0.5 * HEIGHT_2IN]</span><br><span class="line">        end_point2 = [focus_point2[0] + 0.5 * WIDTH_2IN, focus_point2[1] + 0.5 * HEIGHT_2IN]</span><br><span class="line">        for i in range(0,2):</span><br><span class="line">            for j in range(0,2):</span><br><span class="line">                img[int(start_point2[1]+0.5*i*HEIGHT_6IN):int(end_point2[1]+0.5*i*HEIGHT_6IN),int(start_point2[0]+j*WIDTH_6IN/4):int(end_point2[0]+j*WIDTH_6IN/4),:] = photo2</span><br><span class="line"></span><br><span class="line">        return img</span><br><span class="line"></span><br><span class="line">    img = self.image.copy()</span><br><span class="line">    items = (&#x27;1寸&#x27;, &#x27;2寸&#x27;, &#x27;5寸(8*1寸)&#x27;, &#x27;5寸(4*1寸+2*2寸)&#x27;, &#x27;6寸(8*1寸+4*2寸)&#x27;)</span><br><span class="line">    item,ok = QInputDialog.getItem(self,&quot;区域分割&quot;,&quot;选择需要分成几块&quot;,items,3,False)</span><br><span class="line">    if ok:</span><br><span class="line">        if item == &#x27;1寸&#x27;:</span><br><span class="line">            img = cut_photo(img,1)</span><br><span class="line">        elif item == &#x27;2寸&#x27;:</span><br><span class="line">            img = cut_photo(img,2)</span><br><span class="line">        elif item == &#x27;5寸(8*1寸)&#x27;:</span><br><span class="line">            img = layout_photo_5_1(img)</span><br><span class="line">        elif item == &#x27;5寸(4*1寸+2*2寸)&#x27;:</span><br><span class="line">            img = layout_photo_5_mix(img)</span><br><span class="line">        elif item == &#x27;6寸(8*1寸+4*2寸)&#x27;:</span><br><span class="line">            img = layout_photo_6_mix(img)</span><br><span class="line"></span><br><span class="line">        win_name = &quot;ID photo&quot;</span><br><span class="line">        UIFunctions.wait_key(self,img,win_name)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;opencv的python图像处理学习笔记&lt;/p&gt;
&lt;p&gt;转像素画、转字符画、图片九宫格、图片蒙太奇、幻影坦克、证件照裁剪。&lt;/p&gt;
&lt;p&gt;部分代码参考互联网。</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://splendidwave.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv-python学习(5)--傅里叶变换与小波变换</title>
    <link href="https://splendidwave.github.io/2022/10/25/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(5)--%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/"/>
    <id>https://splendidwave.github.io/2022/10/25/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(5)--%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/</id>
    <published>2022-10-25T04:51:22.000Z</published>
    <updated>2022-10-30T07:42:49.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>opencv的python图像处理学习笔记</p><p>从空间基的角度介绍小波变换</p><span id="more"></span><h2 id="信号的数学表示">1. 信号的数学表示</h2><p>人类探索自然的工具是数学，为此探索的第一步就是将现实中的事物映射到数学上。</p><p>函数就是很好的工具，甚至可以将抽象的数学用图像的方法在坐标系中表示出来。比如一个阶跃信号，被表示为了一个幅值随时间变化的函数。它可以在平面直角坐标系中表示出来，其中横坐标代表时间，纵坐标是幅值。</p><figure><img src="jy.jpg" alt="阶跃信号" /><figcaption aria-hidden="true">阶跃信号</figcaption></figure><h2 id="距离与度量空间">2.距离与度量空间</h2><p>上面这图是使用Matlab绘制的，看着是连续的线，但实际上只是先绘制了一些离散的点，然后连接成线的。</p><p>平面上的点<spanclass="math inline">\(p_1\)</span>由两个坐标构成，一个是时间<spanclass="math inline">\(x_1\)</span>，一个是幅值<spanclass="math inline">\(y_1\)</span></p><p>平面集合中的两个元素<spanclass="math inline">\(p_1,p_2\)</span>，在数学上可以引入<strong>距离</strong>的概念，定义为<spanclass="math inline">\(d(p_1,p_2)\)</span>,该距离函数被称为空间集合上的度量，<strong>有距离函数的空间集合就称为度量空间。</strong></p><p>这里为便于理解就不给出严格的数学定义，下同。</p><h2 id="范数与赋范空间">3.范数与赋范空间</h2><p>有了度量函数就可以度量距离了，但是对于单个点的距离或者说是向量还没有办法度量。</p><p>如果你认为和零点的距离不就是向量的距离吗，那非常好，这个空间的范数就已经被定义了，<strong>拥有范数函数的空间集合就称为赋范空间。</strong></p><p>显而易见赋范空间应该包含于度量空间。</p><h2 id="线性空间内积空间与正交性">4.线性空间、内积空间与正交性</h2><p>线性空间的概念就非常熟悉了，满足加法的交换律结合律，乘法的分配律等就是线性空间，线性空间的好处在于任何一个元素都可以使用一组基来线性表示。</p><p>对于一个线性赋范空间，如果赋予它内积的运算，它就被称为内积空间，这个运算的数学上的意义是为了能将矢量转换为标量，显而易见内积空间应该包含于线性赋范空间。</p><p>当两个向量的内积为0时，这两个向量相互正交，如果一组基两两正交，则称这组基是正交基。</p><h2 id="希尔伯特空间">5.希尔伯特空间</h2><p>对于上图信号所处的空间来说，是一个简单的二维线性内积空间，其中维度就是指需要多少个值来描述空间中的一个元素。</p><p>因为它的坐标集合是实数集，所以这个空间又是完备的，有限维度的完备内积空间被数学家称为欧几里德空间。（完备性要求度量空间中的所有柯西序列都收敛于该空间的一点）</p><p>一个有限维度的空间只能表达低于该维度的函数，比如在平面直角坐标系中只能表示一维函数，曲面就需要在三维欧几里德空间中才能画出来。</p><p>维度是一方面的局限，另一个可以简化问题的决策在于基的选择。同样是二维的欧几里德空间，表示一个半径为1的圆，使用<span class="math inline">\(x\)</span>,<spanclass="math inline">\(y\)</span>方向的单位向量作为基底，可以写作<spanclass="math inline">\(x^2+y^2=1\)</span>，而在极坐标下只需要写<spanclass="math inline">\(r=1\)</span></p><p>假如有一个空间是无限维的，同时有很多基底供你选择，这样一个空间是不是很棒呢？实际上这也是科学家一直在努力的方向。一个维度不受限的欧几里德空间被称为希尔伯特空间。</p><h2 id="傅里叶变换与短时傅里叶变换">6.傅里叶变换与短时傅里叶变换</h2><p>希尔伯特空间维度是任意的n维，坐标轴的取值也可以从实数拓展到虚数，人类无法想象这个空间，但数学可以将它抽象出来。为方便理解，我们还是以欧几里德空间来想象它。</p><p>有了希尔伯特空间算是解决的第一个问题，无限维的好处是特征有无限多，任何的低维信号在希尔伯特空间都可以映射成向量。现在需要选取一些合适的基，最好的最容易理解和接受的基仍然是沿着假想中的坐标轴的单位向量。</p><p>其次是傅里叶提出的三角函数正交基，三角函数的正交性证明感兴趣的可以见参考资料<ahref="#refer-anchor-1"><sup>[4]</sup></a></p><p>傅里叶变换的本质就是在希尔伯特空间换了一组基来表示一个信号。为了区分，把以时间方向为基的表示称为时域表示，三角函数基称为频域表示。这一对表示有着非常有意思的性质，他们互为倒空间，在时域上极短的信号体现在频域上就是无限长，反过来也一样。</p><p>傅里叶变换很好用，但同时也有它的局限性，因为过多关注了频域，对于时域的信息反而获取不到。对于特定的情况，傅里叶变换后的信号可能没这么容易获取信息。</p><p>比如对于一个频率随时间变换的信号，出来的图像如图，上图表示时域信号，下图为频域信号</p><figure><img src="fft.jpg" alt="傅里叶变换的局限" /><figcaption aria-hidden="true">傅里叶变换的局限</figcaption></figure><p>可以看出频谱除了有4个比较明显的峰外还有许多振荡，而且没法体现出在时域信号中频率随时间变化这一显著的特点。</p><p>所以为了解决这一问题，短时傅里叶变换被提了出来。既然时间信息丢失了，那就补上，短时傅里叶变换和傅里叶变换唯一的区别在于多了一个窗口函数，用一个窗函数去框选时域信号，然后对这一部分再做傅里叶变换，这体现在空间中就是多了一个维度，用热力图来表示如下。</p><figure><img src="stft.jpg" alt="短时傅里叶变换" /><figcaption aria-hidden="true">短时傅里叶变换</figcaption></figure><p>短时傅里叶变换就很明显的表现出了时间上的频率变换，但问题在于要怎么知道这个窗口选多大才是合理的，选大了就会出现和傅里叶变换一样的问题出现时域信息丢失，选小了会让频域上的分辨率降低，这里倒是有点测不准原理的感觉了。</p><h2 id="小波变换">7.小波变换</h2><p>不知道该多大的窗口那不如把窗口也变为可变的，不过这样一来，维度又会多了一维，在三维空间里就显得失去了直观性。再往深了考虑的解决方法是使用自适应短时傅里叶变换，使用算法来让窗口自适应信号。</p><p>不过也可以换个角度思考，现在陷入瓶颈的原因还是在于使用了两个互为倒空间的基，出现了测不准的问题，如果重新在希尔伯特空间选择一个基，是否就能够解决这个问题。</p><p>首先波这个概念很好，有了波才引出了频域，我们希望保留它。其次加窗的想法也很好，它保留了时域的信息，这两者都是有物理意义的。这样我们是否能够使用一个小范围的波来作为基呢？起个名字就叫小波，用<spanclass="math inline">\(\psi(t)\)</span>来表示。，样子大概如下。</p><figure><img src="wave.png" alt="小波" /><figcaption aria-hidden="true">小波</figcaption></figure><p>当然这只是一个概念图，光有一个波可构不成希尔伯特空间的基。</p><p>好在我们是在线性空间里讨论的，只要一个集合能被一组已知的基完全线性表示，那这个集合也是一组基。这里完全线性表示的意思是用上了所有的元素才能表示全。</p><p>所以只要加上尺度变换<spanclass="math inline">\(\frac{1}{\sqrt{a}}\psi(\frac{t}{a})\)</span>,这样随着a的变换，在时域上看是变胖变瘦，在频域上看是遍历所有频率。前面的系数是为了归一化，同样为了方便处理，我们人为将小波在时域上的积分设置为0，这样就和三角函数相统一了。</p><p>解决了基的问题，好像顺带也把频域的特性提取问题解决了，因为小波基底的选择就是借用的波的概念，下一步是让波在时域上动起来，这个也很好处理，只要用初中学的函数平移就行。以小波为基底的变换就叫小波变换。下面直接给出函数<spanclass="math inline">\(f(t)\)</span>小波变换的完整公式。</p><p><span class="math display">\[W T(a, \tau)=\frac{1}{\sqrt{a}} \int_{-\infty}^{\infty} f(t) *\psi\left(\frac{t-\tau}{a}\right) d t\]</span></p><p>实际上小波不一定长得和上图一样，尺度变换也可以用其他方法表示，记作<spanclass="math inline">\(\phi(t)\)</span></p><p>小波的函数<spanclass="math inline">\(\psi(t)\)</span>被称为母小波，尺度函数<spanclass="math inline">\(\phi(t)\)</span>被称为父小波。确定了两者就可以愉快地进行小波变换了！</p><h2 id="参考资料">参考资料</h2><p>[1] <ahref="https://www.bilibili.com/video/BV1ce4y1p7jF/?spm_id_from=333.880.my_history.page.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">卷积神经网络的底层是傅里叶变换，傅里叶变换的底层是希尔伯特空间坐标</a></p><p>[2] <ahref="https://www.zhihu.com/question/332144499/answer/731866608">希尔伯特空间、内积空间的定义有什么关系和区别？</a></p><p>[3] <ahref="https://blog.csdn.net/weixin_36811328/article/details/81207753">欧几里得空间与希尔伯特空间</a></p><div id="refer-anchor-1"></div><p>[4] <ahref="https://www.bilibili.com/video/BV1Et411R78v/?from=search&amp;seid=7859464741790869886&amp;spm_id_from=333.337.0.0&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">纯干货数学推导_傅里叶级数与傅里叶变换_Part1_三角函数的正交性</a></p><p>[5] <ahref="https://zhuanlan.zhihu.com/p/143510464">Matlab中短时傅里叶变换spectrogram和stft的用法</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;opencv的python图像处理学习笔记&lt;/p&gt;
&lt;p&gt;从空间基的角度介绍小波变换&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://splendidwave.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv-python学习(4)--形态学与图像分割</title>
    <link href="https://splendidwave.github.io/2022/10/23/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(4)--%E5%BD%A2%E6%80%81%E5%AD%A6%E4%B8%8E%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    <id>https://splendidwave.github.io/2022/10/23/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(4)--%E5%BD%A2%E6%80%81%E5%AD%A6%E4%B8%8E%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/</id>
    <published>2022-10-23T08:57:32.000Z</published>
    <updated>2022-10-28T11:19:54.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>opencv的python图像处理学习笔记</p><span id="more"></span><h2 id="形态学处理">1.形态学处理</h2><h3 id="腐蚀">1.1 腐蚀</h3><p>原理：遍历原图像的每一个像素，然后用核的中心点对准当前正在遍历的这个像素，然后取当前结构元素所覆盖下的原图对应区域内的所有像素的最小值，用这个最小值替换当前像素值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = np.ones((3, 3), np.uint8)</span><br><span class="line">dst = cv2.erode(src, k, iterations=3)</span><br></pre></td></tr></table></figure><p>iterations是迭代次数，越多腐蚀力度越大</p><h3 id="膨胀">1.2 膨胀</h3><p>原理与腐蚀相同，改为使用最大值替换当前像素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = np.ones((3, 3), np.uint8)</span><br><span class="line">dst = cv2.dilate(src, k, iterations=3)</span><br></pre></td></tr></table></figure><h3 id="开运算与闭运算">1.3 开运算与闭运算</h3><p>先进行腐蚀再进行膨胀就叫做开运算</p><p>先膨胀在腐蚀就是闭运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = np.ones((3, 3), np.uint8)</span><br><span class="line">dst = cv2.morphologyEx(src,cv2.MORPH_OPEN,k)</span><br></pre></td></tr></table></figure><p>cv2.MORPH_OPEN：指定为开运算</p><p>cv2.MORPH_CLOSE：指定为闭运算</p><p>cv2.MORPH_GRADIENT 梯度运算（膨胀减去腐蚀）</p><p>cv2.MORPH_TOPHAT 礼帽 = 原始-开运算</p><p>cv2.MORPH_BLACKHAT 黑帽 = 闭运算-原始</p><h2 id="图像分割">2.图像分割</h2><h3 id="基于阈值的分割方法">2.1 基于阈值的分割方法</h3><ol type="1"><li>固定阈值分割&gt;这是最简单的分割方法，大于某一阈值就提取出来，但该方法使用范围也非常的窄。</li><li>直方图双峰法&gt;灰度直方图通常由双峰属性，两个峰值之间的最小值通常可以认为是最优的二值化分界点。</li><li>迭代阈值图像分割 &gt;1. 选取终止步长dt &gt;2. 选取初始阈值T0 &gt;3.使用T分割图像分为G1、G2两组 &gt;4. 统计G1、G2的平均灰度m1、m2 &gt;5.新阈值为<span class="math inline">\(T=(m1+m2)/2\)</span> &gt;6.重复iii-v直到新阈值变动值小于dt</li><li>OTSU法（最大类间方差法/大津法）&gt;通过计算分割阈值的最大类间方差得到最合适的分割阈值，公式参考<ahref="https://blog.csdn.net/weixin_44842748/article/details/115827607">【图像分割】自适应阈值图像分割方法（最大类间差法与最大熵法）</a></li><li>最大熵法 &gt;同上，基于最大熵选取阈值</li></ol><h3 id="基于边缘检测的分割方法">2.2 基于边缘检测的分割方法</h3><p>锐化空间滤波器内容见上一篇博客，使用锐化算子可以检测出边缘并进行分割。</p><h3 id="基于区域的分割方法">2.3 基于区域的分割方法</h3><ol type="1"><li>区域生长法&gt;根据统一物体区域的像素相似性来聚集像素点达到区域生长的方法。</li><li>区域分裂合并法&gt;将图像任意分成若干互不相交的区域，按准则对这些区域进行分裂合并。差不多是生长法的逆过程。</li><li>分水岭法&gt;分水岭是用三维方法具象化二维图片，将灰度看着是海拔。模拟水淹没地形的过程，通过修建水坝的方式分割区域。</li></ol><h3 id="基于深度学习的分割方法">2.4 基于深度学习的分割方法</h3><p>K-MeansClustering（k聚类）是一种非监督学习算法，对于给定样本集，按照距离大小划分为k个簇。</p><p>opencv提供的api</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compactness, labels, (centers) = cv2.kmeans(data, K, bestLabels, criteria, attempts, centers)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>data：输入的样本数据，必须是按行组织样本，每一行为一个样本数据，列表示样本的维度。</li><li>K：最终的簇的数目。</li><li>bestLabels：预设的分类标签或者None。</li><li>criteria：迭代停止的模式选择，这是一个含有三个元素的元组型数。格式为（type,max_iter, epsilon）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其中type有如下模式：</span><br><span class="line">cv2.TERM_CRITERIA_EPS ：精确度（误差）满足epsilon，则停止。</span><br><span class="line">cv2.TERM_CRITERIA_MAX_ITER：迭代次数超过max_iter，则停止。</span><br><span class="line">cv2.TERM_CRITERIA_EPS+cv2.TERM_CRITERIA_MAX_ITER：两者结合，满足任意一个结束。</span><br></pre></td></tr></table></figure><ul><li>attempts：重复试验kmeans算法次数，将会返回最好的一次结果。</li><li>centers：初始中心选择： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.KMEANS_RANDOM_CENTERS：每次随机选择初始中心</span><br></pre></td></tr></table></figure></li></ul><p>返回值：</p><ul><li>compactness：密度，返回每个点到相应重心的距离的平方和。</li><li>labels：结果标记，每个成员被标记为分组的序号，如 0,1,2,3,4…等。</li><li>centers：由聚类的中心的描述信息(可能是坐标，也可能是色彩值)组成的数组。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#K-means均值聚类</span><br><span class="line">Z = img.reshape((-1, 3))</span><br><span class="line">Z = np.float32(Z)      #转化数据类型</span><br><span class="line">c = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)</span><br><span class="line">k = 4  # 聚类个数</span><br><span class="line">ret, label, center = cv2.kmeans(Z, k, None, c, 10, cv2.KMEANS_RANDOM_CENTERS)</span><br><span class="line">center = np.uint8(center)</span><br><span class="line">res = center[label.flatten()]</span><br><span class="line">output_img = res.reshape((img.shape))</span><br></pre></td></tr></table></figure><h3 id="opencv的人脸检测">3. opencv的人脸检测</h3><p>既然都提到图像分割和机器学习，这就不得不试一试人脸检测了。opencv有自带的训练好的数据，调一下库还是很快就能实现出来。</p><p>主要是使用分类器和检测多脸 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 加载人脸特征，该文件在 python安装目录\Lib\site-packages\cv2\data 下</span><br><span class="line">face_cascade = cv2.CascadeClassifier(&#x27;haarcascade_frontalface_default.xml&#x27;)</span><br><span class="line">faces = face_cascade.detectMultiScale(img, scaleFactor, minNeighbors, minSize,maxSize)</span><br><span class="line"></span><br><span class="line"># image表示的是要检测的输入图像</span><br><span class="line"># scaleFactor表示每次图像尺寸减小的比例</span><br><span class="line"># minNeighbors表示检测到多少次才算是目标</span><br><span class="line"># minSize为目标的最小尺寸 元组</span><br><span class="line"># maxSize为目标最大尺寸 元组</span><br><span class="line"># 除了image其他都可以不输入</span><br></pre></td></tr></table></figure></p><p>工程实例 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 人脸检测</span><br><span class="line">def facefind(self):</span><br><span class="line">   # 读入图片并转换为灰度</span><br><span class="line">   img = self.image</span><br><span class="line">   gray = UIFunctions.trun_gray(self,img)</span><br><span class="line">   # 加载人脸特征，该文件在 python安装目录\Lib\site-packages\cv2\data 下</span><br><span class="line">   face_cascade = cv2.CascadeClassifier(r&#x27;modules\haarcascade_frontalface_default.xml&#x27;)</span><br><span class="line">   faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=4, minSize=(20, 20))</span><br><span class="line">   # 绘制矩形框</span><br><span class="line">   for (x, y, w, h) in faces:</span><br><span class="line">      cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2)</span><br><span class="line">   win_name = &quot;face&quot;</span><br><span class="line">   UIFunctions.wait_key(self,img,win_name)</span><br></pre></td></tr></table></figure></p><h2 id="参考资料">参考资料</h2><p>[1] <ahref="https://blog.csdn.net/weixin_45848575/article/details/125420149">python-opencv图像处理-腐蚀和膨胀</a></p><p>[2] <ahref="https://blog.csdn.net/fengdu78/article/details/124011203">【深度学习】基于区域生长的图像分割算法！</a></p><p>[3]https://blog.csdn.net/weixin_53598445/article/details/123730985</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;opencv的python图像处理学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://splendidwave.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv-python学习(3)--加噪与空间滤波</title>
    <link href="https://splendidwave.github.io/2022/10/19/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(3)--%E5%8A%A0%E5%99%AA%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2/"/>
    <id>https://splendidwave.github.io/2022/10/19/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(3)--%E5%8A%A0%E5%99%AA%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2/</id>
    <published>2022-10-19T08:57:32.000Z</published>
    <updated>2022-10-21T07:52:20.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>opencv的python图像处理学习笔记</p><span id="more"></span><h2 id="图像噪声">1.图像噪声</h2><p>图像噪声是指存在于图像数据中的不必要的或多余的干扰信息。有些噪声严重影响了图片的质量，因此在图片预处理的过程中需要先将图片的噪声去除。</p><p>噪声通常是随机过程，需要具备一定的概率论相关知识才能更好的理解。</p><p>常见的噪声有如下几种：椒盐/高斯/泊松/散斑，下面给出使用python对图片加噪的方法。部分代码参考<ahref="https://blog.csdn.net/sinat_29957455/article/details/123977298">csdn文章python使用opencv对图像添加(高斯/椒盐/泊松/斑点)噪声</a></p><h3 id="椒盐噪声">1.1 椒盐噪声</h3><p>这个名字起的色香味俱全，椒盐噪声实际上指的是两种颜色的噪声，黑点为椒，白点为盐。在图片上的分布通常是随机的，就像是撒了胡椒和盐在图片上，由此得名。</p><p><strong>产生的原因</strong>通常是<strong>脉冲干扰</strong>或者<strong>传感器内部错误</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 加椒盐噪声</span><br><span class="line">def add_pepper_and_salt(self):</span><br><span class="line">    # 获取数量和椒盐比</span><br><span class="line">    amount = float(self.config.get(&quot;Noisy&quot;,&quot;noise_ratio&quot;))</span><br><span class="line">    p_vs_s = float(self.config.get(&quot;Noisy&quot;,&quot;pepper_vs_salt&quot;))</span><br><span class="line">    noisy_img = np.copy(self.image)</span><br><span class="line">    num_pepper = np.ceil(amount * noisy_img.size * p_vs_s)</span><br><span class="line">    num_salt = np.ceil(amount * noisy_img.size * (1. - p_vs_s))</span><br><span class="line">    #设置添加pepper噪声</span><br><span class="line">    coords = [np.random.randint(0, i - 1, int(num_pepper)) for i in self.image.shape]</span><br><span class="line">    noisy_img[tuple(coords)] = 0</span><br><span class="line">    #设置添加salt噪声</span><br><span class="line">    coords = [np.random.randint(0, i - 1, int(num_salt)) for i in self.image.shape]</span><br><span class="line">    noisy_img[tuple(coords)] = 255</span><br><span class="line">    # 展示</span><br><span class="line">    win_name = &quot;pepper&amp;salt&quot;</span><br><span class="line">    UIFunctions.wait_key(self,noisy_img,win_name)</span><br></pre></td></tr></table></figure><h3 id="高斯噪声">1.2 高斯噪声</h3><p>高斯噪声是一种非常常见的噪声，很多噪声都是服从正态分布的，他们被统一称为高斯噪声。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 加高斯噪声</span><br><span class="line">def add_gauss_noisy(self):</span><br><span class="line">    img = self.image</span><br><span class="line">    #获取均值和标准差</span><br><span class="line">    mean = float(self.config.get(&quot;Noisy&quot;,&quot;guass_mean&quot;))</span><br><span class="line">    sigma = float(self.config.get(&quot;Noisy&quot;,&quot;guass_sigma&quot;))</span><br><span class="line">    #生成高斯分布的噪声</span><br><span class="line">    gauss = np.random.normal(mean,sigma,img.shape)</span><br><span class="line">    #给图片添加高斯噪声</span><br><span class="line">    noisy_img = img + gauss</span><br><span class="line">    #设置图片添加高斯噪声之后的像素值的范围</span><br><span class="line">    noisy_img = np.uint8(np.clip(noisy_img,a_min=0,a_max=255))</span><br><span class="line">    # 展示</span><br><span class="line">    win_name = &quot;gauss_noisy&quot;</span><br><span class="line">    UIFunctions.wait_key(self,noisy_img,win_name)</span><br></pre></td></tr></table></figure><h3 id="泊松噪声">1.3 泊松噪声</h3><p>泊松噪声又称散粒噪声，适合于描述单位时间内随机事件发生的次数的概率分布。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 加泊松噪声</span><br><span class="line">def add_poisson_noisy(self):</span><br><span class="line">    img = self.image</span><br><span class="line">    lam = float(self.config.get(&quot;Noisy&quot;,&quot;poisson_lambda&quot;))</span><br><span class="line">    # 生成泊松分布的噪声</span><br><span class="line">    poisson = np.random.poisson(lam=lam,size=img.shape).astype(dtype=&#x27;uint8&#x27;)</span><br><span class="line">    noisy_img = img + poisson</span><br><span class="line">    noisy_img = np.uint8(np.clip(noisy_img,a_min=0,a_max=255))</span><br><span class="line">    # 展示</span><br><span class="line">    win_name = &quot;poisson_noisy&quot;</span><br><span class="line">    UIFunctions.wait_key(self,noisy_img,win_name)</span><br></pre></td></tr></table></figure><h3 id="散斑噪声">1.4 散斑噪声</h3><p>散斑的英文是Speckle，产生的原因通常是干涉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 加散斑噪声</span><br><span class="line">def add_speckle_noisy(self):</span><br><span class="line">    img = self.image</span><br><span class="line">    speckle = np.random.randn(*img.shape)</span><br><span class="line">    #给图片添加speckle噪声</span><br><span class="line">    noisy_img = img + img * speckle</span><br><span class="line">    #归一化图像的像素值</span><br><span class="line">    noisy_img = np.uint8(np.clip(noisy_img,a_min=0,a_max=255))</span><br><span class="line">    # 展示</span><br><span class="line">    win_name = &quot;speckle_noisy&quot;</span><br><span class="line">    UIFunctions.wait_key(self,noisy_img,win_name)</span><br></pre></td></tr></table></figure><h2 id="平滑空间滤波器">2.平滑空间滤波器</h2><h3 id="原理">2.1 原理</h3><p>滤波一词源于频域，指筛选掉一部分频率的波。但因为空域和频域是可以通过傅里叶变换相互转换的，所以在空间中对图像进行一些操作在频域上看起来就是滤波(如平滑操作对应于频域的低通滤波)。而且二者各有优劣，所以在空域上对图片进行处理统一称为空间滤波。</p><p>平滑滤波器的主要原理是针对每一个像素点对一个核内的数据进行对应处理实现平滑效果。有点类似与卷积但不完全是。</p><h3 id="均值滤波">2.2 均值滤波</h3><p>对核取平均值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.GaussianBlur(img,size)</span><br></pre></td></tr></table></figure><p>img 原图像</p><p>size 核大小，通常为奇数，如(3，3)</p><h3 id="高斯滤波">2.3 高斯滤波</h3><p>对核高斯加权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.GaussianBlur(src,ksize,sigmaX,sigmaY)</span><br><span class="line">cv2.GaussianBlur(img,(5,5),0,0)</span><br></pre></td></tr></table></figure><p>sigmaX,sigmaY分别表示X,Y方向的标准偏差。如果两者都为零，则根据内核大小计算它们。</p><h3 id="中值滤波">2.4 中值滤波</h3><p>取核内的中位数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.medianBlur(img, k)</span><br><span class="line">cv2.medianBlur(img,3)</span><br></pre></td></tr></table></figure><p>k 为方框的尺寸</p><h2 id="锐化空间滤波器">3.锐化空间滤波器</h2><h3 id="原理-1">3.1 原理</h3><p>通过找到灰度变换明显的区域，强化该范围像素。</p><p>这里涉及到寻找一个跳变（边缘）的过程，所以可以采用求导的方法。一阶导或者二阶导（拉普拉斯算子）</p><p>因为是寻找边缘，所以还可以用来进行腐蚀，膨胀，边缘检测等操作。</p><h3 id="sobel">3.2 sobel</h3><p>索贝尔算子方法简单、处理速度快，被广泛应用于边缘提取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=5)</span><br></pre></td></tr></table></figure><p>其中第二个参数是数据类型，第3、4个参数是dx,dy表示水平方向/竖直方向，要求两者只能有一个为1，另一个为0,第5个值表示核的大小</p><h3 id="scharr">3.3 scharr</h3><p>当索贝尔算子的第五个参数为-1时，就变成了夏尔算子,scharr是sobel的一个增强，如下图</p><figure><img src="ss.png" alt="scharr 和 sobel" /><figcaption aria-hidden="true">scharr 和 sobel</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.Scharr(img, cv2.CV_64F, 0, 1)</span><br></pre></td></tr></table></figure><h3 id="laplace">3.4 laplace</h3><p>拉普拉斯算子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.Laplacian(self.image, cv2.CV_64F)</span><br></pre></td></tr></table></figure><h3 id="canny">3.5 canny</h3><p>Canny算法年代久远，但可以说它是边缘检测的一种标准算法，而且仍在广泛使用。</p><p>Canny边缘检测算法可以分为以下5个步骤： 1. 高斯滤波来平滑图像去除噪声2. 找寻图像的强度梯度 3. 应用非最大抑制（non-maximumsuppression）技术来消除边误检 4.应用双阈值的方法来决定可能的（潜在的）边界 5. 利用滞后技术来跟踪边界</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.Canny(img, lowThreshold, highThreshold)</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><p>[1]https://blog.csdn.net/weixin_40922285/article/details/102801633</p><p>[2] https://baike.baidu.com/item/canny%E7%AE%97%E6%B3%95/8439208</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;opencv的python图像处理学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://splendidwave.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>numpy库使用多个元素的数组的真值不明确问题</title>
    <link href="https://splendidwave.github.io/2022/10/19/2022-10/numpy%E5%BA%93%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E7%9C%9F%E5%80%BC%E4%B8%8D%E6%98%8E%E7%A1%AE%E9%97%AE%E9%A2%98/"/>
    <id>https://splendidwave.github.io/2022/10/19/2022-10/numpy%E5%BA%93%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E7%9C%9F%E5%80%BC%E4%B8%8D%E6%98%8E%E7%A1%AE%E9%97%AE%E9%A2%98/</id>
    <published>2022-10-19T02:57:32.000Z</published>
    <updated>2022-10-22T08:07:32.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>ValueError: The truth value of an array with more than one element isambiguous. Use a.any() or a.all()</p><span id="more"></span><h2 id="问题">问题</h2><p>总所周知，numpy库可以使用布尔值索引，这对加快python的矩阵处理速度起到了很大的作用。比如在图像处理中使用矩阵掩膜的方法<code>out_img[input == i] = xxx</code>可以快速对满足条件的值赋值（比如应用在直方图均衡）。</p><p>同时使用<code>np.where(condition, x, y)</code>的方法可以更快得同时处理满足条件和不满足条件的情况,满足修改为x，不满足修改为y。</p><p>但使用二维矩阵的俩个条件时就会报错，如要让大于等于era1和小于era2的值赋255，不满足服0<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layer = np.where((layer&gt;=era1) and (layer&lt;era2),255,0)</span><br><span class="line">ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()</span><br></pre></td></tr></table></figure></p><p>当然用<code>a&lt;x&lt;b</code>的条件也是不行的。</p><h2 id="解决方法">解决方法</h2><ol type="1"><li><p>使用运算符号代替逻辑运算，把“or”改为“+”或“|”，“and”改为“*”或“&amp;”在python中True是1，False是0，条件判断都是返回一个布尔值矩阵，在使用运算符号就可以实现矩阵的逻辑运算。</p></li><li><p>使用位运算<code>np.bitwise_and()</code>numpy库自带了一个计算位运算的函数，使用这个也可以实现矩阵逻辑运算</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;ValueError: The truth value of an array with more than one element is
ambiguous. Use a.any() or a.all()&lt;/p&gt;</summary>
    
    
    
    <category term="解决方案" scheme="https://splendidwave.github.io/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv-python学习(2)--灰度变换与直方图</title>
    <link href="https://splendidwave.github.io/2022/10/17/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(2)--%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%9B%B4%E6%96%B9%E5%9B%BE/"/>
    <id>https://splendidwave.github.io/2022/10/17/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(2)--%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%9B%B4%E6%96%B9%E5%9B%BE/</id>
    <published>2022-10-17T04:17:32.000Z</published>
    <updated>2022-10-20T01:50:28.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>opencv的python图像处理学习笔记</p><span id="more"></span><h2 id="灰度变换">1.灰度变换</h2><h3 id="灰度化">1.1 灰度化</h3><p>灰度化是将图片由RGB三通道转为只有灰度的单通道图片。</p><p>改变颜色空间使用<code>cvtColor(input_image, flag)</code>BGR↔︎灰色和BGR↔︎HSV的转换比较常用，这里主要看灰度图</p><p>cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def trun_gray(img):</span><br><span class="line">    try:</span><br><span class="line">        depth = img.shape[2]</span><br><span class="line">        if depth == 3:</span><br><span class="line">            return cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    except IndexError:</span><br><span class="line">        return img</span><br></pre></td></tr></table></figure><h3 id="二值化">1.2 二值化</h3><p>二值化是将图片矩阵转为只有0和255的图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv2.threshold(src, thresh, maxval, type)</span><br><span class="line"></span><br><span class="line">ret,binary = cv2.threshold(img,0,255,cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br></pre></td></tr></table></figure><p>传入源图片src，阈值thresh，最大值maxval，参数type，cv2.THRESH_OTSU指使用OTSU算法自动获取阈值，THRESH_BINARY等参数见下</p><p>返回ret是OTSU算法得到的阈值，binary是二值化后的图片</p><table><thead><tr class="header"><th style="text-align: center;">名称</th><th style="text-align: center;">含意</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">cv2.THRESH_BINARY</td><tdstyle="text-align: center;">像素灰度值小于阈值全为0,大于阈值全为255</td></tr><tr class="even"><td style="text-align: center;">cv2.THRESH_BINARY_INV</td><tdstyle="text-align: center;">像素灰度值小于阈值全为255,大于阈值全为0</td></tr><tr class="odd"><td style="text-align: center;">cv2.THRESH_TRUNC</td><tdstyle="text-align: center;">像素灰度值小于阈值不变,大于阈值变为阈值</td></tr><tr class="even"><td style="text-align: center;">cv2.THRESH_TOZERO</td><tdstyle="text-align: center;">像素灰度值小于阈值不做任何改变,大于阈值全为0</td></tr><tr class="odd"><td style="text-align: center;">cv2.THRESH_TOZERO_INV</td><tdstyle="text-align: center;">像素灰度值小于阈值全为0,大于阈值不做任何改变</td></tr></tbody></table><h3 id="图像反转">1.3 图像反转</h3><p>图像反转又称反色变换，记原图像矩阵为r，灰度范围为[0，L-1]</p><p>反转后图像公式如下 <span class="math display">\[s =  L-1-r\]</span></p><p>如果是二值图就相当于黑白反转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def image_inverse(x):</span><br><span class="line">    value_max = np.max(x)</span><br><span class="line">    y = value_max - x</span><br><span class="line">    return y</span><br></pre></td></tr></table></figure><h3 id="对数变换">1.4 对数变换</h3><p>通用变换规律 <span class="math display">\[s = c \cdot \ln(1+r)\]</span></p><p>其中加1是为了确保输出的值都大于0 对数通常以e为底。</p><p>变换是为了让图片的动态显示范围更直观，在实际展示时还要注意归一化。一个典型的用处就是展示傅里叶频谱图，频谱的低频值比较重要。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 归一化映射函数</span><br><span class="line">def normImg(self,x):</span><br><span class="line">    return  cv2.normalize(x,None,0,255,cv2.NORM_MINMAX)</span><br><span class="line"></span><br><span class="line">def log_image(self):</span><br><span class="line">  img = self.image</span><br><span class="line">  log = np.uint8(self.normImg(self,np.log(1.0 + img)))</span><br></pre></td></tr></table></figure></p><h3 id="伽马变换">1.5 伽马变换</h3><p>伽马变换又称幂律变换，可以提升暗部细节，对过白或过暗的图片进行矫正。</p><p>基本形式为</p><p><span class="math display">\[s = c (r + \epsilon)^\gamma\]</span></p><p>其中补偿系数<span class="math inline">\(\epsilon\)</span>一般为0</p><p>同样伽马变换也要注意映射到指定范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def gamma_image(self):</span><br><span class="line">  img = self.image</span><br><span class="line">  gamma = np.power(img, eps)</span><br><span class="line">  gamma = np.uint8(normImg(self,gamma))</span><br></pre></td></tr></table></figure><p><strong><spanclass="math inline">\(\gamma\)</span>大于1是增强暗度，小于1是增强亮度。</strong></p><h3 id="分段线性变换">1.6 分段线性变换</h3><h4 id="对比度拉伸">1.6.1 对比度拉伸</h4><p>没啥好说的，就是再映射</p><h4 id="灰度级分层">1.6.2 灰度级分层</h4><p>当只对某一范围的灰度感兴趣时，我们可以将该区域设置为白色或黑色，其他保持不变或变为另一种颜色。这样可以提取出想要的信息。</p><h4 id="比特屏幕分层">1.6.3 比特屏幕分层</h4><p>对于256级的8位灰度图，将每一位的灰度拆分出来，生成对应的二值图像，并将不同层次的灰度二值图像组合可以在不损失图像精度的前提下降低图像存储空间。</p><p>第1位，二值图像灰度值为1的灰度级区间为[2^0, 2^1) , 即 [0, 2);</p><p>第2位，二值图像灰度值为1的灰度级区间为[2^1, 2^2), 即 [2, 4);</p><p>...</p><p>第8位，二值图像灰度值为1的灰度级区间为[2^7, 2^8), 即 [128, 256)。</p><h2 id="直方图">2.直方图</h2><h3 id="opencv中的直方图">2.1 opencv中的直方图</h3><p>直方图是指把像素值（通常为[0,255]）的像素点个数统计出来画成直方图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 展示直方图</span><br><span class="line">def show_image_hist(self):</span><br><span class="line">    if len(self.image.shape) == 2:</span><br><span class="line">        # hist = cv2.calcHist([self.image],[0],None,[256],[0,256])</span><br><span class="line">        plt.hist(self.image.ravel(),256); </span><br><span class="line">    else:</span><br><span class="line">        color = (&#x27;b&#x27;,&#x27;g&#x27;,&#x27;r&#x27;)</span><br><span class="line">        for i,col in enumerate(color): </span><br><span class="line">            histr = cv2.calcHist([self.image],[i],None,[256],[0,256]) </span><br><span class="line">            plt.plot(histr,color = col) </span><br><span class="line">            plt.xlim([0,256])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>其中<code>.ravel()</code>是将矩阵拍成一维数组</p><p><code>cv2.calcHist(images,channels,mask,histSize,ranges)</code>是opencv的直方图接口，api参数如下</p><ul><li>images：原图像 当传入函数时应用中括号[]括起来，如[img]</li><li>channels：如果输入图像是灰度图，它的值就是[0]；如果是彩色图，传入的参数可以是[0],[1],[2]，分别对应通道B、G、R</li><li>mask：掩膜图像。统计整张图像的直方图就把它设置为None。当统计图像某一部分的直方图时，需要自己制作一个掩膜图像</li><li>histsize：BIN的数目。用中括号[]括起来，如[256]</li><li>ranges：像素值范围，通常为[0, 256]</li></ul><p>直方图均衡化也可以作为提高图像对比度的一个手段。下面给出一个opencv自带的均衡函数<code>dst = cv2.equalizeHist(img)</code>但通常这样操作效果不是很好，还需要考虑全局的信息，为解决该问题，需要使用<strong>自适应的直方图均衡化</strong>。该方法会将图片切成小块，进行均衡。但直接这样会让噪声也扩撒，所以在切成小块前要先把超过对比度上限的像素点均匀分散到其他bins上。</p><p>自适应直方图均衡化的opencvAPI是<code>cv2.createCLAHE(clipLimit, tileGridSize)</code></p><ul><li>clipLimit：对比度限制，默认是40</li><li>tileGridSize：分块的大小，默认为8*8</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个自适应均衡化的对象，并应用于图像</span><br><span class="line">clahe = cv.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))</span><br><span class="line">cl1 = clahe.apply(img)</span><br></pre></td></tr></table></figure><h3 id="直方图均衡原理">2.2 直方图均衡原理</h3><p>以灰度图像为例，它的直方图（不同灰度的像素点个数统计）的积分和为总像素点的个数，图像的灰度变量记为r。然后在其经过一个灰度变换<spanclass="math inline">\(T(r)\)</span>后，我们记为s，可知s的总像素个数应该与r相同，也就是说s的直方图积分等于r的直方图积分。同时将s和r归一化（横坐标由[0,L-1]映射到[0,1]，直方图的面积设置为1），这条定理也应该成立，公式如下：</p><p><span class="math display">\[\int_{0}^{b} p_{s}(s) d s=\int_{0}^{a} p_{r}(r) d r\]</span></p><p>其中<span class="math inline">\(a=b=1\)</span>,<spanclass="math inline">\(p_s\)</span>和<spanclass="math inline">\(p_r\)</span>分别为s和r的直方图函数，因为已经进行了归一化，它们的积分(面积)为1，这样也可以将<spanclass="math inline">\(p\)</span>看做是图像的概率密度分布函数。反正在计算机眼里，图片只是一些随机分布的噪点罢了。</p><p>另一方面，如果灰度变化函数是单调递增的函数，那么当<spanclass="math inline">\(b=T(a)\)</span>时，该公式也应当成立。给一个直观的参考图。</p><figure><img src="p.png" alt="灰度变化后直方图的关系" /><figcaption aria-hidden="true">灰度变化后直方图的关系</figcaption></figure><p>将上式改为微分形式(两边对s求导)有：</p><p><span class="math display">\[p_{s}(s)=\frac{p_{r}(r) d r}{d s}\]</span></p><p>想要让变化后的图片实现直方图均衡，即让<spanclass="math inline">\(p_s\)</span>恒等于1，代入可得</p><p><span class="math display">\[p_{r}(r)=\frac{d s}{d r}\]</span></p><p>两边再对r积分得到</p><p><span class="math display">\[s=\int_{0}^{x} p_{r}(r) d r\]</span></p><p>再将积分转换为离散的像素点的求和，最后别忘记了反归一化</p><p><span class="math display">\[s_{k}=(L-1)*\sum_{i=0}^{k} p_{r}(i)\]</span></p><p>这样我们就得到了输出图像灰度变量s，利用直方图巧妙地得到了灰度变化函数。再通过灰度变化函数对原图的像素点进行操作即可得到输出图像。</p><h3 id="直方图规定化">2.3 直方图规定化</h3><p>有时候均衡不是我们想要达到的目的，比如一个哥特风的cos照，均衡化后反而变亮了，失去了原有的风格。但原图拍摄的又比较暗，无法看清细节。所以我现在希望能将目标图像的直方图转变为我想要的直方图以实现图像变换的效果。</p><p>下面简单介绍原理，我们知道对于归一化的图像灰度变量a有</p><p><span class="math display">\[s=T(a) = \int_{0}^{x} p_{a}(a) d a\]</span></p><p>其中s是归一化平衡化直方图的灰度变量，它的概率密度函数恒为1 <spanclass="math inline">\(T\)</span>是a到s的灰度变换函数。</p><p>那同样对于我们需要的目标图像的灰度变量b，它所对应的平衡直方图也应该是s</p><p><span class="math display">\[s=G(b) = \int_{0}^{x} p_{b}(b) d b\]</span></p><p>其中<span class="math inline">\(G\)</span>是b到s的灰度变换函数。</p><p>这里理一下思路：</p><p>我们现在可以从目标图像B的灰度直方图中得出灰度变换函数<spanclass="math inline">\(G\)</span>、还可以从原图像A中得到均衡后的图像<spanclass="math inline">\(A^{&#39;}\)</span>，并且已知目标图像B的均衡后的图像<spanclass="math inline">\(B^{&#39;}\)</span>有<spanclass="math inline">\(B^{&#39;}=A^{&#39;}\)</span></p><p>现在的问题明确了，只要知道了<spanclass="math inline">\(G^{-1}\)</span>就可以由<spanclass="math inline">\(B^{&#39;}\)</span>获得目标图像B。但问题在于这个反函数没有这么容易求。不过在工程上倒是有一个近似方法，利用<spanclass="math inline">\(G\)</span>可以将[0,L-1]范围的像素先做一个映射表。然后通过遍历均衡后图像的像素点通过查表法映射回去。虽然不知道函数，但对于离散值，这样的计算也是足够了。</p><h2 id="参考资料">参考资料</h2><p>[1] https://blog.csdn.net/XWMRHZZ/article/details/124393745</p><p>[2] https://blog.csdn.net/my_cat__/article/details/125477831</p><p>[3] opencv官方手册</p><p>[4] https://blog.csdn.net/m0_47472749/article/details/114223563</p><p>[5] https://blog.csdn.net/gg13213/article/details/123671416</p><p>[6] <ahref="https://www.bilibili.com/video/BV1RF41177xo?share_source=copy_web&amp;vd_source=4ed37bc2c316b34de1f0a37e789af272">【手写图像处理库4】别再说数学理论鼓噪无味了，概率论的典型应用，直方图均衡化，一键完成对比度增强，懒人神器，数字图像处理，冈萨雷斯</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;opencv的python图像处理学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://splendidwave.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv-python学习(1)--读写与缩放</title>
    <link href="https://splendidwave.github.io/2022/10/11/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(1)--%E8%AF%BB%E5%86%99%E4%B8%8E%E7%BC%A9%E6%94%BE/"/>
    <id>https://splendidwave.github.io/2022/10/11/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(1)--%E8%AF%BB%E5%86%99%E4%B8%8E%E7%BC%A9%E6%94%BE/</id>
    <published>2022-10-11T09:27:32.000Z</published>
    <updated>2022-10-20T01:50:22.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>opencv的python图像处理学习笔记</p><span id="more"></span><h2 id="安装和导入">1.安装和导入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br></pre></td></tr></table></figure><h2 id="读取与显示">2.读取与显示</h2><p>读取图片 img = cv2.imread (filename,flags=None)</p><p>路径要全英文，图像路径错误不会报错会返回None</p><p>读取到了返回的是numpy.ndarray对象 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># -1表示保持原有的格式不变</span><br><span class="line"># 0表示将图像调整为单通道的灰度图像</span><br><span class="line"># 1表示将图像调整为3通道的BGR通道。为默认值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img=cv2.imread(&quot;test.jpg&quot;)</span><br><span class="line">img=cv2.imread(&quot;test.jpg&quot;,0)</span><br></pre></td></tr></table></figure></p><p>展示图片 cv.imshow(“窗口名字”,被读取的图片)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 显示一个可以调大小的窗口</span><br><span class="line">cv2.namedWindow(&quot;image&quot;,cv2.WINDOW_FREERATIO)</span><br><span class="line"></span><br><span class="line"># cv2.WINDOW_NORMAL# 用户可以改变这个窗口大小</span><br><span class="line"># cv2.WINDOW_AUTOSIZE# 窗口大小自动适应图片大小，并且不可手动更改。   </span><br><span class="line"># cv2.WINDOW_FREERATIO# 自适应比例</span><br><span class="line"># cv2.WINDOW_KEEPRATIO# 保持比例</span><br><span class="line"># cv2.WINDOW_OPENGL# 窗口创建的时候会支持OpenGL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 打开一个名为“image”的窗口并展示图片</span><br><span class="line">cv2.imshow(&quot;image&quot;,img)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 等待结束</span><br><span class="line">cv2.waitKey(0) </span><br><span class="line"># 不加窗口会闪退，值为时间单位ms，0代表永久</span><br><span class="line">cv2.destroyAllWindows() </span><br><span class="line"># 关掉所有窗口</span><br></pre></td></tr></table></figure><p>汇总 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img=cv2.imread(&quot;hmbb.jpg&quot;)</span><br><span class="line">print(&#x27;Original Dimensions : &#x27;,img.shape) # 显示图片大小等参数</span><br><span class="line"># cv2.namedWindow(&quot;image&quot;,cv2.WINDOW_FREERATIO)</span><br><span class="line">cv2.imshow(&quot;image&quot;,img)</span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h3 id="缩放">3.缩放</h3><p>cv2.resize()</p><p>快速使用 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = cv.resize(img,(width,height))</span><br><span class="line"># 默认双线性插值</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">resize(InputArray src, OutputArray dst, Size dsize, </span><br><span class="line">        double fx=0, double fy=0, int interpolation=INTER_LINEAR )</span><br><span class="line"></span><br><span class="line">InputArray src ：输入，原图像</span><br><span class="line">OutputArray dst： 输出，缩放后的图像</span><br><span class="line"></span><br><span class="line">dsize：输出图像的大小，要元组类型，两个元素xy。</span><br><span class="line"></span><br><span class="line">fx：width方向的缩放比例</span><br><span class="line">fy：height方向的缩放比例</span><br><span class="line"></span><br><span class="line">interpolation：指定插值方法</span><br><span class="line"></span><br><span class="line">INTER_NEAREST - 最邻近插值</span><br><span class="line">INTER_LINEAR - 双线性插值(默认)</span><br><span class="line">INTER_CUBIC - 4x4像素邻域内的双立方插值</span><br><span class="line">INTER_LANCZOS4 - 8x8像素邻域内的Lanczos插值</span><br></pre></td></tr></table></figure><p>图片缩放函数</p><p>来自<ahref="https://blog.csdn.net/tzj1844400/article/details/105648680">计算机视觉图像处理-CV2与图像插值算法</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def inter(img):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    图像缩放</span><br><span class="line">    param: img</span><br><span class="line">    return: None</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    scale_percent = 30       # percent of original size</span><br><span class="line">    width = int(img.shape[1] * scale_percent / 100)</span><br><span class="line">    height = int(img.shape[0] * scale_percent / 100)</span><br><span class="line">    dim = (width, height)</span><br><span class="line">    # 双线性插值缩小</span><br><span class="line">    resized = cv2.resize(img, dim, interpolation = cv2.INTER_LINEAR)  # 缩小到0.3 </span><br><span class="line"></span><br><span class="line">    # 缩放大小</span><br><span class="line">    fx = 1.5</span><br><span class="line">    fy = 1.5</span><br><span class="line">    # 方法1：最近邻插值放大</span><br><span class="line">    nearest_resized = cv2.resize(img, dsize=None, fx=fx, fy=fy, interpolation = cv2.INTER_NEAREST)</span><br><span class="line">    # 方法2：双线性插值放大</span><br><span class="line">    linear_resized = cv2.resize(img, dsize=None, fx=fx, fy=fy, interpolation = cv2.INTER_LINEAR)</span><br><span class="line"></span><br><span class="line">    # 展示结果</span><br><span class="line">    cv2.imshow(&quot;Resized image&quot;, resized)</span><br><span class="line">    cv2.imshow(&quot;INTER_NEAREST image&quot;, nearest_resized)</span><br><span class="line">    cv2.imshow(&quot;INTER_LINEAR image&quot;, linear_resized)</span><br><span class="line">    cv2.waitKey(0)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><p>4.保存</p><p>借用官方文档的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import cv2 as cv</span><br><span class="line">img = cv.imread(&#x27;messi5.jpg&#x27;,0)</span><br><span class="line">cv.imshow(&#x27;image&#x27;,img)</span><br><span class="line">k = cv.waitKey(0)</span><br><span class="line">if k == 27: # 等待ESC退出</span><br><span class="line">    cv.destroyAllWindows()</span><br><span class="line">elif k == ord(&#x27;s&#x27;): # 等待关键字，保存和退出</span><br><span class="line">    cv.imwrite(&#x27;messigray.png&#x27;,img)</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>手册说如果是64位，需使用<code>k = cv.waitKey(0)  &amp; 0xFF</code>但实测不需要也是对的。</p><h2 id="参考资料">参考资料</h2><p>[1] https://www.cnblogs.com/luozx207/p/8611459.html</p><p>[2] https://blog.csdn.net/qq_51491920/article/details/124408811</p><p>[3] <ahref="https://blog.csdn.net/weixin_41466575/article/details/113058802">cv2.resize()原理详解</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;opencv的python图像处理学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://splendidwave.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7配置Anaconda3管理下的python</title>
    <link href="https://splendidwave.github.io/2022/10/06/2022-10/CentOS7%E9%85%8D%E7%BD%AEAnaconda3%E7%AE%A1%E7%90%86%E4%B8%8B%E7%9A%84python/"/>
    <id>https://splendidwave.github.io/2022/10/06/2022-10/CentOS7%E9%85%8D%E7%BD%AEAnaconda3%E7%AE%A1%E7%90%86%E4%B8%8B%E7%9A%84python/</id>
    <published>2022-10-06T07:58:32.000Z</published>
    <updated>2022-10-06T10:32:27.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>在centos7下安装anaconda3并管理python</p><span id="more"></span><h2 id="安装anaconda3">1.安装Anaconda3</h2><p>在<ahref="https://www.anaconda.com/products/distribution#linux">官网</a>下载最新版或者使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.2.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure> 在镜像源上下载。</p><p>下载完成后使用<code>sh Anaconda3-5.2.0-Linux-x86_64.sh</code>进行安装</p><p>一路回车然后yes，然后会让你选择安装路径，默认为<code>当前用户/anaconda3</code></p><p>随后会问是否添加环境变量（yes），是否安装vscode（no）</p><p>最后使用<code>conda info</code>来查看是否安装成功，如果出现<code>bash: conda: command not found</code>是没加入环境变量，或者添加了没重新生效，需要到用户目录下输入<code>source .bashrc</code></p><p>成功后可以使用下面语句换源 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge </span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line"></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h2 id="创建环境">2.创建环境</h2><p><code>conda create -n envname python=3.9</code></p><p>其中envname是环境名，3.9是版本号，都可以替换</p><p>如果出现创建新环境有出现<code>CondaHTTPError: HTTP 000 CONNECTION FAILED for url</code>可能是防火墙等因素的问题，建议使用<code>conda config --remove-key channels</code>命令去除换源。</p><p>使用<code>source activate</code>进入base环境，这是基础环境，不建议在这里安装库，在base环境中可以使用一些命令见<ahref="https://splendidwave.github.io/2022/06/13/2022-6/anacodna3%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98%E5%BD%95/">anacodna3命令备忘录</a></p><h2 id="编写运行python">3.编写运行python</h2><p>使用<code>touch</code>或<code>vi</code>命令创建<code>.py</code>文件</p><p>在终端使用<code>python xxx.py</code>运行</p><h2 id="参考资料">参考资料</h2><p>[1] https://blog.csdn.net/u013898698/article/details/117958663</p><p>[2] https://blog.csdn.net/Arno_An/article/details/105229780</p><p>[3] https://www.cnblogs.com/tianlang25/p/12433025.html</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;在centos7下安装anaconda3并管理python&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="Linux" scheme="https://splendidwave.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>决策树模型基础</title>
    <link href="https://splendidwave.github.io/2022/09/09/2022-9/%E5%86%B3%E7%AD%96%E6%A0%91%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://splendidwave.github.io/2022/09/09/2022-9/%E5%86%B3%E7%AD%96%E6%A0%91%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2022-09-09T13:56:32.000Z</published>
    <updated>2022-09-09T13:56:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>决策树是一种基本的分类和回归方法，其具有可读性好，分类快等优点。在西瓜书中，决策树就作为例子引入了机器学习，说明了树模型是适合于新手入门学习的内容。本文会从基本概念逐一展开介绍几种决策树的基本算法。</p><span id="more"></span><h2 id="信息熵">1.信息熵</h2><p>信息熵是用来衡量一个体系的不确定度的物理量，熵这个词也是借用的热力学，信息熵越大，不确定性越强。计算公式如下</p><p><span class="math display">\[H(X)=-\sum_{i=1}^{M} P\left(x_{i}\right) \log _{2} P\left(x_{i}\right)\tag{1.1}\]</span></p><p>如果不太清楚这个概念可以通过该链接去了解一下<ahref="https://splendidwave.github.io/2022/08/20/2022-8/%E4%BF%A1%E6%81%AF%E9%87%8F%E5%92%8C%E4%BF%A1%E6%81%AF%E7%86%B5/">信息量和信息熵</a></p><p>在理解信息熵这个概念后，这里再补充一个<strong>条件熵</strong>，它指的是在某一条件Y下体系具有的信息熵。公式如下</p><p><span class="math display">\[H(X \mid Y)=-\sum_{i=1}^{M} P(x_i \mid Y) \log _{2} P(x_i \mid Y)\tag{1.2}\]</span></p><p>显然系统的条件熵要比信息熵要小一些，因为条件Y的发生让系统更加确定了一些，它们差值不妨就叫做<strong>信息增益</strong>。公式如下</p><p><span class="math display">\[I(X, Y)=H(X)-H(X \mid Y)\tag{1.3}\]</span></p><h2 id="判别条件">2.判别条件</h2><p>有了以上几个量化概念，我们就可以用来量化决策树。如果你还不知道什么是决策树，下面给个5分钟的小视频，相信不难理解。<ahref="https://www.bilibili.com/video/BV1ar4y137GD?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">[5分钟学算法]#03 决策树 小明毕业当行长</a></p><p>那么信息熵具体是如何量化决策树模型的好坏的呢？</p><p>让我们来看一个具体的例子。加入有一副去掉大小王的扑克牌(52张)，我从中随机抽取一张，想让机器狗旺财来帮我判别它是<strong>红色还是黑色</strong>。旺财无法直接识别颜色，它只能看见点数和花色,所以它需要用决策树的方法来处理这个问题。</p><p>旺财计算了一下该问题的信息熵</p><p><span class="math display">\[\begin{align}H(X) &amp; = -\sum_{i=1}^{M} P\left(x_{i}\right) \log _{2}P\left(x_{i}\right)\nonumber\\&amp; = \frac{1}{2} + \frac{1}{2} \nonumber \\&amp; = 1 \nonumber\end{align}\]</span></p><h3 id="使用点数决策-y_1">2.1 使用点数决策 <spanclass="math inline">\(Y_1\)</span></h3><p>它决定先试试点数，<strong>决策条件为点数大于等于10的都是红色</strong>。</p><p>那么条件熵为</p><p><span class="math display">\[H(X \mid Y_1) = (\frac{4}{13}+\frac{9}{13})\cdot(\frac{1}{4}\log_{2}{4}-\frac{3}{4}\log_{2}\frac{3}{4}) \approx 0.811\]</span></p><p>好像这个条件并没有起到任何帮助，信息增益为<spanclass="math inline">\(I(X, Y_1)=0.189\)</span></p><h3 id="使用花色决策-y_2">2.2 使用花色决策 <spanclass="math inline">\(Y_2\)</span></h3><p>旺财改变了策略，<strong>红桃的牌都是红色</strong>。</p><p>红桃牌的概率是1/4且全是红色 那么条件熵为</p><figure><img src="2.jpg" alt="决策2" /><figcaption aria-hidden="true">决策2</figcaption></figure><p><span class="math display">\[H(X \mid Y_2) = \frac{1}{4} \cdot 0 + \frac{3}{4} \cdot 0.91829 \approx0.689\]</span></p><p>信息增益为<span class="math inline">\(I(X,Y_2)=0.311\)</span>，看起来好了一些。</p><h3 id="花色决策2.0-y_3">2.3 花色决策2.0 <spanclass="math inline">\(Y_3\)</span></h3><p>旺财注意到上述决策中左节点的信息熵已经是0了，可以停止优化，而右节点的信息熵接近父节点的信息熵，说明优化空间很大，于是它对右节点再采策略认为<strong>方片也是红的</strong>。</p><p>毫无疑问信息信息增益达到了最大，旺财完美地完成了任务。</p><h2 id="id3算法">3.ID3算法</h2><p>ID 是 IterativeDichotomiser的缩写，迭代二分器/二叉树，虽然决策树不一定是二叉树，但通常情况下是二分的，3大概是第三代的意思吧。</p><p>上述这种以<strong>信息增益作为特征选择的度量</strong>，使用自顶向下的贪心算法遍历决策树空间的算法即为ID3算法。</p><p>通俗的讲该算法就是每一步都选择可以实现信息增益最大的特征作为该节点的分类条件直到特征用完或者分类结束。</p><p>程序流程图就放在后面给，现在来看看ID3算法优缺点。</p><h3 id="id3的优点">3.1 ID3的优点</h3><ol type="1"><li>简单，只需要算信息熵就完了。</li><li>鲁棒性强，不容易受到噪声的影响</li><li>搜索空间完整，基本上会遍历所有特征</li></ol><h3 id="id3的缺点">3.2 ID3的缺点</h3><ol type="1"><li>ID3算法会去选择可取值类别多的特征，这是信息熵的计算方法导致的，分得越细，确定性就会越高。</li><li>只能计算离散值</li><li>无法处理信息缺失</li><li>容易过拟合，因为它会遍历所有特征</li></ol><h2 id="c4.5算法">4.C4.5算法</h2><p>ID3 算法的发明人RossQuinlan也意识到了这些缺点，有问题就解决呗，ID3会对多分类有个偏好，这是因为信息增益的计算方式导致的，为了解决这一问题，必须将判别条件改变。</p><p>为此分裂信息的定义被提出，计算公式如下：</p><p><span class="math display">\[SplitInfo_A(D)=-\sum_{i=1}^{n} \frac{\left|D_{i}\right|}{|D|} \log _{2}\frac{\left|D_{i}\right|}{|D|}\tag{4.1}\]</span></p><p>其中D是数据集，<spanclass="math inline">\(D_i\)</span>是D在特征A下的第i个分类子集。可以看出分裂信息也特征的类别越多值就会越大。</p><p>所以只要将信息增益除以分裂信息就可以得到一个消除倾向的判别条件，我们称为<strong>信息增益率</strong>，计算公式如下：</p><p><span class="math display">\[\operatorname{GainRatio}(D,A)=\frac{I(D,A)}{\operatorname{SplitInfo_A}(D)} \tag{4.2}\]</span></p><p>对于连续的特征值，可以选择遍历这些值找到信息增益最大的分界点来实现对值的二分离散化。</p><p>信息缺失可以选择补上期望值，过拟合就采用剪枝的方法来完成。</p><p>这样问题就解决了不少，但这类算法还是存在硬伤。一是算法只能用于分类，二是构造过程需要反复遍历，比较大小，还是对数运算，算法效率低。</p><h2 id="cart3算法">5.CART3算法</h2><h3 id="不如换个判别条件">5.1 不如换个判别条件</h3><p>既然对数运算费时，不如直接抛开熵这个数值条件，重新找一个判别依据，公式如下</p><p><span class="math display">\[\operatorname{Gini}(D)=\sum_{k=1}^{K}\frac{\left|C_{k}\right|}{|D|}\left(1-\frac{\left|C_{k}\right|}{|D|}\right)=1-\sum_{k=1}^{K}p_{k}^{2} \tag{5.1}\]</span></p><p>我们称它为基尼系数，其中k为类别，<spanclass="math inline">\(p_k\)</span>是k类别的概率，它可以识别当前集合的纯度。来看一个具体例子，当k只能取两个值时，如红色牌的概率为<spanclass="math inline">\(p_1\)</span> 黑色牌概率为<spanclass="math inline">\(p_2\)</span>，而且有<spanclass="math inline">\(p_1=1-p_2\)</span>，代入式(5.1)可得基尼系数是一个关于<spanclass="math inline">\(p_1\)</span>的二次函数，关系如下图</p><figure><img src="gini.jpg" alt="基尼系数" /><figcaption aria-hidden="true">基尼系数</figcaption></figure><p>当集合中只有红色时，即概率<spanclass="math inline">\(p=1\)</span>，这时基尼系数为0，当红黑参半时，基尼系数会达到最大。由此可见，基尼系数越小，代表集合纯度越高。</p><p>我们可以以此为参考依据，遍历特征，选出加权基尼系数最小的分类方法作为策略。同时CART3永远对数据二分，离散连续一视同仁，二叉树的便捷性也是显而易见的。</p><h3 id="谁说树只能分类">5.2 谁说树只能分类</h3><p>CART树全名是Classification and RegressionTree，这说明它既能分类也能回归，回归树的构建本质上是用<strong>平方误差最小化准则</strong>进行特征选择，去生成二叉树。</p><p>其判别的条件又不是基尼系数了，而是最小均方差值，公式如下</p><p><span class="math display">\[\min_{j, s}\left[\min_{c_{1}} \sum_{x_{i} \in R_{1}(j,s)}\left(y_{i}-c_{1}\right)^{2}+\min_{c_2} \sum_{x_{i} \in R_{2}(j,s)}\left(y_{i}-c_{2}\right)^{2}\right] \tag{5.2}\]</span></p><p>其中因为特征是连续值，该公式的意思是选择第j个特征的s为切分点，这样集合就分为了<spanclass="math inline">\(R_1\)</span>和<spanclass="math inline">\(R_2\)</span>，使得两个区域的label值和该划分区域的值c平方和最小。得到j和s作为划分的依据，其中<spanclass="math inline">\(c_1\)</span>、<spanclass="math inline">\(c_2\)</span>取集合的均值： <spanclass="math display">\[c_{1}=\frac{1}{N_{1}} \sum_{x_{i} \in R_{1}} y_{i}, \quadc_{2}=\frac{1}{N_{2}} \sum_{x_{i} \in R_{2}} y_{i}\]</span></p><p>回归树但看公式可能有些困难，最好找道例题或者自己敲遍代码加强理解。另外cart算法也容易过拟合，需要配合减枝。</p><h2 id="随机森林">6.随机森林</h2><p>树看起来内容差不多了，但有很多树的时候，就形成了森林。为什么需要很多树？这是因为我们在处理问题时可能会不知道那些特征是有用的，那些特征是没有用的，为此不妨多训练几颗树，让每个树的特征随机选取。最后通过统计所有树的输出结果少数服从多数得到答案。</p><p>随机森林的结构简单而高效，当不知道用什么算法时不妨试试随机森林。而且这类集成学习的方法也不单单适用于决策树，同时也可以集成神经网络。</p><h2 id="boosting算法">7.Boosting算法</h2><p>Boosting是提升的意思，Boosting算法是通过把弱学习器加强成强学习器。一个典型的例子是GBDT算法</p><p>GBDT全称是Gradient Boosting DecisionTree，它利用CART的回归树作为弱学习器。这里只给出实现思路，具体公式暂不呈现。</p><p>我们引入一个残差的概念，它指的是模型的预测值和真实值的差距。当我们训练了一个树，它的输出结果会与真实值存在残差，我们可以再训练一个树来预测残差，当然这个预测残差的树也必然会与真实残差存在一个残差。不过没关系，我们可以套娃，套到结果可以接受的样子，大概的思路类似梯度下降法，同时公式也是用的一阶导数（负梯度）来近似残差。</p><p>另外还有XGBoost算法，XG是ExtremeGradient的意思，XGBoost在GBDT的基础上又做了改进，使用了二阶导数的信息，同时又加了一个正则项来防止过拟合。</p><h2 id="参考资料">参考资料</h2><p>[1] 《统计学习方法》 李航</p><p>[2] 《机器学习》 周志华</p><p>[3] 知乎文章 <ahref="https://zhuanlan.zhihu.com/p/399549773">零基础一文读懂树模型：从决策树到LightGBM</a></p><p>[4] 知乎文章 <ahref="https://zhuanlan.zhihu.com/p/158633779">【预估排序】Xgboost、GBDT、CART等树模型联系和区别（超级详细）</a></p><p>[5] CSDN文章 <ahref="https://blog.csdn.net/weixin_45834080/article/details/103036401">对ID3算法的理解及其优缺点</a></p><p>[6] b站视频 <ahref="https://www.bilibili.com/video/BV1VA411A7AQ?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">决策树算法例题</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;决策树是一种基本的分类和回归方法，其具有可读性好，分类快等优点。在西瓜书中，决策树就作为例子引入了机器学习，说明了树模型是适合于新手入门学习的内容。本文会从基本概念逐一展开介绍几种决策树的基本算法。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="机器学习" scheme="https://splendidwave.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7搭建mc服务器</title>
    <link href="https://splendidwave.github.io/2022/09/01/2022-9/CentOS7%E6%90%AD%E5%BB%BAmc%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://splendidwave.github.io/2022/09/01/2022-9/CentOS7%E6%90%AD%E5%BB%BAmc%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2022-09-01T06:51:32.000Z</published>
    <updated>2022-10-06T07:56:54.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>CentOS7是一个企业级的Linux发行版本，MC是一款著名的是沙盒类游戏，中国区由网易代理，网易版虽然本体免费，但在可拓展性上远远不及java版。在服务器上运行mc可以较为方便得让多人共同游玩，前提是你有好朋友。</p><span id="more"></span><p>暑假里用阿里云上白嫖的服务器玩了一个月，现在准备转移阵地，顺便写篇备份一下如何操作的。我使用的是阿里云的服务器mc的版本是1.17.1附带安装Forge。</p><h2 id="安装java环境">1.安装JAVA环境</h2><p>连接上你的远程服务器</p><p>通过下面的命令安装jdk16</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 下载JDK安装包，也可以自己去官网下载，如果出错就运行命令 yum install wget</span><br><span class="line">wget https://img.zeruns.tech/down/Java/OpenJDK16U-jdk_x64_linux_hotspot_16.0.1_9.tar.gz</span><br><span class="line"></span><br><span class="line"># 创建安装目录</span><br><span class="line">mkdir /usr/local/java/</span><br><span class="line"></span><br><span class="line"># 解压当前目录下的JDK压缩文件</span><br><span class="line">tar -zxvf OpenJDK16U-jdk_x64_linux_hotspot_16.0.1_9.tar.gz -C /usr/local/java/</span><br></pre></td></tr></table></figure><p>通过修改<code>/etc/profile</code>文件来配置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 使用vi编辑器编辑</span><br><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 用方向键滚动光标到末尾</span><br><span class="line"># 按i进入编辑模式</span><br><span class="line"># 将下面内容复制到文件末尾</span><br><span class="line"># 按esc后用:wq保存并退出</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk-16.0.1+9</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br><span class="line"></span><br><span class="line"># 应用修改后的环境变量</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line"># 软链接程序到环境变量中</span><br><span class="line">ln -sf /usr/local/java/jdk-16.0.1+9/bin/java /usr/bin/java</span><br><span class="line"></span><br><span class="line"># 测试是否安装正常，显示 openjdk version &quot;16.0.1&quot; 则为正常</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><h2 id="端口开放">2.端口开放</h2><p>在服务器的管理端开启mc服务器的端口，一般在<code>网络与安全-&gt;安全组-&gt;配置规则</code>mc的端口号默认是25565</p><p>推荐把tcp和udp都开一下，授权对象选全0</p><h3 id="下载服务端">3.下载服务端</h3><p>这里服务端的选择有许多种,区别可以看看参考资料[2],原版是官方的纯净版，不能装mod和插件。这里说一下mod和插件的区别，两者都是放在mod文件夹下，但是mod需要服务端和客户端都装，插件只需要服务器装。</p><p><ahref="https://www.minecraft.net/en-us/download/server">官方服务端</a></p><p><ahref="https://files.minecraftforge.net/net/minecraftforge/forge/">forge</a></p><p>找到对应的版本，两者务必要一样，forge是用来拓展mod的，如果你只想玩纯净版下第一个就行了。</p><p>我这里以1.17.1版本为例，先将两者放在window的同一目录下，双击<code>forge-1.17.1-37.1.1-installer.jar</code>选择installserver,再点击三个点，选择我们现在服务器要创建的该文件夹，点击确定，开始安装。安装过程可能会比较慢，这里中间过程有问题可以参考资料[3]</p><p>完成后在mod文件夹下放入要装的mods，没有mods文件夹的话自己新建一个,先不放也没事，运行服务器后会自动生成这个mod，有需要后面可以自己加。这里要注意mod和版本的匹配。</p><p>在自己电脑上配置，这样做一是操作简便一些，另一是到时候换服务器的时候可以节省这一步，直接上传到服务器上。</p><p>如果是新版本，如1.17，服务端会放在libraies里，旧版本会出一个<code>.jar</code>文件参考资料[4]</p><p>在服务器上新建一个文件夹，把文件上传上去(最开始的两个.jar文件可以不传)。不知道怎么传的推荐搜索一下mobaxterm</p><h3 id="运行服务器">4.运行服务器</h3><p>cd到对应目录</p><p><code>user_jvm_args.txt</code> 可以自己配置一下内存大小。</p><p>运行命令 <code>./run.sh</code></p><p>如果提示没有权限，输入<code>chmod +x run.sh</code>给予权限</p><p>第一次运行会报错，同时会生成一个eula文件，这是许可文件，把这个文件中的false改为true再启动一次就可以了</p><p>运行成功后先<code>stop</code>停止服务器</p><p>然后<code>vi server.properties</code>修改配置文件，这里可以自己去查找一下各个值的意思</p><p><strong>开服！！</strong></p><p>为了让服务器能在后台能一直跑，我们需要创建一个<code>screen</code>参考资料[5]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装screen</span><br><span class="line">yum install screen</span><br><span class="line"></span><br><span class="line"># 创建一个名为MinecraftServer的screen</span><br><span class="line">screen -S MinecraftServer</span><br><span class="line"></span><br><span class="line"># 启动服务器</span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure><p>运行成功后按Ctrl + A +D，将screen挂起运行,下次进入可以使用下面命令回到screen</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">screen -ls# 查看screen，记下MinecraftServer的编号</span><br><span class="line">screen -r &lt;MinecraftServer的编号&gt;</span><br></pre></td></tr></table></figure><p>现在进入我的世界客户端，注意mod也要配置一致，然后选多人游戏，输入服务器ip即可。给予op权限需要在后台输入<code>op &lt;玩家姓名&gt;</code></p><h2 id="参考资料">参考资料</h2><p>[1] https://blog.zeruns.tech/archives/636.html</p><p>[2] https://zhuanlan.zhihu.com/p/369785741</p><p>[3]https://blog.csdn.net/leleprogrammer/article/details/126120111</p><p>[4] https://blog.csdn.net/qq_41228599/article/details/123926758</p><p>[5] https://www.cnblogs.com/shiraka/p/14532465.html</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;CentOS
7是一个企业级的Linux发行版本，MC是一款著名的是沙盒类游戏，中国区由网易代理，网易版虽然本体免费，但在可拓展性上远远不及java版。在服务器上运行mc可以较为方便得让多人共同游玩，前提是你有好朋友。&lt;/p&gt;</summary>
    
    
    
    <category term="文化娱乐" scheme="https://splendidwave.github.io/categories/%E6%96%87%E5%8C%96%E5%A8%B1%E4%B9%90/"/>
    
    <category term="折腾与游戏" scheme="https://splendidwave.github.io/categories/%E6%96%87%E5%8C%96%E5%A8%B1%E4%B9%90/%E6%8A%98%E8%85%BE%E4%B8%8E%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="Linux" scheme="https://splendidwave.github.io/tags/Linux/"/>
    
    <category term="mc" scheme="https://splendidwave.github.io/tags/mc/"/>
    
  </entry>
  
  <entry>
    <title>信息量和信息熵</title>
    <link href="https://splendidwave.github.io/2022/08/20/2022-8/%E4%BF%A1%E6%81%AF%E9%87%8F%E5%92%8C%E4%BF%A1%E6%81%AF%E7%86%B5/"/>
    <id>https://splendidwave.github.io/2022/08/20/2022-8/%E4%BF%A1%E6%81%AF%E9%87%8F%E5%92%8C%E4%BF%A1%E6%81%AF%E7%86%B5/</id>
    <published>2022-08-20T08:45:32.000Z</published>
    <updated>2022-08-22T11:47:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言">引言</h2><p>随着计算机和个人手机的普及，人们常说我们现在进入了信息时代。另一方面，在我们日常互联网使用过程中的产生大数据也和我们的生活息息相关。在每天接触的过程中不知道你有没有考虑过为什么信息是可以被度量的？它又是怎么被计算的？</p><span id="more"></span><h2 id="概率和信息">1.概率和信息</h2><blockquote><p>“你这句话信息量真大”</p></blockquote><p>我们日常就会对信息产生一个笼统的概念，能大致判量的大小。具体而言似乎并不和字数成正比，比如说来段营销号文案。</p><blockquote><p>信息量和文案字数没有关系是怎么一回事呢，信息相信大家都很熟悉，但是信息量和文案字数没有关系是怎么一回事呢？下面就让小编带大家一起了解吧。大家可能会惊讶信息量和文案字数怎么会没有关系呢？但事实就是这样，小编也很惊讶。这就是关于信息量和文案字数没有关系的全部内容了，大家有什么想法可以在评论区告诉小编一起讨论哦！</p></blockquote><p>香农提出<strong>信息量应该与事件发生的概率相关，事情发生的概率越小，所包含的信息量就越大</strong>，这也非常好理解，有人对你说“太阳明天从东边升起”和“明天太阳要爆炸了”肯定是后者的信息量较大。</p><p>既然一个事件发生的概率(<spanclass="math inline">\(P\)</span>)越小，它所包含的信息量就越大。那我们是否能通过一个函数<spanclass="math inline">\(f(P)\)</span>来定量描述一下信息量呢。</p><p>这可得好好考虑一下。首先信息量的函数<spanclass="math inline">\(f(P)\)</span>是一个</p><ul><li>单调递减函数</li><li>定义域是[0,1]</li><li><span class="math inline">\(f(1)=0\)</span><br /></li><li><span class="math inline">\(f(0)=\infty\)</span></li></ul><p>还有一点，信息量应该可以相加表示两个独立的事件同时发生所包含的信息量，又根据概率论两个事件同时发生的概率为<spanclass="math inline">\(P_1*P_2\)</span>也就是说，<spanclass="math inline">\(f(p_1)+f(p_2)=f(P_1*P_2)\)</span></p><p>相信看到这个公式，这个信息量的函数的身份就已经呼之欲出了。对数函数可以完美满足了以上所有的条件。其次为了方便2进制计算机的使用和度量，我们通常采用公式<spanclass="math inline">\(f(p) =-\log_{2}{P}\)</span>来计算信息量。单位就记作bit，负号是为了满足递减的性质。</p><p>当然也可以使用10作为对数函数的基底，单位为哈莱特(Hartly);还有以e为基地，单位为奈特(nit)</p><h2 id="信息熵">2. 信息熵</h2><p>熵和量子这种新构名词听起来就很高大上，但解释起来倒是不难理解，信息量是单个事件的度量，而信息熵是用来表示事件集的平均信息量。</p><p>先给出公式，对于一个离散的信号源有</p><p><span class="math display">\[\left[\begin{array}{cccc}x_{1}, &amp; x_{2}, &amp; \cdots, &amp; x_{M} \\P\left(x_{1}\right), &amp; P\left(x_{2}\right), &amp; \cdots, &amp;P\left(x_{M}\right)\end{array}\right] \text {, 且 } \sum_{i=1}^{M} P\left(x_{i}\right)=1\]</span></p><p>其中<spanclass="math inline">\(x_i\)</span>是离散消息，对应二进制计算机就是0和1，<spanclass="math inline">\(P(x_i)\)</span>是离散消息<spanclass="math inline">\(x_i\)</span>发生的概率。</p><p>其信息熵<span class="math inline">\(H(x)\)</span>的计算公式如下：</p><p><span class="math display">\[H(x)=-\sum_{i=1}^{M} P\left(x_{i}\right) \log _{2} P\left(x_{i}\right)\]</span></p><p>这个公式就是将各自的信息量乘以发生的概率然后求和，这有什么用呢？首先作为平均信息量，它可以快速计算一段信息的总信息量，比如说该信号源发生了n位信息，那它的总信息量为<spanclass="math inline">\(I = n*H(x)\)</span></p><p>其次这个值就代表了数据编码的最小值。中文的信息熵是要高于英语，西班牙语，俄语等主流语言，所以在计算机中中文的文件会比其他语言的要大一些。</p><h2 id="存储单位和网速">3.存储单位和网速</h2><p>比特(bit)前面也介绍过了，这是计算机中最小的存储单位，8个bit为一个字节(Byte)缩写为B</p><p>以字节(Byte)为单元，计算机还有KB，MB，GB，TB换算如下</p><table><thead><tr class="header"><th style="text-align: center;">单位换算</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1 Byte = 8 bit</td></tr><tr class="even"><td style="text-align: center;">1 KB = 1024 B</td></tr><tr class="odd"><td style="text-align: center;">1 MB = 1024 KB</td></tr><tr class="even"><td style="text-align: center;">1 GB = 1024 MB</td></tr><tr class="odd"><td style="text-align: center;">1 TB = 1024 GB</td></tr></tbody></table><p>1024是2的10次方，这是计算机里常用的换算方法，对于硬盘厂商的换算还是以1000为单位换算</p><p>另外网络线路的计量单位是bps，比特每秒(bits persecond),所以对应我们常说的下载速度KB/MB要除以8.</p><h2 id="参考资料">参考资料</h2><p>[1] 《通信原理》第七版 曹丽娜 樊昌信</p><p>[2] 知乎问题 <ahref="https://www.zhihu.com/question/37998688/answer/489871504">世界上信息熵最大的语言是汉语吗？</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;随着计算机和个人手机的普及，人们常说我们现在进入了信息时代。另一方面，在我们日常互联网使用过程中的产生大数据也和我们的生活息息相关。在每天接触的过程中不知道你有没有考虑过为什么信息是可以被度量的？它又是怎么被计算的？&lt;/p&gt;</summary>
    
    
    
    <category term="文化娱乐" scheme="https://splendidwave.github.io/categories/%E6%96%87%E5%8C%96%E5%A8%B1%E4%B9%90/"/>
    
    <category term="逻辑与科普" scheme="https://splendidwave.github.io/categories/%E6%96%87%E5%8C%96%E5%A8%B1%E4%B9%90/%E9%80%BB%E8%BE%91%E4%B8%8E%E7%A7%91%E6%99%AE/"/>
    
    
    <category term="科普" scheme="https://splendidwave.github.io/tags/%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>使用树莓派3b搭OpenWrt</title>
    <link href="https://splendidwave.github.io/2022/08/11/2022-8/%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3b%E6%90%ADOpenwrt/"/>
    <id>https://splendidwave.github.io/2022/08/11/2022-8/%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3b%E6%90%ADOpenwrt/</id>
    <published>2022-08-11T07:45:32.000Z</published>
    <updated>2022-08-21T07:48:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>OpenWRT是一个嵌入式Linux系统，拥有强大的网络组件和扩展性，常用来作为主流路由器固件，使用OpenWrt作为软路由对用户来说意味着拥有个人定制化网络的权利<del>（并没有什么用）</del>。因此对于喜欢折腾的玩家来说，使用一个闲置的树莓派来刷openwrt系统是不错的选择。</p><p>本文树莓派型号是3b，OpenWrt固件版本为immortalwrt</p><span id="more"></span><h2 id="硬件准备">硬件准备</h2><ol type="1"><li>win10系统电脑一台</li><li>树莓派3b</li><li>网线</li><li>sd卡（8G就够了，要玩nas或docker的可以挂载硬盘）</li><li>读卡器</li></ol><h2 id="刷写固件">1.刷写固件</h2><p>可以按照该网址给出步骤操作</p><p>https://doc.openwrt.cc/1-General/1-Install-Upgrade/</p><p>下面给出我的步骤：</p><ol type="1"><li>下载<ahref="https://www.balena.io/etcher/">Etcher</a>这是一个刷写工具</li><li>下载储存还原固件</li><li>在软件源站下载进入如下目录<code>/releases/targets/bcm27xx/bcm2710/</code>下载<code>immortalwrt-bcm27xx-bcm2710-rpi-3-ext4-factory.img.gz</code>这是树莓派3b对应的固件下载路径。</li></ol><blockquote><p>树莓派3B和3B+都是Broadcom的cpu，3B是BCM2837A0，3B+是BCM2837B0;树莓派4B的cpu型号是Broadcom BCM2838. OpenWRT里对应型号是bcm27xx树莓派3B和3B+的Subtarget都是bcm2710 树莓派4B的Subtarget是bcm2711所以树莓派3b按步骤3的路径选，其他版本的openwrt同理。[1]</p></blockquote><p>下好后用Etcher洗掉sd卡的东西然后刷写进固件就可以了。</p><h2 id="基础配置">2.基础配置</h2><p>给树莓派插卡通电，可以看见一个名为openwrt的wifi，连接（也可以直接插网线）</p><p>打开浏览器，输入 http://192.168.1.1 进入路由器后台</p><p>输入默认用户名，root 和 password</p><p>进入luci界面如下</p><figure><img src="luci.png" alt="openwrt luci界面" /><figcaption aria-hidden="true">openwrt luci界面</figcaption></figure><h3 id="管理员密码修改">2.1 管理员密码修改</h3><p><code>系统</code>-&gt;<code>管理权</code></p><p>改完点一下保存</p><h3 id="网络接口">2.2 网络接口</h3><p>点击<code>网络</code> -&gt; <code>接口</code>这里可以配置lan口，点击<code>修改</code></p><p>我是当作旁路由使用的，主路由的ip是<code>102.168.3.1</code>所以这里设置格式如下。</p><figure><img src="接口.png" alt="接口配置" /><figcaption aria-hidden="true">接口配置</figcaption></figure><p>改WiFi密码在<code>网络</code>-&gt;<code>无线</code>-&gt;<code>无线安全</code>的加密这改。</p><h3 id="拓展">2.3 拓展</h3><p>在<code>系统</code>-&gt;<code>软件包</code>中可以安装下载需要的插件。</p><p>推荐在下载前扩容一下overlay，相关方法可以看B站BraveRu的视频<ahref="https://www.bilibili.com/video/BV1w541157Uo?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">极其详尽的OpenWRT软路由系统安装与设置教程（物理机安装）</a></p><p>插件的名字和功能也可以在网上搜到。</p><h2 id="结束">3.结束</h2><p>折腾了半天，发现刷一个软路由不能说收获满满，只能说毫无用处。。。</p><h2 id="参考资料">参考资料</h2><p>[1]https://www.itgeeker.net/raspberry-3b-3buse-openwrt-pure-org-img-to-install-and-config-socks5-agent-1/</p><p>[2] 知乎文章：<ahref="https://zhuanlan.zhihu.com/p/463838793">将树莓派3B刷成OpenWrt软路由，成为魔法WiFi上网的强大路由器</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;OpenWRT是一个嵌入式Linux系统，拥有强大的网络组件和扩展性，常用来作为主流路由器固件，使用OpenWrt作为软路由对用户来说意味着拥有个人定制化网络的权利&lt;del&gt;（并没有什么用）&lt;/del&gt;。因此对于喜欢折腾的玩家来说，使用一个闲置的树莓派来刷openwrt系统是不错的选择。&lt;/p&gt;
&lt;p&gt;本文树莓派型号是3b，OpenWrt固件版本为immortalwrt&lt;/p&gt;</summary>
    
    
    
    <category term="文化娱乐" scheme="https://splendidwave.github.io/categories/%E6%96%87%E5%8C%96%E5%A8%B1%E4%B9%90/"/>
    
    <category term="折腾与游戏" scheme="https://splendidwave.github.io/categories/%E6%96%87%E5%8C%96%E5%A8%B1%E4%B9%90/%E6%8A%98%E8%85%BE%E4%B8%8E%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="openwrt" scheme="https://splendidwave.github.io/tags/openwrt/"/>
    
    <category term="计算机网络" scheme="https://splendidwave.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTML标签速查</title>
    <link href="https://splendidwave.github.io/2022/07/31/2022-7/HTML%E6%A0%87%E7%AD%BE%E9%80%9F%E6%9F%A5/"/>
    <id>https://splendidwave.github.io/2022/07/31/2022-7/HTML%E6%A0%87%E7%AD%BE%E9%80%9F%E6%9F%A5/</id>
    <published>2022-07-31T01:45:32.000Z</published>
    <updated>2022-08-13T01:34:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开头">开头</h2><p><code>!</code>快速添加模板</p><p>charset="UTF-8"</p><p>lang="zh-CN"</p><span id="more"></span><h2 id="参考">参考</h2><p><ahref="https://blog.csdn.net/qq_52341981/article/details/119863488">HTML基本结构标签以及常用标签</a></p><p><ahref="https://blog.csdn.net/qq_57587705/article/details/124215974">HTML语法规范及其基本结构标签</a></p><p><ahref="https://b23.tv/6hTWJu4">黑马程序员前端Web全套教程，会打字就能学会的Web前端课程</a></p><h2 id="基本结构标签">基本结构标签</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;/html&gt;作为页面中一个最大的标签，包裹住其他小标签，称其为根标签</span><br><span class="line">&lt;head&gt;&lt;/head&gt;文档的头部，在这其中必须包含tilte标签</span><br><span class="line">&lt;title&gt;&lt;/title&gt;文档的标题，给页面设置标题</span><br><span class="line">&lt;body&gt;&lt;/body&gt;文档发主体，页面中的内容基本都放在改标签里。</span><br></pre></td></tr></table></figure><h2 id="常用标签">常用标签</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">标题标签：&lt;h1&gt;~&lt;h6&gt;一共六级选</span><br><span class="line">段落标签：&lt;p&gt;我是一个段落标签&lt;/p&gt;</span><br><span class="line">换行标签：&lt;/br&gt;——这是一个单标签</span><br><span class="line">文本格式化标签：将字体设置粗体、斜体、删除线或下划线效果</span><br><span class="line">加粗&lt;strong&gt;&lt;/strong&gt;或&lt;b&gt;&lt;/b&gt;常用&lt;strong&gt;&lt;/strong&gt;</span><br><span class="line">斜体&lt;em&gt;&lt;/em&gt;或&lt;i&gt;&lt;/i&gt;常用&lt;em&gt;&lt;/em&gt;</span><br><span class="line">删除线&lt;del&gt;&lt;/del&gt;或&lt;s&gt;&lt;/s&gt;常用&lt;del&gt;&lt;/del&gt;</span><br><span class="line">下划线&lt;ins&gt;&lt;/ins&gt;或&lt;u&gt;&lt;/u&gt;常用&lt;ins&gt;&lt;/ins&gt;</span><br></pre></td></tr></table></figure><h2 id="布局标签和链接">布局标签和链接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;一行只能放一个&lt;/div&gt;</span><br><span class="line">&lt;span&gt;一行能放多个&lt;/span&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">图片</span><br><span class="line">&lt;img src=&quot;此处写图像路径&quot;/&gt;</span><br><span class="line"></span><br><span class="line">超链接</span><br><span class="line">&lt;a href=&quot;跳转目标&quot;target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;</span><br><span class="line">其中_self为默认值，_blank为新窗口打开方式</span><br><span class="line"></span><br><span class="line">锚点</span><br><span class="line">&lt;h3 id = &quot;z&quot;&gt;&lt;/h3&gt;</span><br><span class="line">&lt;a href=&quot;#z&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="特殊字符">特殊字符</h2><figure><img src="tszf.png" alt="特殊字符对照表" /><figcaption aria-hidden="true">特殊字符对照表</figcaption></figure><h2 id="表格标签">表格标签</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">&lt;thead&gt;</span><br><span class="line">&lt;tr&gt; &lt;th&gt;表头单元格&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt;</span><br><span class="line">&lt;/thead&gt;</span><br><span class="line"></span><br><span class="line">&lt;tbody&gt;</span><br><span class="line">&lt;tr&gt; &lt;td&gt;单元格文字&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/tobdy&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>以下属性要写入table里<code>&lt;table align = "center"&gt;</code>都可以用CSS控制 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">align = &quot;left&quot;/&quot;center&quot;/&quot;right&quot;</span><br><span class="line">border = &quot;1&quot;</span><br><span class="line">cellpadding = &quot;像素值&quot; 单元格边框和内容的边距 默认1</span><br><span class="line">cellspacing = &quot;像素值&quot; 单元格之间的空白 默认2 通常为0</span><br><span class="line">width = &quot;像素值&quot; 单元格宽度</span><br><span class="line">height = &quot;像素值&quot; 单元格高度</span><br></pre></td></tr></table></figure></p><p>合并单元格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">跨行合并：rowspan = &quot;合并单元格的个数&quot; 写在最上侧单元格</span><br><span class="line">跨列合并：colspan = &quot;合并单元格的个数&quot; 写在最左侧单元格</span><br></pre></td></tr></table></figure><h2 id="列表标签">列表标签</h2><h3 id="无序列表">无序列表</h3><p>ul 里只能放 li 标签 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><h3 id="有序列表">有序列表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义列表">自定义列表</h3><p>dt和dd数量没有限制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">&lt;dt&gt;&lt;/dt&gt;</span><br><span class="line">&lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">&lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure><h2 id="表单">表单</h2><h3 id="表单域">表单域</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单域名称&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h3 id="表单控件表单元素">表单控件（表单元素）</h3><h4 id="input">input</h4><p>单标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;属性值&quot; &gt; &lt;br&gt;</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th>属性值</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>button</td><td>按钮，通过JavaScript启动脚本</td></tr><tr class="even"><td>checkbox</td><td>复选框</td></tr><tr class="odd"><td>text</td><td>可以输入文本</td></tr><tr class="even"><td>color</td><td>定义拾色器</td></tr><tr class="odd"><td>radio</td><td>单选框</td></tr><tr class="even"><td>date</td><td>选择日期</td></tr><tr class="odd"><td>file</td><td>选择本地文件</td></tr><tr class="even"><td>number</td><td>数字</td></tr><tr class="odd"><td>password</td><td>密码</td></tr><tr class="even"><td>range</td><td>定义用于精确值不重要的输入数字的控件</td></tr><tr class="odd"><td>reset</td><td>重置</td></tr><tr class="even"><td>search</td><td>搜索</td></tr><tr class="odd"><td>submit</td><td>提交</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;xxx.php&quot; method=&quot;get&quot;&gt;</span><br><span class="line">用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;请输入用户名&quot; maxlength=&quot;8&quot;&gt; &lt;br&gt;</span><br><span class="line">密码：&lt;input type=&quot;passsword&quot; name=&quot;pwd&quot;&gt; &lt;br&gt;</span><br><span class="line">性别：男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; checked=&quot;checked&quot;&gt; 女 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt; 中性 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;中性&quot;&gt; &lt;br&gt;</span><br><span class="line">爱好：吃饭 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;吃饭&quot;&gt; 睡觉&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;睡觉&quot;&gt; 打豆豆 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;打豆豆&quot;&gt; &lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">上传头像：&lt;input type=&quot;file&quot;&gt; </span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;免费注册&quot;&gt;</span><br><span class="line">&lt;input type=&quot;reset&quot; name=&quot;重新填写&quot;&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;获取短信验证码&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h3 id="label标签">label标签</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;label for=&quot;text1&quot;&gt; 用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;text1&quot;&gt; &lt;br&gt;</span><br><span class="line">  &lt;label for=&quot;nan&quot;&gt; 男 &lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;nan&quot; name=&quot;sex&quot;&gt;&lt;label for=&quot;nv&quot;&gt; 女 &lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;nv&quot; name=&quot;sex&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;第一个单选按钮在表单之外,但它仍属于该表单的一部分。尝试点击文本标签切换单选按钮。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=&quot;demo_form.php&quot; id=&quot;form1&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;male&quot;&gt;&lt;br&gt;</span><br><span class="line">  &lt;label for=&quot;female&quot;&gt;Female&lt;/label&gt;</span><br><span class="line">  &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot; value=&quot;female&quot;&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;label for=&quot;male&quot; form=&quot;form1&quot;&gt;Male&lt;/label&gt;</span><br></pre></td></tr></table></figure><h3 id="select">select</h3><p>多选项选择，节省空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">籍贯：  </span><br><span class="line">&lt;select&gt;</span><br><span class="line">  &lt;option&gt;山东&lt;/option&gt;</span><br><span class="line">  &lt;option&gt;北京&lt;/option&gt;</span><br><span class="line">  &lt;option&gt;浙江&lt;/option&gt;</span><br><span class="line">  &lt;option&gt;天津&lt;/option&gt;</span><br><span class="line">  &lt;option selected=&quot;selected&quot;&gt;其他&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h3 id="textarea">textarea</h3><p>文本域</p><p>cols 是列数 rows是行数 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">今日反馈：</span><br><span class="line">&lt;textarea rows=&quot;3&quot; cols=&quot;10&quot;&gt;欢迎留言呀&lt;/textarea&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;开头&quot;&gt;开头&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;!&lt;/code&gt;快速添加模板&lt;/p&gt;
&lt;p&gt;charset=&quot;UTF-8&quot;&lt;/p&gt;
&lt;p&gt;lang=&quot;zh-CN&quot;&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="前端" scheme="https://splendidwave.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>VASP计算单层黑磷能带(HSE06)</title>
    <link href="https://splendidwave.github.io/2022/07/19/2022-7/VASP%E8%AE%A1%E7%AE%97%E5%8D%95%E5%B1%82%E9%BB%91%E7%A3%B7%E8%83%BD%E5%B8%A6(HSE06)/"/>
    <id>https://splendidwave.github.io/2022/07/19/2022-7/VASP%E8%AE%A1%E7%AE%97%E5%8D%95%E5%B1%82%E9%BB%91%E7%A3%B7%E8%83%BD%E5%B8%A6(HSE06)/</id>
    <published>2022-07-19T03:17:56.000Z</published>
    <updated>2022-09-05T09:33:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>vasp使用HSE06计算单层黑磷能带的方法</p><span id="more"></span><h2 id="前处理">前处理</h2><p>为加速计算结构优化和自洽仍采用PBE，同上一篇文章<ahref="https://splendidwave.github.io/2022/07/17/2022-7/VASP%E8%AE%A1%E7%AE%97%E5%8D%95%E5%B1%82%E9%BB%91%E7%A3%B7%E8%83%BD%E5%B8%A6(PBE)/#more">VASP计算单层黑磷能带(PBE)</a></p><h2 id="能带计算">能带计算</h2><p>将文件复制到一个band_hse文件夹，修改INCAR</p><figure class="highlight plaintext"><figcaption><span>INCAR</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># Global Parameters</span><br><span class="line">SYSTEM = BP_AB_hse06</span><br><span class="line">ISTART = 1 </span><br><span class="line">ISPIN =  1 </span><br><span class="line">ICHARG = 1</span><br><span class="line">LWAVE  = .F.</span><br><span class="line">LCHARG = .F.</span><br><span class="line">ENCUT = 500</span><br><span class="line">LORBIT = 11</span><br><span class="line"></span><br><span class="line"># Electronic Relaxation</span><br><span class="line">ISMEAR =  0</span><br><span class="line">SIGMA  =  0.05</span><br><span class="line">NELM =  300</span><br><span class="line">NELMIN =  6</span><br><span class="line">EDIFF = 1E-06</span><br><span class="line"></span><br><span class="line"># Ionic Relaxation</span><br><span class="line">NSW =  0</span><br><span class="line">IBRION =  -1</span><br><span class="line">ISIF =  3</span><br><span class="line">EDIFFG = -1E-03</span><br><span class="line">ISYM =  0</span><br><span class="line">POTIM = 0.2</span><br><span class="line"></span><br><span class="line">#HSE</span><br><span class="line">ALGO = Damped</span><br><span class="line">HFSCREEN = 0.2</span><br><span class="line">GGA = PE</span><br><span class="line">LHFCALC = .True.</span><br><span class="line">LMAXFOCK = 4</span><br><span class="line">PRECFOCK = Fast</span><br><span class="line">TIME = 0.4</span><br></pre></td></tr></table></figure><p>使用vaspkit的302生成新的k路径(KPATH)，251生成KPOINTS,</p><p>提交运行，HSE的运行时间会比较长</p><p>运行完成后使用252获得能带数据和带隙</p><h2 id="记一下运行指令">记一下运行指令</h2><h3 id="不挂断运行vasp">不挂断运行vasp</h3><p>nohup mpirun -np 6 vasp_std &amp;</p><p>6是核数，我自己的电脑是6核的</p><h3 id="查看运行文件">查看运行文件</h3><p>tail -f nohup.out</p><h2 id="参考资料">参考资料</h2><p>[1] <ahref="https://zhuanlan.zhihu.com/p/82078425">VASP之HSE06能带计算</a></p><p>[2] <ahref="https://zhuanlan.zhihu.com/p/446453016">HSE06计算带隙</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;vasp使用HSE06计算单层黑磷能带的方法&lt;/p&gt;</summary>
    
    
    
    <category term="科研项目" scheme="https://splendidwave.github.io/categories/%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="黑磷的拉曼光谱" scheme="https://splendidwave.github.io/categories/%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE/%E9%BB%91%E7%A3%B7%E7%9A%84%E6%8B%89%E6%9B%BC%E5%85%89%E8%B0%B1/"/>
    
    
    <category term="固体物理" scheme="https://splendidwave.github.io/tags/%E5%9B%BA%E4%BD%93%E7%89%A9%E7%90%86/"/>
    
    <category term="VASP" scheme="https://splendidwave.github.io/tags/VASP/"/>
    
  </entry>
  
  <entry>
    <title>VASP计算单层黑磷能带(PBE)</title>
    <link href="https://splendidwave.github.io/2022/07/17/2022-7/VASP%E8%AE%A1%E7%AE%97%E5%8D%95%E5%B1%82%E9%BB%91%E7%A3%B7%E8%83%BD%E5%B8%A6(PBE)/"/>
    <id>https://splendidwave.github.io/2022/07/17/2022-7/VASP%E8%AE%A1%E7%AE%97%E5%8D%95%E5%B1%82%E9%BB%91%E7%A3%B7%E8%83%BD%E5%B8%A6(PBE)/</id>
    <published>2022-07-17T03:17:56.000Z</published>
    <updated>2022-07-19T12:27:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>以单层黑磷为例记录一下用vasp使用PBE计算二维材料的方法</p><span id="more"></span><h2 id="预备工具">预备工具</h2><ol type="1"><li>装有Linux系统的的电脑（本文使用wsl2下的ubuntu1804版本，使用vscode编辑）</li><li>VASP 5.4.4</li><li>vaspkit 1.3.5</li></ol><h2 id="结构优化">结构优化</h2><p>这一步是为了得到原子的最优位置，所以POSCAR给的稍微有些偏差问题是不大的，因为后面VASP会优化。</p><p>新建文件夹<code>BP_1L</code>，在当前目录创建名为<code>opt</code>的文件夹。</p><h3 id="poscar">POSCAR</h3><p>POSCAR可以去下载cif通过VESTA转换，也可以通过MS或VESTA画出来</p><p>导入写好的POSCAR，这里为了实现单层y方向给了20埃的长度</p><figure class="highlight plaintext"><figcaption><span>POSCAR</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BP_1L</span><br><span class="line">1.0</span><br><span class="line">        3.3159999847         0.0000000000         0.0000000000</span><br><span class="line">        0.0000000000        20.0000000000         0.0000000000</span><br><span class="line">        0.0000000000         0.0000000000         4.3889999390</span><br><span class="line">    P</span><br><span class="line">    4</span><br><span class="line">Direct</span><br><span class="line">     0.809849977         0.456869990         0.580680013</span><br><span class="line">     0.809849977         0.559960008         0.400680006</span><br><span class="line">     0.309850007         0.559960008         0.080679998</span><br><span class="line">     0.309850007         0.456869990         0.900680006</span><br></pre></td></tr></table></figure><h3 id="incar">INCAR</h3><figure class="highlight plaintext"><figcaption><span>INCAR</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Global Parameters</span><br><span class="line">SYSTEM = BP_1L</span><br><span class="line">ISTART = 0</span><br><span class="line">ISPIN =  1</span><br><span class="line">ICHARG = 2 </span><br><span class="line">LWAVE  = .F.</span><br><span class="line">LCHARG = .F.</span><br><span class="line">ENCUT = 500</span><br><span class="line"># LORBIT = 11</span><br><span class="line"></span><br><span class="line"># Electronic Relaxation</span><br><span class="line">ISMEAR =  0</span><br><span class="line">SIGMA  =  0.05</span><br><span class="line">NELM =  300</span><br><span class="line">NELMIN =  6</span><br><span class="line">EDIFF = 1E-06</span><br><span class="line"></span><br><span class="line"># Ionic Relaxation</span><br><span class="line">NSW =  100</span><br><span class="line">IBRION =  2</span><br><span class="line">ISIF =  3</span><br><span class="line">EDIFFG = -1E-03</span><br><span class="line">ISYM =  0</span><br><span class="line">POTIM = 0.2</span><br></pre></td></tr></table></figure><h3 id="potcar和kpoint">POTCAR和KPOINT</h3><p>使用vaspkit生成</p><p>输入vaspkit</p><ol type="1"><li>选 1) VASP Input-Files Kit<br /></li><li>选 103) Generate POTCAR File with Default Setting</li></ol><p>即可生成POTCAR</p><p>输入vaspkit</p><ol type="1"><li>选 1) VASP Input-Files Kit<br /></li><li>选 102) Generate KPOINTS File for SCF Calculation</li><li>选 1) Monkhorst-Pack Scheme</li><li>输入0.01</li><li>在生成的KPOINTS中第四行修改为<code>14   1  10</code></li></ol><p>得到KPOINTS</p><h3 id="optcell">OPTCELL</h3><p>二维材料还需要一个optcell文件来让VASP不要优化真空层方向</p><p>里面写<code>101</code>即可，0表示不优化第二个方向</p><p>运行vasp</p><h2 id="自洽">自洽</h2><p>将上一步骤完成的文件复制一份并重命名为scf</p><p>在该目录下输入<code>cp CONTCAR POSCAR</code>将上一步优化好的结果赋给POSCAR</p><p>修改INCARD</p><figure class="highlight plaintext"><figcaption><span>INCAR</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Global Parameters</span><br><span class="line">SYSTEM = BP_1L</span><br><span class="line">ISTART = 0</span><br><span class="line">ISPIN =  1</span><br><span class="line">ICHARG = 2 </span><br><span class="line">LWAVE  = .T.</span><br><span class="line">LCHARG = .T.</span><br><span class="line">ENCUT = 500</span><br><span class="line">LORBIT = 11</span><br><span class="line"></span><br><span class="line"># Electronic Relaxation</span><br><span class="line">ISMEAR =  0</span><br><span class="line">SIGMA  =  0.05</span><br><span class="line">NELM =  300</span><br><span class="line">NELMIN =  6</span><br><span class="line">EDIFF = 1E-06</span><br><span class="line"></span><br><span class="line"># Ionic Relaxation</span><br><span class="line">NSW =  0</span><br><span class="line">IBRION =  -1</span><br><span class="line">ISIF =  3</span><br><span class="line">EDIFFG = -1E-03</span><br><span class="line">ISYM =  0</span><br><span class="line">POTIM = 0.2</span><br></pre></td></tr></table></figure><p>运行vasp</p><h2 id="能带计算">能带计算</h2><p>将文件复制到一个band文件夹，修改INCAR</p><figure class="highlight plaintext"><figcaption><span>INCAR</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Global Parameters</span><br><span class="line">SYSTEM = BP_1L</span><br><span class="line">ISTART = 1</span><br><span class="line">ISPIN =  1</span><br><span class="line">ICHARG = 11</span><br><span class="line">LWAVE  = .F.</span><br><span class="line">LCHARG = .F.</span><br><span class="line">ENCUT = 500</span><br><span class="line">LORBIT = 11</span><br><span class="line"></span><br><span class="line"># Electronic Relaxation</span><br><span class="line">ISMEAR =  0</span><br><span class="line">SIGMA  =  0.05</span><br><span class="line">NELM =  300</span><br><span class="line">NELMIN =  6</span><br><span class="line">EDIFF = 1E-06</span><br><span class="line"></span><br><span class="line"># Ionic Relaxation</span><br><span class="line">NSW =  0</span><br><span class="line">IBRION =  -1</span><br><span class="line">ISIF =  3</span><br><span class="line">EDIFFG = -1E-03</span><br><span class="line">ISYM =  0</span><br><span class="line">POTIM = 0.2</span><br></pre></td></tr></table></figure><p>使用vaspkit生成新的k路径</p><p>输入vaspkit</p><ol type="1"><li>选 3) K-Path for Band-Structure</li><li>选 302) 2D Structure</li><li><code>cp KPATH.in KPOINTS</code></li></ol><p>提交运行</p><p>输出文件中的DOSCAR内的费米能级是不准确的，所以这里进行一个修改，使用<code>grep fermi ../scf/OUTCAR</code>从自洽中找到准确的费米能级<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ISMEAR =     0;   SIGMA  =   0.05  broadening in eV -4-tet -1-fermi 0-gaus</span><br><span class="line"> E-fermi :  -1.8123     XC(G=0):  -3.0926     alpha+bet : -3.0343</span><br></pre></td></tr></table></figure> 我这里是-1.8123</p><p>将该数值复制到band文件夹下输出文件DOSCAR的第六行的第4个数，两个数的值一般会比较接近。</p><h2 id="参看数据及绘制能带图">参看数据及绘制能带图</h2><p>通过vaspkit计算能带</p><p>输入vaspkit</p><ol type="1"><li>选 21) Band-Structure</li><li>选 211) Band-Structure</li></ol><p>输出文件中有<code>BAND_GAP</code>可以看见 Band Gap (eV)</p><p>绘制能带图可以使用 python 的 pymatgen 或origin（把band.dat拖进去）</p><p>下面给出pymatgen的绘制能带图代码，代码节选自<ahref="http://blog.wangruixing.cn/2019/05/19/pymatgen-band/">刘锦城老师的文章</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from pymatgen.io.vasp.outputs import Vasprun</span><br><span class="line">from pymatgen.electronic_structure.plotter import BSDOSPlotter,BSPlotter,BSPlotterProjected,DosPlotter</span><br><span class="line"></span><br><span class="line">bs_vasprun = Vasprun(&quot;./vasprun.xml&quot;,parse_projected_eigen=True)</span><br><span class="line">bs_data = bs_vasprun.get_band_structure(line_mode=True)</span><br><span class="line"></span><br><span class="line">band_fig = BSPlotter(bs=bs_data)</span><br><span class="line">band_fig.get_plot()</span><br><span class="line">plt.savefig(&#x27;band_fig.png&#x27;, img_format=&#x27;png&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;以单层黑磷为例记录一下用vasp使用PBE计算二维材料的方法&lt;/p&gt;</summary>
    
    
    
    <category term="科研项目" scheme="https://splendidwave.github.io/categories/%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="黑磷的拉曼光谱" scheme="https://splendidwave.github.io/categories/%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE/%E9%BB%91%E7%A3%B7%E7%9A%84%E6%8B%89%E6%9B%BC%E5%85%89%E8%B0%B1/"/>
    
    
    <category term="固体物理" scheme="https://splendidwave.github.io/tags/%E5%9B%BA%E4%BD%93%E7%89%A9%E7%90%86/"/>
    
    <category term="VASP" scheme="https://splendidwave.github.io/tags/VASP/"/>
    
  </entry>
  
  <entry>
    <title>VASP输入文件INCAR速查</title>
    <link href="https://splendidwave.github.io/2022/07/17/2022-7/VASP%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6INCAR%E9%80%9F%E6%9F%A5/"/>
    <id>https://splendidwave.github.io/2022/07/17/2022-7/VASP%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6INCAR%E9%80%9F%E6%9F%A5/</id>
    <published>2022-07-17T02:12:10.000Z</published>
    <updated>2022-07-21T07:07:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>VASP一共有4个输入文件，分别为：POSCAR、INCAR、KPOINTS和POTCAR。其中POSCAR为结构文件，KPOINTS为K点文件，POTCAR是赝势文件。<strong>而INCAR决定了做什么计算以及如何做此次计算。</strong></p><blockquote><p>查询参数功能, 输入网站 + <em>参数名</em>https://www.vasp.at/wiki/index.php/ + <em>参数名</em></p></blockquote><span id="more"></span><p>下面按第一性原理计算的一般步骤（结构优化、自洽计算、非自洽计算）展示INCAR参数应该如何设置。等于号(=)后面为在该步骤的推荐设置。</p><h1 id="结构优化-opt">结构优化 OPT</h1><p>主要用来计算体系结构，原子位置。</p><h2 id="基础设置">基础设置</h2><p><strong>1、ISTART</strong></p><p><strong>控制如何生成初始波函数</strong></p><ul><li>0：随机生成波函数</li><li>1 : 从WAVECAR中读取波函数，当读取失败时，会随机生成</li></ul><p>= 0</p><p><strong>2、ISPIN</strong></p><p><strong>是否打开自旋</strong></p><ul><li>1: 非自旋极化计算</li><li>2: 打开自旋极化计算</li></ul><p>=2</p><p><strong>3、 ICHAGE</strong></p><p><strong>控制如何生成初始电荷密度</strong></p><ul><li>0：读取WAVECAR生成电荷密度，当读取失败时，通过原子电荷密度叠加生成初始电荷密度</li><li>1：从CHGCAR中的设定读取电荷密度</li><li>2：通过原子电荷密度的叠加方法，生成初始的猜测电荷密度</li><li>11：从CHGCAR读取电荷密度，且在自洽循环中保持不变，适用于非自洽循环计算，如电子态密度的计算</li></ul><p>=2</p><p><strong>4、 LWAVE/LCHARG</strong></p><p><strong>控制是否输出波函数(WAVECAR)和电荷密度(CHGCAR)</strong></p><ul><li>.T.: 写波函数和电荷密度</li><li>.F.: 不写波函数和电荷密度</li></ul><p>=.F.</p><h2 id="计算精度设置">计算精度设置</h2><p><strong>1、ENCUT</strong></p><p><strong>平面波截断能，控制用多少平面波展开波函数</strong></p><p>推荐设置为POTCAR（赝势文件）中参数ENMAX值的1.0-1.3倍，从而兼顾计算的精度与效率。</p><p>=500</p><p><strong>2、PREC</strong></p><p><strong>总体计算精度控制</strong></p><ul><li>Accurate: 准确</li><li>Normal: 一般</li></ul><p>默认为Normal</p><p>= Accurate</p><p><strong>3、ADDGRID</strong></p><p><strong>是否开启网格</strong></p><ul><li>.TRUE. : 开启</li><li>.FALSE. : 关闭</li></ul><p>=.TRUE.</p><p><strong>4、NPAR</strong></p><p><strong>核数</strong></p><p>别写,用默认的就行</p><p><strong>3、LORBIT</strong></p><p><strong>总态密度投影</strong></p><p>11: 每一个原子对应的轨道的贡献输出到OUTCAR里</p><p>=11</p><h2 id="宏观设置">宏观设置</h2><p><strong>1、ISMEAR</strong></p><p><strong>设置展宽方法，决定如何进行电子轨道分数占据</strong></p><ul><li>0: Gaussian smearing</li><li>−1: Fermi smearing</li></ul><p>金属可以设置为1</p><p>=0</p><p><strong>2、SIGMA</strong></p><p><strong>展宽的宽度，与ISMEAR联用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">半导体 设置为 0.05</span><br><span class="line">金属 设置为 0.02</span><br><span class="line"></span><br><span class="line">小 -&gt; 大</span><br><span class="line">态密度平滑 -&gt; 态密度尖锐</span><br></pre></td></tr></table></figure><p>单位为eV，默认值为0.2</p><p>=0.05</p><p><strong>3、NELM</strong></p><p><strong>自洽迭代循环的最大次数</strong></p><p>一般在150-300</p><p>=300</p><p><strong>4、NELMIN</strong></p><p><strong>自洽迭代循环的最小次数</strong></p><p>一般在4-6</p><p>=6</p><p><strong>5、EDIFF</strong></p><p><strong>自洽迭代循环收敛标准，单位为eV</strong></p><p>一般在1E-05 - 1E-06</p><p>= 1E-06</p><h2 id="离子弛豫相关设置">离子弛豫相关设置</h2><p><strong>1、NSW</strong></p><p><strong>最大步数</strong></p><p>=100</p><p><strong>2、IBRION</strong></p><p><strong>离子步弛豫（离子位置优化）算法</strong> * 0：分子动力学模拟 *1：准牛顿法 * 2：共轭梯度法 * 5：振动频率计算 * 6：弹性常数计算</p><p>=2</p><p><strong>3、ISIF</strong></p><p><strong>离子步弛豫控制</strong></p><ul><li>2： 晶胞大小不变，原子位置动</li><li>3： 晶胞大小改变，原子位置动，晶胞体积变</li><li>4： 晶胞大小改变，原子位置动，晶胞体积不变（多用于一二维体系）</li></ul><p>=4</p><p><strong>4、EDIFFG</strong></p><p><strong>离子弛豫中断</strong></p><p>=-1E-03</p><p><strong>5、ISYM</strong></p><p><strong>对称</strong></p><ul><li>0: 不打开对称</li><li>2: 打开对称</li></ul><p>=0</p><p><strong>6、MAGMOM</strong></p><p><strong>对于磁性材料，设置初始原子磁矩</strong>默认值是每个原子的磁矩均为1对于含有d、f轨道的原子，需根据原子核外电子排布情况设置相应的数值可以设置每个原子初始磁矩方向，正值为自旋向上，负值为自旋向下。</p><p>根据POSCAR修改</p><p><strong>7、IVDW</strong></p><p><strong>范德华力计算方法，在DFT能量计算基础上增加范德华力修正</strong>* 10：DFT-D2方法 * 11：DFT-D3方法</p><p>=11</p><h2 id="参数汇总">参数汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ISTART = 0 </span><br><span class="line">ISPIN =  2 </span><br><span class="line">ICHARG = 2 </span><br><span class="line">LWAVE  = .F.</span><br><span class="line">LCHARG = .F.</span><br><span class="line">ENCUT = 500</span><br><span class="line"># PREC =  Accurate        (Precision level)   Normal / Accurate</span><br><span class="line"># ADDGRID = .TRUE.        (Increase grid; helps GGA convergence) </span><br><span class="line"># NPAR = 4 </span><br><span class="line">LORBIT = 11</span><br><span class="line"></span><br><span class="line">ISMEAR =  0</span><br><span class="line">SIGMA  =  0.05</span><br><span class="line">NELM =  300</span><br><span class="line">NELMIN =  6</span><br><span class="line">EDIFF = 1E-06</span><br><span class="line"></span><br><span class="line">NSW =  100</span><br><span class="line">IBRION=  2</span><br><span class="line">ISIF =  4</span><br><span class="line">EDIFFG = -1E-03</span><br><span class="line">ISYM =  0</span><br><span class="line">POTIM = 0.2</span><br><span class="line">IVDW = 11</span><br></pre></td></tr></table></figure><h1 id="自洽-scf">自洽 SCF</h1><p>电荷密度 波函数</p><p>参数基本与上一步骤相同</p><p><strong>1、NEDOS</strong></p><p><strong>态密度数据点个数</strong> 通常设置1000-3000</p><p>=3001</p><p><strong>2、NSW</strong></p><p>cp CONTCAR POSCAR</p><p>不做结构优化</p><p>= 0</p><h2 id="参数汇总-1">参数汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Global Parameters</span><br><span class="line">ISTART = 0</span><br><span class="line">ISPIN =  2</span><br><span class="line">ICHARG = 2</span><br><span class="line">ENCUT  =  500</span><br><span class="line">PREC =  Accurate</span><br><span class="line">EDIFF  = 1E-08 </span><br><span class="line">ADDGRID = .TRUE. </span><br><span class="line">LWAVE  = .T.        </span><br><span class="line">LCHARG = .T.</span><br><span class="line"># NPAR = 4</span><br><span class="line">LORBIT = 11</span><br><span class="line">NEDOS = 3001</span><br><span class="line"> </span><br><span class="line">ISMEAR =  0 </span><br><span class="line">SIGMA  =  0.05</span><br><span class="line">NELM =  300</span><br><span class="line">NELMIN =  6</span><br><span class="line"> </span><br><span class="line">NSW =  0</span><br><span class="line">IBRION =  -1</span><br><span class="line"># ISIF   =  3</span><br><span class="line"># EDIFFG = -1E-03</span><br><span class="line">ISYM =  0</span><br><span class="line">POTIM = 0.2</span><br><span class="line"> </span><br><span class="line"># LSORBIT = .TRUE.    (Activate SOC)</span><br><span class="line"># GGA_COMPAT = .FALSE.   (Apply spherical cutoff on gradient field)</span><br><span class="line"># LMAXMIX =  4        (For d elements increase LMAXMIX to 4, f: LMAXMIX = 6)</span><br><span class="line"># SAXIS =  0 0 1    (Direction of the magnetic field)</span><br><span class="line"> </span><br><span class="line">IVDW = 11</span><br></pre></td></tr></table></figure><h1 id="非自恰运算-nscf">非自恰运算 NSCF</h1><p>band dos 磁矩</p><h2 id="能带结构运算">能带结构运算</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ISTART = 1</span><br><span class="line">ISPIN =  2</span><br><span class="line">ICHARG = 11</span><br><span class="line">ENCUT  =  500</span><br><span class="line">PREC = Accurate</span><br><span class="line">EDIFF  = 1E-08</span><br><span class="line">ADDGRID= .TRUE.</span><br><span class="line">LWAVE  = .F.</span><br><span class="line">LCHARG = .F.</span><br><span class="line">LORBIT = 11</span><br><span class="line"> </span><br><span class="line">ISMEAR =  0</span><br><span class="line">SIGMA  =  0.02</span><br><span class="line">NELM   =  300</span><br><span class="line">NELMIN =  6</span><br><span class="line"> </span><br><span class="line">NSW    =  0</span><br><span class="line">IBRION =  -1</span><br><span class="line"># ISIF   =  3</span><br><span class="line"># EDIFFG = -1E-03        (Ionic convergence; eV/AA)</span><br><span class="line">ISYM =  0</span><br><span class="line">POTIM = 0.2</span><br><span class="line"></span><br><span class="line">IVDW = 11   ##vdw forces</span><br></pre></td></tr></table></figure><h1 id="参考资料">参考资料</h1><p>[1] 知乎文章 <ahref="https://zhuanlan.zhihu.com/p/151725218">VASP软件INCAR文件参数含义速查表</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;VASP一共有4个输入文件，分别为：POSCAR、INCAR、KPOINTS和POTCAR。其中POSCAR为结构文件，KPOINTS为K点文件，POTCAR是赝势文件。&lt;strong&gt;而INCAR决定了做什么计算以及如何做此次计算。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查询参数功能, 输入网站 + &lt;em&gt;参数名&lt;/em&gt;
https://www.vasp.at/wiki/index.php/ + &lt;em&gt;参数名&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="物理" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%A9%E7%90%86/"/>
    
    
    <category term="VASP" scheme="https://splendidwave.github.io/tags/VASP/"/>
    
  </entry>
  
  <entry>
    <title>密度泛函理论-Hatree-Fock方法</title>
    <link href="https://splendidwave.github.io/2022/06/13/2022-6/%E5%AF%86%E5%BA%A6%E6%B3%9B%E5%87%BD%E7%90%86%E8%AE%BA_Hatree_Fock%E6%96%B9%E6%B3%95/"/>
    <id>https://splendidwave.github.io/2022/06/13/2022-6/%E5%AF%86%E5%BA%A6%E6%B3%9B%E5%87%BD%E7%90%86%E8%AE%BA_Hatree_Fock%E6%96%B9%E6%B3%95/</id>
    <published>2022-06-13T11:42:50.000Z</published>
    <updated>2022-06-14T05:38:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>Hatree-Fock方法的导出</p><span id="more"></span><h2 id="薛定谔方程">1. 薛定谔方程</h2><p>量子力学这门课其实就干了一件事情--解薛定谔方程。</p><p>通过求解薛定谔方程我们就可以知道微观粒子的运动，起码是运动概率。就相当于我们求解牛顿方程就可以在经典世界得到物体的运动规律。</p><p>下面简单复习下薛定谔方程的推导。</p><p>按照德布罗意物质波理论，粒子可以写成波函数的形式，简化起见，先来看一个能量为E动量为p自由粒子，按照德布罗意关系，角频率<spanclass="math inline">\(\omega\)</span>和波矢<spanclass="math inline">\(\boldsymbol{k}\)</span>由下式给出</p><p><span class="math display">\[\omega=E / \hbar, \quad \boldsymbol{k}=\boldsymbol{p} / \hbar\]</span></p><p>我们先看一个简单的平面单色波，因为复杂的波函数也是许多平面波的叠加,作为一个线性系统其结果应该满足和单色波结果一致。</p><p><span class="math display">\[\begin{align}\psi (\mathbf{r},t ) &amp; = exp[i(\mathbf{k\cdot r} -\omegat)]\nonumber\\&amp;= exp[i(\mathbf{p \cdot r}-Et )/\hbar ]\nonumber\end{align}\tag{1}\]</span></p><p>将上式分别对时间和空间求导有</p><p><span class="math display">\[i\hbar \frac{\partial }{\partial t} \psi = E \psi  \tag{2}\]</span></p><p><span class="math display">\[-i\hbar \nabla  \psi = \mathbf{p}  \psi \tag{3}\]</span></p><p><span class="math display">\[-\hbar ^2 \nabla ^2 \psi = \mathbf{p}^2  \psi \tag{4}\]</span></p><p>对自由粒子来说<spanclass="math inline">\(E=\frac{1}{2}mc^2=\mathbf{p}^2/2m\)</span>再结合式(2)(3)所以有 <span class="math display">\[i\hbar \frac{\partial }{\partial t} \psi = -\frac{\hbar ^2 \nabla^2}{2m} \psi \tag{5}\]</span></p><p>如果加上势场，能量为<spanclass="math inline">\(E=\mathbf{p}^2/2m+V\)</span>就可以得到薛定谔提出的薛定谔方程<span class="math display">\[i \hbar \frac{\partial }{\partial t}\psi(\mathbf{r},t)=\left[-\frac{\hbar^{2}}{2 m} \nabla^{2}+V\right] \psi(\mathbf{r},t)\tag{6}\]</span></p><h2 id="多粒子系统的简化">2. 多粒子系统的简化</h2><p>薛定谔方程确实很好用，但人类是有极限的。只有少数体系能求解出解析解，就算是数值解，目前计算机也无法实现计算。</p><p>究其原因，作为一个多粒子体系，电子和电子之间，电子和原子核之间，原子核和原子核之间都存在相互作用，又两者又分别有动能和势能。哈密顿量写出来就是老长一串。看着就头大，根本不好计算。</p><p>为此物理学家得先进行<del>偷懒</del>化简。</p><h3 id="玻恩-奥本海默近似bo近似">2.1 玻恩-奥本海默近似（BO近似）</h3><p>由于原子核比电子重得多，电子运动速度比核快得多，因此我们可以假设电子运动时，原子核是固定的，从而将核与电子的运动分开考虑。多粒子系统的哈密顿量可以写为<span class="math display">\[\hat{H} = \hat{T} + \hat{V}_{ne}+\hat{V}_{ee}  \tag{7}\]</span>第一项为电子的动能，下标ne和ee分别表示核-电子核电子-电子相互作用。这样波函数就简化了不少。</p><h3 id="hatree近似">2.2 Hatree近似</h3><p>上面的多粒子体系的哈密顿量最复杂的项是第三项，电子间的相互作用。正是因为有了这一项，我们不能把方程分离成一系列独立的单粒子方程。</p><p>起初哈特里将电子对某一电子i的库伦作用用平均场方法来处理，即用平均场代替电子与电子间的相互作用。这样式(7)第三项可以和第二项合并其薛定谔方程和单粒子薛定谔方程一致，大大简化了计算。</p><p>同时Hatree提出电子系统的波函数可以看作多个单电子波函数的连续乘积。并且其中涉及到单电子波函数全用迭代自洽的方法解决，所以被叫做自洽场方法(SCF)。</p><p>该方法在概率论方面也容易理解，相当于把电子的出现概率看作是独立的事件。</p><h3 id="斯莱特行列式slater行列式">2.3 斯莱特行列式（Slater行列式）</h3><p>哈特里的方法简单但是缺乏准确性。多电子体系是全同的费米子体系，量子力学要求其波函数具有交换反对称性，即如果两电子交换坐标，波函数应该反号。下面以氦原子为例给出推导证明。</p><p>氦原子是双电子体系，其哈密顿量为</p><p><span class="math display">\[H = \mathbf{p}_1^2/2m +  \mathbf{p}_2^2/2m-\frac{2e^2}{r_1}-\frac{2e^2}{r_2} +\frac{e^2}{\left | \mathbf{r_1} -\mathbf{r_2}  \right| } \tag{8}\]</span></p><p>易得当两个电子交换时，哈密顿量不变，可见哈密顿量算符和交换算符具有对易关系：</p><p><span class="math display">\[[H,P_{12}] = 0 \tag{9}\]</span></p><p>所以将交换算符作用在电子波函数<spanclass="math inline">\(\psi\)</span>上有</p><p><span class="math display">\[P_{12} \psi = \lambda \psi \tag{10}\]</span></p><p>再作用一次有</p><p><span class="math display">\[P^2_{12} \psi = \lambda^2 \psi \tag{11}\]</span></p><p>对易算符作用两次等于本身，所以有<spanclass="math inline">\(\lambda=\pm 1\)</span></p><p>这表明两个粒子进行交换，波函数必须是对称或者是反对称的。恰巧实验证明，交换对称的粒子符合Bose统计，所以称为玻色子，反对称的粒子符合fermi统计，所以称为费米子。</p><p>对于费米子（如电子，质子，中子，这里是氦的两个电子）归一化对称波函数可以构建如下</p><p><span class="math display">\[\begin{align}\psi ^A_{k_1k_2}(q_1,q_2) &amp; =\frac{1}{\sqrt[]{2}}(1-P_{12})\varphi_{k_1}(q_1)\varphi_{k_2}(q_2)\nonumber\\&amp;=\frac{1}{\sqrt[]{2}}[\varphi_{k_1}(q_1)\varphi_{k_2}(q_2)-\varphi_{k_1}(q_2)\varphi_{k_2}(q_1)]\nonumber\\&amp;= \frac{1}{\sqrt{2}} \begin{vmatrix}\varphi_{k_1}(q_1) &amp; \varphi_{k_2}(q_1)\\\varphi_{k_1}(q_2) &amp; \varphi_{k_2}(q_2)\end{vmatrix}\nonumber\end{align}\tag{12}\]</span></p><p>可以看出利用行列式的方法很好的处理了反对称问题，一旦两个电子交换坐标，相当于行列式的交换了两行，行列式的值取个负号。如果有两个电子坐标相同，行列式值为0，表明状态不存在，这就是泡利不相容原理。（不能有两个全同费米子处于同一个单粒子态）</p><p>将这个行列式推广到N个粒子就是斯莱特行列式</p><p><span class="math display">\[\psi=\frac{1}{\sqrt{N !}}\left|\begin{array}{cccc}\varphi_{1}\left(q_{1}\right) &amp; \varphi_{2}\left(q_{1}\right) &amp;\ldots &amp; \varphi_{N}\left(q_{1}\right) \\\varphi_{1}\left(q_{2}\right) &amp; \varphi_{2}\left(q_{2}\right) &amp;\ldots &amp; \varphi_{N}\left(q_{2}\right) \\\ldots &amp; \ldots &amp; \ldots &amp; \ldots \\\varphi_{1}\left(q_{N}\right) &amp; \varphi_{2}\left(q_{N}\right) &amp;\ldots &amp; \varphi_{N}\left(q_{N}\right)\end{array}\right|\tag{13}\]</span></p><h3 id="hatree-fork方法">2.4 Hatree-Fork方法</h3><p>针对Hatree近似的不准确性，福克就采用了斯莱特行列式来表示整个电子体系的波函数。这和Hatree近似一样，将多粒子体系变成了单电子系统。</p><p>下面给出哈特里-福克方程的推导。</p><p>首先能量E的平均值<span class="math inline">\(\left \langle E \right\rangle\)</span>计算公式如下 <span class="math display">\[E = \left \langle E \right \rangle =\int \psi  ^* \hat{H} \psi d \tau=   \left \langle \psi \left | \hat{H} \right | \psi  \right \rangle\tag{14}\]</span></p><p>其中波函数<spanclass="math inline">\(\psi\)</span>可以用斯莱特行列式表示，哈密顿量与式(7)相同，对于有N个电子和M个核的系统展开为</p><p><span class="math display">\[\hat{H} = -\sum_{i=1}^{N}  \frac{1}{2} \nabla ^2_i - \sum_{i=1}^{N}\sum_{A=1}^{M} \frac{Z_A}{ r_{iA} }+\sum_{i=1}^{N} \sum_{j&gt;i}^{N}\frac{1}{ r_{ij} } \tag{15}\]</span></p><p>其中<spanclass="math inline">\(\nabla\)</span>是拉普拉斯算符，r为粒子间的距离。</p><p>将式(13)(15)代入(14)就可以得到N电子系统的能量<spanclass="math inline">\(E_{HF}\)</span></p><p>为了有更直观的体验，我们还是以二电子系统为例推导一下。</p><p><span class="math display">\[E=\left\langle\psi\left|H_{1}\right|\psi\right\rangle+\left\langle\psi\left|H_{2}\right|\psi\right\rangle+\left\langle\psi\left|H_{12}\right| \psi\right\rangle\tag{16}\]</span></p><p>前两项分别是单电子的哈密顿量，即包含单电子的动能和势能的哈密顿量。最后一项代表了两个电子相互作用项，展开如下：</p><p><span class="math display">\[\begin{align}\left\langle\psi\left|H_{12}\right| \psi\right\rangle &amp; = \iint dr_{1} d r _{2} \frac{1}{\sqrt{2}}\left[\varphi_{1}^{*}\left(q_{1}\right)\varphi_{2}^{*}\left(q_{2}\right)-\varphi_{1}^{*}\left(q_{2}\right)\varphi_{2}^{*}\left(q_{1}\right)\right]\nonumber\\&amp;\frac{1}{r_{12}}\frac{1}{\sqrt{2}}\left[\varphi_{1}\left(q_{1}\right)\varphi_{2}\left(q_{2}\right)-\varphi_{1}\left(q_{2}\right)\varphi_{2}\left(q_{1}\right)\right] \nonumber\\&amp; = \iint d r_{1} d r _{2} \frac{1}{2}[ \frac{\left |\varphi_{1}(q_1) \right |^2\left|\varphi_{2}\left(q_{2}\right)\right|^{2}+\left|\varphi_{2}\left(q_{1}\right)\right|^{2}\left|\varphi_{1}\left(q_{2}\right)\right|^{2}}{r_{12}}\nonumber\\&amp; - \frac{\varphi_{1}^{*}\left(q_{1}\right)\varphi_{2}^{*}\left(q_{2}\right)\varphi_{1}\left(q_{2}\right)\varphi_{2}\left(q_{1}\right) +\varphi_{1}^{*}\left(q_{2}\right)\varphi_{2}^{*}\left(q_{1}\right)\varphi_{1}\left(q_{1}\right)  \varphi_{2}\left(q_{2}\right)  }{r_{12}}]\nonumber\end{align} \tag{17}\]</span></p><p>推广到N电子系统</p><p><span class="math display">\[H_{HF} = \left \langle \psi \left | \hat{H}  \right | \psi  \right\rangle = \sum _{i=1}^{N} H_i + \frac{1}{2}\sum_{i,j=1}^{N}(J_{ij}-K_{ij}) \tag{18}\]</span> 其中</p><p><span class="math display">\[\begin{array}{c}H_{i}=\int \varphi_{i}^{*}\left(q_{i}\right)\left(-\frac{1}{2}\nabla_{i}^{2}- \sum _{A=1}^{M} Z_{A} / r_{i A}\right)\varphi_{i}\left(q_{i}\right) \mathrm{d} r_{i} \\J_{i j}=\iint \varphi_{i}\left(q_{1}\right)\varphi_{i}^{*}\left(q_{1}\right)\left(1 / r_{12}\right)\varphi_{j}^{*}\left(q_{2}\right) \varphi_{j}\left(q_{2}\right)\mathrm{d} r_{1} \mathrm{~d} r_{2} \\K_{i j}=\iint \varphi_{i}^{*}\left(q_{1}\right)\varphi_{j}^{*}\left(q_{2}\right)\left(1 / r_{12}\right)\varphi_{i}\left(q_{2}\right) \varphi_{j}\left(q_{1}\right) \mathrm{d}r_{1} \mathrm{~d} r_{2}\end{array}\]</span></p><p>当i，j相同时，J和K也相同。我们将J称为<strong>库伦积分</strong>，将K称为<strong>交换积分</strong>，它们都属于电子-电子间相互作用。</p><p>波函数有正交归一条件限制，所以需要利用拉格朗日未定乘数法构建泛函如下：</p><p><span class="math display">\[W = E +\sum_{i} \varepsilon _i \left ( \int d r \varphi_{i}^{*}\varphi_{i} - 1 \right )\tag{19}\]</span></p><p>还是以双电子系统为例，对其取变分有：</p><p><span class="math display">\[\begin{align}\delta E &amp; = \sum _{i} \int \delta\varphi_{i}^{*}\left(r\right)\left(-\frac{1}{2} \nabla_{i}^{2}- \sum _{A= 1}^{M} Z_{A} / r_{i A}\right) \varphi_{i}\left(r\right) \mathrm{d}r_{i}\nonumber \\&amp; +\sum_{ij} \iint \delta \varphi_{i}^{*}\left(r\right)\varphi_{i}\left(r\right) \left(1 / r_{12}\right)\varphi_{j}^{*}\left(r^{\prime}\right)\varphi_{j}\left(r^{\prime}\right) \mathrm{d} r_{1} \mathrm{~d} r_{2}\nonumber \\&amp; - \sum_{ij} \iint \delta \varphi_{i}^{*}\left(r\right)\varphi_{j}^{*}\left(r^{\prime}\right)\left(1 / r_{12}\right)\varphi_{i}\left(r^{\prime}\right) \varphi_{j}\left(r\right) \mathrm{d}r_{1} \mathrm{~d} r_{2} \nonumber\end{align} \tag{20}\]</span></p><p>后面一项</p><p><span class="math display">\[\delta \sum_{i} \varepsilon _i \left ( \int d r \varphi_{i}^{*}\varphi_{i} - 1 \right ) = \sum_{i} \int dr \delta \varphi_{i}^{*}\varepsilon _i \varphi_{i} \tag{21}\]</span></p><p>两式相加后提取公因式。</p><p><span class="math display">\[\begin{align}\sum_{i} \int d r \delta \varphi_{i}^{*} [H_{i}\varphi_{i}(r)+\sum_{j(\neq i)} \int d r^{\prime}\frac{\left|\varphi_{j}\left(r^{\prime}\right)\right|^{2}}{\left|r-r^{\prime}\right|}\varphi_{i}(r)\nonumber\\-\sum_{j(\neq i)} \int d r^{\prime}\frac{\varphi_{j}^{*}\left(r^{\prime}\right)\varphi_{i}\left(r^{\prime}\right)}{\left|r-r^{\prime}\right|}\varphi_{j}(r)-\varepsilon_{i} \varphi_{i}(r)] = 0\nonumber\end{align}\tag{22}\]</span></p><p>变分为零即要求括号内的部分为零 <span class="math display">\[H_{i} \varphi_{i}+\sum_{j(\neq i)} \int d r^{\prime}\frac{\left|\varphi_{j}\left(r^{\prime}\right)\right|^{2}}{\left|r-r^{\prime}\right|}\varphi_{i}-\sum_{j(\neq i)} \int d r^{\prime}\frac{\varphi_{j}^{*}\left(r^{\prime}\right)\varphi_{i}\left(r^{\prime}\right)}{\left|r-r^{\prime}\right|}\varphi_{j}=\varepsilon_{i} \varphi_{i} \tag{23}\]</span></p><p>该式即为单电子波函数<spanclass="math inline">\(\psi\)</span>的Hatree-Fork方程，简记为</p><p><span class="math display">\[\hat{F}_i \psi(q_i) = \varepsilon _i \psi(q_i)\tag{24}\]</span></p><p>其中<spanclass="math inline">\(\hat{F}_i\)</span>被称为福克算符，表示单电子的哈密顿量算符。</p><h2 id="参考资料">参考资料</h2><p>[1] 量子力学 曾谨言</p><p>[2] 知乎文章 <ahref="https://zhuanlan.zhihu.com/p/40527652">密度泛函理论简介：A briefsummary</a></p><p>[3] 知乎文章 <ahref="https://zhuanlan.zhihu.com/p/487866148">固体物理：4.0 能带论波恩奥本海默近似 Hatree-Fock近似 单电子近似</a></p><p>[4] 密度泛函理论 胡英 刘洪来</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;Hatree-Fock方法的导出&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="物理" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%A9%E7%90%86/"/>
    
    
    <category term="能带" scheme="https://splendidwave.github.io/tags/%E8%83%BD%E5%B8%A6/"/>
    
    <category term="密度泛函理论" scheme="https://splendidwave.github.io/tags/%E5%AF%86%E5%BA%A6%E6%B3%9B%E5%87%BD%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统命令(备忘录)</title>
    <link href="https://splendidwave.github.io/2022/06/13/2022-6/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4(%E5%A4%87%E5%BF%98%E5%BD%95)/"/>
    <id>https://splendidwave.github.io/2022/06/13/2022-6/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4(%E5%A4%87%E5%BF%98%E5%BD%95)/</id>
    <published>2022-06-13T11:40:29.000Z</published>
    <updated>2022-10-06T07:57:57.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>Linux系统命令备忘录</p><span id="more"></span><h2 id="正文">正文</h2><h3 id="展示目录内容">1. 展示目录内容</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -a：显示所有文件（包括隐藏文件）；</span><br><span class="line">Linux中以.开头的文件是隐藏文件；</span><br><span class="line">ls -l：显示详细信息；</span><br><span class="line">ls -R：递归显示子目录结构；</span><br><span class="line">pwd:显示当前目录</span><br></pre></td></tr></table></figure><h3 id="创建工作区和虚拟环境">2. 创建工作区和虚拟环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export MY_PATH=&quot;$HOME/ml&quot; </span><br></pre></td></tr></table></figure><p>将路径HOME/ml取名为MY_PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p MY_PATH</span><br></pre></td></tr></table></figure><p>建立多级文件目录，当前目录下创建可以不加p</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --user --upgrade virtualenv</span><br></pre></td></tr></table></figure><p>安装虚拟环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv env --python=3.6</span><br></pre></td></tr></table></figure><p>在当前目录下创建虚拟环境名字为env,python版本为3.6</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source env/bin/activate</span><br></pre></td></tr></table></figure><p>启动虚拟环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><p>退出虚拟环境</p><h3 id="创建编辑文本">3. 创建编辑文本</h3><h4 id="文件夹与文件">3.1 文件夹与文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir 文件夹名称：创建文件夹；</span><br><span class="line">rmdir 文件夹名称：删除文件；</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch 文件名：创建文件（要加后缀）</span><br><span class="line">rm 文件名：删除文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv a.txt b.txt ：重命名</span><br><span class="line">mv a.txt ../ ：移动到上层</span><br><span class="line">cp 源文件路径  目标文件路径：复制到 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim 文件名：如果目标文件存在，则vim打开目标文件，如果目标文件不存在，则vim新建并打开该文件。</span><br></pre></td></tr></table></figure><h4 id="vim模式">3.2 VIM模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vim拥有三种模式</span><br><span class="line">（1）命令模式（常规模式）</span><br><span class="line">vim启动后，默认进入命令模式，任何模式都可以通过esc键回到命令模式（可以多按几次），命令模式下可以键入不同的命令完成选择、复制、粘贴、撤销等操作。</span><br><span class="line">命名模式常用命令如下：</span><br><span class="line">i : 在光标前插入文本；</span><br><span class="line">o:在当前行的下面插入新行；</span><br><span class="line">dd:删除整行；</span><br><span class="line">yy：将当前行的内容放入缓冲区（复制当前行）</span><br><span class="line">n+yy :将n行的内容放入缓冲区（复制n行）</span><br><span class="line">p:将缓冲区中的文本放入光标后（粘贴）</span><br><span class="line">u：撤销上一个操作</span><br><span class="line">r:替换当前字符</span><br><span class="line">/ 查找关键字</span><br><span class="line"></span><br><span class="line">（2）插入模式</span><br><span class="line">在命令模式下按 &quot; i &quot;键，即可进入插入模式，在插入模式可以输入编辑文本内容，使用esc键可以返回命令模式。</span><br><span class="line"></span><br><span class="line">（3）底部输入模式</span><br><span class="line">在命令模式中按&quot; : &quot;键可以进入底部输入模式，光标会移动到底部。</span><br><span class="line">底部输入模式常用命令如下：</span><br><span class="line">:w          ：保存当前的修改</span><br><span class="line">:q          ：退出</span><br><span class="line">:q!         ：强制退出，保存修改</span><br><span class="line">:x          : 保存并退出，相当于:wq</span><br><span class="line">:set number : 显示行号</span><br><span class="line">:!          : 系统命令  执行一个系统命令并显示结果</span><br><span class="line">:sh         ：切换到命令行，使用ctrl+d切换回vim</span><br></pre></td></tr></table></figure><h3 id="wsl-ubuntu相关">4. WSL ubuntu相关</h3><h4 id="文件管理">4.1 文件管理</h4><p>如果使用的是WSL，文件位置可以在资源管理器中输入<code>\\wsl$</code>获知。</p><h4 id="重置密码">4.2 重置密码</h4><ol type="1"><li>关闭Ubuntu窗口</li><li>打开Powershell 或 cmd， 以root默认登陆<code>wsl -u root</code>。</li><li>输入 <code>passwd your_username</code></li><li>重新修改并确认密码。</li><li>exit退出</li><li>重启Ubuntu窗口</li></ol><h2 id="参考资料">参考资料</h2><p>[1] <ahref="https://blog.csdn.net/l1028386804/article/details/117917710">全网最全Linux命令总结！！（史上最全，建议收藏）</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;Linux系统命令备忘录&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="备忘录" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
    <category term="Linux" scheme="https://splendidwave.github.io/tags/Linux/"/>
    
    <category term="备忘录" scheme="https://splendidwave.github.io/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Anacodna3命令(备忘录)</title>
    <link href="https://splendidwave.github.io/2022/06/13/2022-6/anacodna3%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>https://splendidwave.github.io/2022/06/13/2022-6/anacodna3%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98%E5%BD%95/</id>
    <published>2022-06-13T11:36:29.000Z</published>
    <updated>2022-10-06T10:33:29.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>Anacodna3常用命令备忘录</p><span id="more"></span><h2 id="正文">正文</h2><p>下列命令在Anacodna Promopt或Anacodna PowershellPromopt或Linux系统下输入</p><h3 id="创建环境">1. 创建环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n envname python=3.9</span><br></pre></td></tr></table></figure><p>其中envname代表环境名</p><h3 id="进入虚拟环境">2. 进入虚拟环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate envname</span><br></pre></td></tr></table></figure><h3 id="退出环境">3. 退出环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><h3 id="删除环境">4. 删除环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n envname --all</span><br></pre></td></tr></table></figure><h3 id="查看所有环境">5. 查看所有环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure><h3 id="查看conda版本">6. 查看conda版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure><h3 id="更新conda">7. 更新conda</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update conda </span><br></pre></td></tr></table></figure><h3 id="备份旧环境">8. 备份旧环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name new_env_name --clone old_env_name</span><br></pre></td></tr></table></figure><h3 id="查看当前环境安装的包">9. 查看当前环境安装的包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;Anacodna3常用命令备忘录&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="备忘录" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
    <category term="备忘录" scheme="https://splendidwave.github.io/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>英语六级作文</title>
    <link href="https://splendidwave.github.io/2022/06/02/2022-6/%E8%8B%B1%E8%AF%AD%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/"/>
    <id>https://splendidwave.github.io/2022/06/02/2022-6/%E8%8B%B1%E8%AF%AD%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/</id>
    <published>2022-06-02T03:07:22.000Z</published>
    <updated>2022-06-02T07:10:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>应Viking的要求给出一个英语六级作文模板</p><span id="more"></span><h2 id="题目解析">1. 题目解析</h2><p>目前常见的题型有</p><ol type="1"><li>现象解释/解决</li><li>某某品质的重要性<br /></li><li>谚语</li></ol><p>不过在21年六月出了个图表类的题目，确实令人猝不及防。</p><p>图表题写法可以参考<ahref="https://splendidwave.github.io/2022/03/26/2022-3/%E9%9B%85%E6%80%9D%E8%80%83%E8%AF%95%E5%B0%8F%E4%BD%9C%E6%96%87/">雅思小作文第四部分图表题写法</a>这里不展开。</p><p>作文是在六级考试最先写的，时间为30分钟，要求大于150字小于200字。</p><h2 id="开头">2. 开头</h2><p>其实常见的题型大多可以归类为the importantance of Y(某品质) ofX(某领域)</p><h3 id="开头模板1-古今对比">2.1 开头模板1 古今对比</h3><p>所以如果写作文比较愁字数的，可以用下面这个古今对比的大水版：</p><p>Wheter in history society or in contemporary society, it is commonphenomenon for people to expect pleasant interpersonal relationships inlife, work, and X. but what is the key to building them? I deem that theanswer is Y.</p><h3 id="开头模板2-假设建议">2.2 开头模板2 假设建议</h3><p>如果不愁字数，怕被看出背板的，还有一个比较简短的:</p><p>provided that X intends to acquire and enjoy long-time名词(prosperity/success), it is advisable for X to maintain their Y.</p><h3 id="开头模板3-两者抉择">2.3 开头模板3 两者抉择</h3><p>如果对通用模板不满意，还有针对性的，针对二者抉择问题：</p><p>in contemporary society, a rising numbers of people find it is hardto decide whether tehy should ...</p><p>或者</p><p>it is universally acknowledged that a host of individuals find itincreasingly challenging to decide whether ...</p><h3 id="开头模板4-原因现象">2.4 开头模板4 原因现象</h3><p>with the development of Internet and digital technology, there is atendency among people that…</p><p>或者</p><p>As the income increases，there was a surge of interest in...</p><p>或者</p><p>with the development of science and technology, many formerlyunimaginable things come into reality.some of them have positive effectson our life, but some are distasteful.</p><p>The phenomenon of ___ is an example.</p><h3 id="开头模板5-谚语">2.5 开头模板5 谚语</h3><p>This is simple but enlightening remark on _ _ by _ _</p><p>The profound meaning lying in this saying persuades us that _ _</p><h2 id="中间">3. 中间</h2><p>中间使用简单句掺杂比喻排比等句子。</p><h3 id="排比1">3.1 排比1</h3><p><strong>Without</strong> innovation, our social industries can neverbe modernized; <strong>without</strong> innovation, our medical sciencecan never cure so many diseases; and <strong>without</strong>innovation, there would be no electronic products we use today.</p><h3 id="排比比喻">3.2 排比+比喻</h3><p>curiosity towards knowledge, without a doubt, <strong>is the steppingstone</strong> which <strong>enriches</strong> learners’ minds,<strong>enhances</strong> their learning efficiency,<strong>ensures</strong> more fruitful results, and<strong>enables</strong> them to go further on the way of education.</p><h3 id="举例子">3.3 举例子</h3><p>A typical example is my friend, who is lazy and always ... Thus, sucha habit leads him nowhere</p><h3 id="排比2">3.4 排比2</h3><p>Some people are <strong>too subordinate to</strong> others' opinions,<strong>too focused on</strong> decision consensus, <strong>too silentabout</strong> their own point of view, <strong>too agreeableto</strong> take things on when they don't have time or energy</p><h3 id="一些短语">3.5 一些短语</h3><h4 id="应该">应该</h4><ol type="1"><li>We should bear in mind that</li><li>It is advisable for us to</li><li>should be encouraged to do</li></ol><h4 id="首先">首先</h4><ol type="1"><li>To begin with</li><li>First and foremost</li></ol><h4 id="总而言之">总而言之</h4><ol type="1"><li>in a word</li><li>to sum up</li><li>in a nutshell</li><li>by and large</li></ol><h2 id="结尾">4. 结尾</h2><p>In a nutshell, _ _ _ lays a solid foundation for _ _ as well as forthem to be qualified competitors in the future.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;应Viking的要求给出一个英语六级作文模板&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="英语" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="https://splendidwave.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
</feed>
