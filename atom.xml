<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SplendidWave&#39;Blog</title>
  
  <subtitle>灿 烂 的 波</subtitle>
  <link href="https://splendidwave.github.io/atom.xml" rel="self"/>
  
  <link href="https://splendidwave.github.io/"/>
  <updated>2024-06-05T13:53:46.606Z</updated>
  <id>https://splendidwave.github.io/</id>
  
  <author>
    <name>splendidwave</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>光学薄膜特性理论计算2-传输矩阵法</title>
    <link href="https://splendidwave.github.io/2024/06/05/2024-6/%E5%85%89%E5%AD%A6%E8%96%84%E8%86%9C%E7%89%B9%E6%80%A7%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%972-%E4%BC%A0%E8%BE%93%E7%9F%A9%E9%98%B5%E6%B3%95/"/>
    <id>https://splendidwave.github.io/2024/06/05/2024-6/%E5%85%89%E5%AD%A6%E8%96%84%E8%86%9C%E7%89%B9%E6%80%A7%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%972-%E4%BC%A0%E8%BE%93%E7%9F%A9%E9%98%B5%E6%B3%95/</id>
    <published>2024-06-05T13:53:11.000Z</published>
    <updated>2024-06-05T13:53:46.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>本文通过等效导纳的方法，推导出薄膜的特征矩阵并给出了数值计算方法。</p><span id="more"></span><h2 id="单层介质薄膜">1.单层介质薄膜</h2><h3 id="特征矩阵">1.1 特征矩阵</h3><p>单层薄膜的两个界面在数学上可以使用一个等效界面来表示，我们记等效后的导纳为组合导纳Y。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/image/202406052141974.png"alt="膜层等效" /><figcaption aria-hidden="true">膜层等效</figcaption></figure><p>因此单层膜的反射系数可以表示为</p><p><span class="math display">\[r = (\eta_0 - Y)/(\eta_0 + Y)\]</span></p><p>下面只需要计算有效导纳，将所有同方向的取相同符号，对于边界条件有</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/image/202406052142478.png"alt="单层膜电场" /><figcaption aria-hidden="true">单层膜电场</figcaption></figure><p><span class="math display">\[E_0 = E_0^+ + E_0^- = E_{11}^+ + E_{11}^-\]</span></p><p><span class="math display">\[H_0 = H_0^+ +H_0^- = \eta_1 E_{11}^+ - \eta_1 E_{11}^-\]</span></p><p>在薄膜上传播的波会出现相位差，所以记</p><p><span class="math display">\[E_0 = E_{12}^+ e^{-i\delta_1} +E_{12}^- e^{i\delta_1}\]</span></p><p><span class="math display">\[H_0 = \eta_1 e^{-i \delta_1 } E_{12}^+ - \eta_1 e^{-i \delta_1 }E_{12}^-\]</span></p><p>用矩阵表示</p><p><span class="math display">\[\begin{bmatrix}E_0\\H_0\end{bmatrix} = \begin{bmatrix}e^{- i \delta_1 } &amp; e^{i \delta_1}\\\eta_1 e^{-i \delta_1 }  &amp; - \eta_1 e^{i \delta_1 }\end{bmatrix}\begin{bmatrix}E_{12}^+\\E_{12}^-\end{bmatrix}\]</span></p><p>同理在界面2处有</p><p><span class="math display">\[E_2 = E_{12}^+ +E_{12}^-\]</span></p><p><span class="math display">\[H_2 = \eta_1 E_{12}^+ - \eta_1 E_{12}^-\]</span></p><p>用矩阵表示</p><p><span class="math display">\[\begin{bmatrix}E_{12}^+\\E_{12}^-\end{bmatrix} = \begin{bmatrix}\frac{1}{2} &amp; \frac{1}{2 \eta_1} \\\frac{1}{2}  &amp; - \frac{1}{2 \eta_1}\end{bmatrix}\begin{bmatrix}E_2\\H_2\end{bmatrix}\]</span></p><p>两式合并</p><p><span class="math display">\[\begin{bmatrix}E_0\\H_0\end{bmatrix} = \begin{bmatrix}e^{-i \delta_1 } &amp; e^{i \delta_1}\\\eta_1 e^{-i \delta_1 }  &amp; - \eta_1 e^{i \delta_1 }\end{bmatrix}\begin{bmatrix}\frac{1}{2} &amp; \frac{1}{2 \eta_1} \\\frac{1}{2}  &amp; - \frac{1}{2 \eta_1}\end{bmatrix}=\begin{bmatrix}\cos{\delta_1} &amp; -\frac{i}{\eta_1} \sin{\delta_1} \\{-i\eta_1} \sin{\delta_1}  &amp; \cos{\delta_1}\end{bmatrix}\begin{bmatrix}E_2\\H_2\end{bmatrix}\]</span></p><p>等效导纳为<span class="math inline">\(Y =H_0/E_0\)</span>，上式也可以写作</p><p><span class="math display">\[E_0\begin{bmatrix}1\\Y\end{bmatrix} =\begin{bmatrix}\cos{\delta_1} &amp; -\frac{i}{\eta_1} \sin{\delta_1} \\{-i\eta_1} \sin{\delta_1}  &amp; \cos{\delta_1}\end{bmatrix}\begin{bmatrix}1\\\eta_2\end{bmatrix}E_2\]</span></p><p>矩阵<span class="math inline">\(\begin{bmatrix}\cos{\delta_1} &amp; -\frac{i}{\eta_j} \sin{\delta_j} \\{-i\eta_j} \sin{\delta_j}  &amp; \cos{\delta_j}\end{bmatrix}\)</span>被定义为膜层的特征矩阵。</p><h3 id="仿真代码">1.2 仿真代码</h3><p>下面给出单层膜计算的流程图和matlab仿真代码，其中透反射与zemax仿真结果一致，</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/image/202406052142046.png"alt="单层膜计算流程图" /><figcaption aria-hidden="true">单层膜计算流程图</figcaption></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 传输矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[Ms,Mp]</span> = <span class="title">GET_single_TRM</span><span class="params">(n0,n,d,wavelength,theta0)</span></span></span><br><span class="line"><span class="comment">% 入射介质折射率 中间层折射率 中间层厚度 中间层折射率波长 入射角</span></span><br><span class="line"></span><br><span class="line">costheta1 = <span class="built_in">sqrt</span>(<span class="number">1</span>-(n0^<span class="number">2</span>*<span class="built_in">sin</span>(theta0)^<span class="number">2</span>)/(n^<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">deta = (<span class="number">2</span>*<span class="built_in">pi</span>/wavelength)*(n*d*costheta1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eta_p1 = n/costheta1;</span><br><span class="line">eta_s1 = n*costheta1;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算s光传输矩阵</span></span><br><span class="line">a1 = <span class="built_in">cos</span>(deta);</span><br><span class="line">a2 = <span class="number">-1</span><span class="built_in">i</span>*<span class="built_in">sin</span>(deta)/eta_s1;</span><br><span class="line">a3 = <span class="number">-1</span><span class="built_in">i</span>*<span class="built_in">sin</span>(deta)*eta_s1;</span><br><span class="line">a4 = <span class="built_in">cos</span>(deta);</span><br><span class="line">Ms = [a1,a2;a3,a4];</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算p光传输矩阵</span></span><br><span class="line">a1 = <span class="built_in">cos</span>(deta);</span><br><span class="line">a2 = <span class="number">-1</span><span class="built_in">i</span>*<span class="built_in">sin</span>(deta)/eta_p1;</span><br><span class="line">a3 = <span class="number">-1</span><span class="built_in">i</span>*<span class="built_in">sin</span>(deta)*eta_p1;</span><br><span class="line">a4 = <span class="built_in">cos</span>(deta);</span><br><span class="line">Mp = [a1,a2;a3,a4];</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">close all</span><br><span class="line"><span class="comment">% 定义参数 单位微米</span></span><br><span class="line">theta_ls = <span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">90</span>, <span class="number">500</span>);</span><br><span class="line">wavelength = <span class="number">0.55</span>;</span><br><span class="line">N_BK7 = <span class="number">1.5214145</span>;</span><br><span class="line">N_air = <span class="number">1</span>;</span><br><span class="line">N_my = <span class="number">1.38</span>;</span><br><span class="line">N_AL = <span class="number">0.7</span>+ <span class="number">7</span><span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">n0 = N_air;</span><br><span class="line">ns = N_air;</span><br><span class="line"><span class="comment">%d = wavelength/N_BK7*0.25;</span></span><br><span class="line">d = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 申请空间</span></span><br><span class="line"><span class="comment">% theta_ls = 0;</span></span><br><span class="line">Rs = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta_ls));</span><br><span class="line">Rp = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta_ls));</span><br><span class="line">Ts = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta_ls));</span><br><span class="line">Tp = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta_ls));</span><br><span class="line">S_phi_R = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta_ls));</span><br><span class="line">P_phi_R = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta_ls));</span><br><span class="line">S_phi_T = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta_ls));</span><br><span class="line">P_phi_T = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta_ls));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx = <span class="number">1</span>:<span class="built_in">numel</span>(theta_ls)</span><br><span class="line">    theta0 = theta_ls(idx);</span><br><span class="line">    theta0 = deg2rad(theta0);</span><br><span class="line">    [Ms,Mp] = GET_single_TRM(N_air,N_BK7,d,wavelength,theta0);</span><br><span class="line"></span><br><span class="line">    eta_p0 = n0/<span class="built_in">cos</span>(theta0);</span><br><span class="line">    eta_s0 = n0*<span class="built_in">cos</span>(theta0);</span><br><span class="line">    costhetas = <span class="built_in">sqrt</span>(<span class="number">1</span>-n0^<span class="number">2</span>*<span class="built_in">sin</span>(theta0)^<span class="number">2</span>/(ns^<span class="number">2</span>));</span><br><span class="line">    eta_ps = ns/costhetas;</span><br><span class="line">    eta_ss = ns*costhetas;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% s光</span></span><br><span class="line">    combMYs = Ms*[<span class="number">1</span>;eta_ss];</span><br><span class="line">    ys = combMYs(<span class="number">2</span>)/combMYs(<span class="number">1</span>);</span><br><span class="line">    rs = (eta_s0 - ys)/(eta_s0 + ys);</span><br><span class="line">    Rs(idx) = <span class="built_in">abs</span>(rs)^<span class="number">2</span>;</span><br><span class="line">    <span class="comment">% 势透射率</span></span><br><span class="line">    Psi = <span class="built_in">real</span>(eta_ss)/<span class="built_in">real</span>((combMYs(<span class="number">1</span>))*(<span class="built_in">conj</span>(combMYs(<span class="number">2</span>))));</span><br><span class="line">    Ts(idx) = (<span class="number">1</span> - Rs(idx))*Psi;</span><br><span class="line">    S_phi_R(idx) = <span class="built_in">angle</span>(rs)/<span class="built_in">pi</span>*<span class="number">180</span>;</span><br><span class="line">    <span class="comment">% p光</span></span><br><span class="line">    combMYp = Mp*[<span class="number">1</span>;eta_ps];</span><br><span class="line">    yp = combMYp(<span class="number">2</span>)/combMYp(<span class="number">1</span>);</span><br><span class="line">    rp = (eta_p0 - yp)/(eta_p0 + yp);</span><br><span class="line">    Rp(idx) = <span class="built_in">abs</span>(rp)^<span class="number">2</span>;</span><br><span class="line">    Psi = <span class="built_in">real</span>(eta_ps)/<span class="built_in">real</span>((combMYp(<span class="number">1</span>))*(<span class="built_in">conj</span>(combMYp(<span class="number">2</span>))));</span><br><span class="line">    Tp(idx) = (<span class="number">1</span>-Rp(idx))*Psi;</span><br><span class="line">    P_phi_R(idx) = <span class="built_in">angle</span>(rp)/<span class="built_in">pi</span>*<span class="number">180</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(theta_ls, Rs);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(theta_ls, Rp);</span><br><span class="line"><span class="built_in">plot</span>(theta_ls,(Rs+Rp)/<span class="number">2</span>);</span><br><span class="line">title(<span class="string">&#x27;Reflectivity&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(theta_ls,Ts);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(theta_ls,Tp);</span><br><span class="line"><span class="built_in">plot</span>(theta_ls,(Ts+Tp)/<span class="number">2</span>);</span><br><span class="line">title(<span class="string">&#x27;transmission&#x27;</span>);</span><br></pre></td></tr></table></figure><p>当把薄膜的有效光学厚度改为1/4波长的整数倍时候，如<code>theta0 = 0;</code>时、<code>d = wavelength/N_BK7*0.25;</code>在参考波长处传输矩阵会变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Ms =</span><br><span class="line"></span><br><span class="line">   0.0000 + 0.0000i   0.0000 - 0.6573i</span><br><span class="line">   0.0000 - 1.5214i   0.0000 + 0.0000i</span><br><span class="line"></span><br><span class="line">Mp =</span><br><span class="line"></span><br><span class="line">   0.0000 + 0.0000i   0.0000 - 0.6573i</span><br><span class="line">   0.0000 - 1.5214i   0.0000 + 0.0000i</span><br></pre></td></tr></table></figure><p>奇数倍时，特征矩阵的主对角线为0，此时膜系对透射和反射特性没有任何影响，被称为“虚设层”，而偶数倍时，会出现反射率的极值。厚度与反透射变化关系如下图，入射角为0度，横坐标单位为一个波长。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/image/202406052143736.png"alt="厚度和反透射关系" /><figcaption aria-hidden="true">厚度和反透射关系</figcaption></figure><h2 id="传输矩阵法">2.传输矩阵法</h2><p>多层膜的计算方法和单层膜相似，使用特征矩阵方法计算，特征矩阵如下：</p><p><span class="math display">\[\prod_{j=1}^{K} \begin{bmatrix}\cos{\delta_j} &amp; -\frac{i}{\eta_j} \sin{\delta_j} \\{-i\eta_j} \sin{\delta_j}  &amp; \cos{\delta_j}\end{bmatrix}\]</span></p><p>总体计算流程图如下</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/image/202406052144814.png"alt="流程图" /><figcaption aria-hidden="true">流程图</figcaption></figure><p>多层膜与单层类似，只需要多加一个循环即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">% 循环膜层</span><br><span class="line">for idx2 = 1:numel(n_ls)</span><br><span class="line">    nj = n_ls(idx2);</span><br><span class="line">    dj = d_ls(idx2);            </span><br><span class="line">    [Ms,Mp] = GET_single_TRM(n0,nj,dj,wavelength,theta0);</span><br><span class="line">    if idx2 == 1</span><br><span class="line">        Ms_all = Ms;</span><br><span class="line">        Mp_all = Mp;</span><br><span class="line">    else</span><br><span class="line">        Ms_all = Ms_all * Ms;</span><br><span class="line">        Mp_all = Mp_all * Mp;</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><p>[1] 唐晋发.现代光学薄膜技术.浙江大学出版社.2006年</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文通过等效导纳的方法，推导出薄膜的特征矩阵并给出了数值计算方法。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="物理" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%A9%E7%90%86/"/>
    
    
    <category term="光学" scheme="https://splendidwave.github.io/tags/%E5%85%89%E5%AD%A6/"/>
    
    <category term="薄膜" scheme="https://splendidwave.github.io/tags/%E8%96%84%E8%86%9C/"/>
    
  </entry>
  
  <entry>
    <title>光学薄膜特性理论计算1-菲涅尔公式</title>
    <link href="https://splendidwave.github.io/2024/06/05/2024-6/%E5%85%89%E5%AD%A6%E8%96%84%E8%86%9C%E7%89%B9%E6%80%A7%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%971-%E8%8F%B2%E6%B6%85%E5%B0%94%E5%85%AC%E5%BC%8F/"/>
    <id>https://splendidwave.github.io/2024/06/05/2024-6/%E5%85%89%E5%AD%A6%E8%96%84%E8%86%9C%E7%89%B9%E6%80%A7%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%971-%E8%8F%B2%E6%B6%85%E5%B0%94%E5%85%AC%E5%BC%8F/</id>
    <published>2024-06-05T13:20:11.000Z</published>
    <updated>2024-06-05T13:53:33.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>光在界面的传播是薄膜理论的基础，本文从麦克斯韦方程组出发推导菲涅尔公式。</p><span id="more"></span><h2 id="折射率与光学导纳1">1.折射率与光学导纳<sup>[1]</sup></h2><p>麦克斯韦方程组如下</p><p><span class="math display">\[\begin{align}    % Gauss&#39;s law for electricity    \nabla \cdot \mathbf{D} &amp;= \rho \nonumber \\    % Gauss&#39;s law for magnetism    \nabla \cdot \mathbf{B} &amp;= 0 \nonumber\\    % Faraday&#39;s law of electromagnetic induction    \nabla \times \mathbf{E} &amp;= -\frac{\partial \mathbf{B}}{\partialt} \nonumber\\    % Ampère&#39;s circuital law with Maxwell&#39;s addition    \nabla \times \mathbf{H} &amp;=  \mathbf{J} +  \frac{\partial\mathbf{D}}{\partial t} \nonumber\end{align}\]</span></p><p>将<span class="math inline">\(D = \varepsilon E\)</span> , <spanclass="math inline">\(J = \sigmaE\)</span>代入麦克斯韦方程组的安培环路定律可得</p><p><span class="math display">\[\nabla \times H = \varepsilon \frac{\partial E}{\partial t} + \sigma E\tag{1-1}\]</span></p><p>对法拉第电感定律两边取旋度并代入(1-1)有</p><p><span class="math display">\[\nabla \times \nabla \times E = - \mu  \frac{\partial (\nabla \timesH)}{\partial t} = - \mu \frac{\partial }{\partial t}(\varepsilon\frac{\partial E}{\partial t} + \sigma E \tag{1-2})\]</span></p><p>运用矢量恒等式<span class="math inline">\(\nabla \times \nabla \timesE =  \nabla (\nabla\cdotE)-\nabla^2E\)</span>在无电荷的均匀空间（根据高斯定理<spanclass="math inline">\(\nabla \cdot \mathbf{D} =0\)</span>），上式可以化简为</p><p><span class="math display">\[\nabla^2E = \mu \varepsilon \frac{\partial^2 E}{\partial^2 t} + \mu\sigma \frac{\partial E}{\partial t} \tag{1-3}\]</span></p><p>如果介质不导电，即<spanclass="math inline">\(\sigma=0\)</span>，式(1-3)变为</p><p><span class="math display">\[\nabla^2E = \mu \varepsilon \frac{\partial^2 E}{\partial^2t}   \tag{1-4}\]</span></p><p>通过求解微分方程，在不导电的均匀介质中，沿x正方向行进的电磁波的表达式可以写成</p><p><span class="math display">\[E = E_0 \exp[i\omega (t-\frac{x}{v})]\tag{1-5}\]</span></p><p>其中<span class="math inline">\(v=1/\sqrt{\mu\varepsilon}\)</span>是在介质中的传播速度，<spanclass="math inline">\(\omega\)</span>是角频率。电池波在真空中传播的速度和在不导电均匀介质中的速度比值，被称为介质的折射率，公式如下：</p><p><span class="math display">\[n = \frac{c}{v}=\frac{\sqrt{\varepsilon \mu}}{\sqrt{\varepsilon_0\mu_0}} = \sqrt{\varepsilon_r \mu_r}\tag{1-6}\]</span></p><p>在光频率下，光学材料的磁导率可以近似认为是1，所以有<spanclass="math inline">\(n=\sqrt{\varepsilon_r}\)</span></p><p>式(1-5)可以被认为是式(1-3)的一个特解，对于金属介质（<spanclass="math inline">\(\sigma \ne 0\)</span>）,将(1-5)回代，得到</p><p><span class="math display">\[\frac{1}{v^2} = \varepsilon \mu - i\frac{\sigma \mu }{\omega} \tag{1-7}\]</span></p><p>则对于金属介质的折射率有</p><p><span class="math display">\[N^2 = \frac{c^2}{v^2} = (\varepsilon \mu - i\frac{\sigma \mu}{\omega})/\varepsilon_0 \mu_0 \tag{1-8}\]</span></p><p>可知金属的折射率为复数，记作<span class="math inline">\(N = n -ik\)</span>，回代入式(1-5)得</p><p><span class="math display">\[E = E_0 \exp{(-\frac{2\pi k x}{\lambda })}\exp{ \left [ i(\omega t -\frac{2\pi n x}{\lambda})  \right ] }\]</span></p><p>说明对于金属折射率的虚部会让电磁波发生指数级衰减，所以k又被称为吸收系数。</p><p>同理，磁场也可以写做波函数的形式，<strong>磁场和电场的表达式如下</strong>：</p><p><span class="math display">\[\mathbf{H} = H_0 \exp{ \left [ i(\omega t - \frac{2\pi N }{\lambda})\mathbf{S_0} \cdot \mathbf{r}  \right ] }\]</span></p><p><span class="math display">\[\mathbf{E} = E_0 \exp{ \left [ i(\omega t - \frac{2\pi N }{\lambda})\mathbf{S_0} \cdot \mathbf{r}  \right ] }\]</span></p><p>其中<spanclass="math inline">\(\mathbf{S_0}\)</span>是平面波传播方向的单位矢量，<spanclass="math inline">\(\mathbf{r}\)</span>是坐标矢径。</p><p>对于<span class="math inline">\(\nabla \times H = -i\frac{2\piN}{\lambda}(\mathbf{S_0} \times\mathbf{H})\)</span>带入麦克斯韦方程组得</p><p><span class="math display">\[\mathbf{S_0} \times \mathbf{H} = -\frac{N\sqrt{\varepsilon _0/\mu_0}}{\mu_r} \mathbf{E}\]</span></p><p><span class="math display">\[\frac{N\sqrt{\varepsilon _0/\mu_0} }{\mu_r} \mathbf{S_0} \times\mathbf{E} = \mathbf{H}\]</span></p><p>上两式说明，电场和磁场是相互垂直的，而且都与传播方向垂直，且符合右手螺旋法则。对于传播过程中，E和H不但相互垂直，且数值间也存在一定比值。</p><p><span class="math display">\[Y = \frac{\left | \mathbf{H} \right | }{\left | \mathbf{S_0 \times E}\right | } = \frac{N\sqrt{\varepsilon _0 / \mu_0}}{\mu_r}\]</span></p><p>Y被称为介质的光学导纳，其中磁导率<spanclass="math inline">\(\mu_r\)</span>通常接近于1，若以自由空间导纳<spanclass="math inline">\(\sqrt{\varepsilon _0 /\mu_0}\)</span>为单位，则光学导纳与折射率相等。</p><h2 id="折射反射定律">2.折射反射定律</h2><p>根据电磁场的边界条件在界面处E和H的切向分量是连续的，有</p><p><span class="math display">\[E_t^i + E_t^r = E_t^t\]</span></p><p><span class="math display">\[H_t^i + H_t^r = H_t^t\]</span></p><p><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/image/202406052131554.png" /></p><p>按图中所示，光线在xz平面传播，以<spanclass="math inline">\(\theta_0\)</span>的角度入射到界面，界面为<spanclass="math inline">\(z=0\)</span>平面。其入射光相位因子为</p><p><span class="math display">\[\exp{\left \{ i\left [ \omega _i t - \frac{2\pi N_0}{\lambda} \left(  \sin\theta_0 x + \cos \theta_0 z\right ) \right ]  \right \} }\]</span></p><p>设反射光和透射光的相位分别为</p><p><span class="math display">\[\exp{\left \{ i\left [ \omega _i t - \frac{2\pi N_0}{\lambda} \left(  \alpha_r x +\beta_r y+ \gamma_r z\right ) \right ]  \right \} }\]</span></p><p><span class="math display">\[\exp{\left \{ i\left [ \omega _i t - \frac{2\pi N_1}{\lambda} \left(  \alpha_t x +\beta_t y+ \gamma_t z\right ) \right ]  \right \} }\]</span></p><p>要满足边界条件，界面上的相位因子必须相等。所以有<spanclass="math inline">\(\beta_r = \beta_t = 0\)</span>、<spanclass="math inline">\(N_0 \alpha_i = N_0 \alpha_r = N_1\alpha_t\)</span></p><p>可以得出反射和折射定律</p><p><span class="math display">\[\theta_0 = \theta_r\]</span></p><p><span class="math display">\[N_0 \sin \theta_0 = N_1 \sin \theta_t\]</span></p><h2 id="菲涅尔公式">3.菲涅尔公式</h2><h3 id="垂直入射情况">3.1 垂直入射情况</h3><p>为进一步研究反射光和入射光振幅和相位的变化关系，我们先假设光是垂直入射界面的。</p><p>对于垂直入射界面的光，显然有E和H都是平行于界面，有 <spanclass="math display">\[H_1 = H_t , E_1 = E_t\]</span></p><p>又根据边界条件有</p><p><span class="math display">\[E_1 = E_0^+ + E_0^-\]</span></p><p><span class="math display">\[H_1 = H_0^+ + H_0^-\]</span></p><p>其中下标0和1代表界面的两边，上标+代表正向传播，-代表反向传播。结合上式有</p><p><span class="math display">\[H_1 = N_1(S_0 \times E_1) = N_0(S_0 \times E_0^+ - S_0 \times E^-_0)\]</span></p><p>即</p><p><span class="math display">\[N_1 E_1 = N_0 (E_0^+ - E_0^-)\]</span></p><p>化简可得反射系数和透射系数</p><p><span class="math display">\[r = \frac{E_0^-}{E_0^+} = \frac{N_0-N_1}{N_0+N_1}\]</span></p><p><span class="math display">\[t = \frac{E_1}{E_0^+} = \frac{2N_0}{N_0 + N_1}\]</span></p><h3 id="倾斜入射情况">3.2 倾斜入射情况</h3><p>下面考虑倾斜入射的情况。我们将入射的电磁波分解为，电场垂直反射面（s光）和平行反射面（p光）振动的两种状态。</p><p><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/image/202406052138385.png" /></p><p>为方便定义切向分量，现引入有效导纳的概念</p><p><span class="math display">\[\eta = H_t^+ / (S_0 \times E_t^+)\]</span></p><p>对于p光（TM波），磁场H垂直于入射面，与界面平行，因此<spanclass="math inline">\(H = H_t\)</span>，而电场<spanclass="math inline">\(E=Ecos \theta\)</span></p><p><span class="math display">\[H_t = H = N(S_0 \times E) = N(r_0 \times E_t/cos\theta) =\frac{N}{cos\theta}(r_0 \times E_t)\]</span></p><p>所以对于p光有<span class="math inline">\(\eta_p = N/cos\theta\)</span>,同理对于s光有<span class="math inline">\(\eta_s = Ncos\theta\)</span></p><p>对菲涅尔反射系数可以写作</p><p><span class="math display">\[r_p = \frac{\eta_{0p}-\eta_{1p}}{\eta_{0p}+\eta_{1p}} =\frac{N_0cos\theta_1 - N_1 cos\theta_0}{N_0cos\theta_1 + N_1cos\theta_0}\]</span></p><p><span class="math display">\[r_s = \frac{\eta_{0s}-\eta_{1s}}{\eta_{0s}+\eta_{1s}} =\frac{N_0cos\theta_0 - N_1 cos\theta_1}{N_0cos\theta_0 + N_1cos\theta_1}\]</span></p><p>对于透射系数可以写作</p><p><span class="math display">\[t_p = \frac{2N_0cos\theta_0}{N_0cos\theta_1+N_1cos\theta_0}\]</span></p><p><span class="math display">\[t_s = \frac{2N_0cos\theta_0}{N_0cos\theta_0 + N_1cos\theta_1}\]</span></p><p>反射率为</p><p><span class="math display">\[R = r^2\]</span></p><p>透射率为</p><p><span class="math display">\[T = \frac{N_1cos\theta_1}{N_0cos\theta_0}|t^2|\]</span></p><p>该公式对复折射率介质也同样成立。</p><p>给出计算代码如下，其中函数公式中符号相反只影响相位，并不影响透射和反射率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Fresnel</span>(<span class="params">n1, n2, theta1</span>):</span><br><span class="line">    <span class="comment"># 角度转弧度</span></span><br><span class="line">    theta1 = theta1 /<span class="number">180</span> * np.pi</span><br><span class="line">    costheta1 = np.cos(theta1)</span><br><span class="line">    n1_r = n1.real</span><br><span class="line">    n2_r = n2.real</span><br><span class="line">    costheta2_2 = <span class="number">1</span>-(n1_r/n2_r*np.sin(theta1))**<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> costheta2_2 &gt;= <span class="number">0</span>:</span><br><span class="line">        costheta2 = np.sqrt(costheta2_2)</span><br><span class="line">        rp = (n2*costheta1 - n1*costheta2)/(n2*costheta1 + n1*costheta2)</span><br><span class="line">        rs = (n1*costheta1 - n2*costheta2)/(n1*costheta1 + n2*costheta2)</span><br><span class="line">        tp = (<span class="number">2</span>*n1*costheta1)/(n1*costheta2+n2*costheta1)</span><br><span class="line">        ts = (<span class="number">2</span>*n1*costheta1)/(n1*costheta1+n2*costheta2)    </span><br><span class="line">        temp = n2*costheta2/(n1*costheta1)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#发生了全反射</span></span><br><span class="line">        rp = <span class="number">1.0</span></span><br><span class="line">        rs = <span class="number">1.0</span></span><br><span class="line">        tp = <span class="number">0.0</span></span><br><span class="line">        ts = <span class="number">0.0</span></span><br><span class="line">        temp = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rp**<span class="number">2</span>, rs**<span class="number">2</span>, temp*(tp**<span class="number">2</span>),temp*(ts**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">theta_ls = np.linspace(<span class="number">0</span>, <span class="number">90</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">N_Bk7 = <span class="number">1.5214145</span></span><br><span class="line">N_air = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p光数据</span></span><br><span class="line">Rp_ls = []</span><br><span class="line">Tp_ls = []</span><br><span class="line"><span class="comment"># s光数据</span></span><br><span class="line">Rs_ls = []</span><br><span class="line">Ts_ls = []</span><br><span class="line"><span class="comment"># 平均数据</span></span><br><span class="line">Avg_r_ls = []</span><br><span class="line">Avg_t_ls = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 吸收计算，暂时为 0</span></span><br><span class="line">absorb = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> theta <span class="keyword">in</span> theta_ls:</span><br><span class="line">    Rp,Rs,Tp,Ts = Fresnel(N_air,N_Bk7,theta)</span><br><span class="line">    Rp_ls.append(Rp)</span><br><span class="line">    Rs_ls.append(Rs)</span><br><span class="line">    Tp_ls.append(Tp)</span><br><span class="line">    Ts_ls.append(Ts)</span><br><span class="line">    Avg_r_ls.append((Rp+Rs)/<span class="number">2</span>)</span><br><span class="line">    Avg_t_ls.append((Tp+Ts)/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.plot(theta_ls,Rp_ls,color=<span class="string">&quot;green&quot;</span>,label = <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">plt.plot(theta_ls,Rs_ls,color=<span class="string">&quot;blue&quot;</span>,label = <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">plt.plot(theta_ls,Avg_r_ls,color=<span class="string">&quot;red&quot;</span>,label = <span class="string">&#x27;avg&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper left&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;R&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">2</span>)</span><br><span class="line">plt.plot(theta_ls,Tp_ls,color=<span class="string">&quot;green&quot;</span>,label = <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">plt.plot(theta_ls,Ts_ls,color=<span class="string">&quot;blue&quot;</span>,label = <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">plt.plot(theta_ls,Avg_t_ls,color=<span class="string">&quot;red&quot;</span>,label = <span class="string">&#x27;avg&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper left&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;T&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="全反射情况">3.3 全反射情况</h3><p>这里只给出相位公式，公式来着参考资料[1]</p><p><span class="math display">\[\tan \frac{1}{2}\varphi _s = \frac{(\sin^2\theta_0 -n_1^2/n_0^2)^{1/2}}{\cos \theta_0}\]</span></p><p><span class="math display">\[\tan \frac{1}{2}\varphi _p = \frac{n_1^2/n_0^2 \cdot\cos\theta_0}{(\sin^2\theta_0 - n_1^2/n_0^2)^{1/2}}\]</span></p><p>但在使用zemax仿真时，发现相位不需要乘2数值才是匹配的，源码和仿真结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Phase</span>(<span class="params">n1, n2, theta1</span>):</span><br><span class="line">    <span class="comment"># 角度转弧度</span></span><br><span class="line">    theta1 = theta1 /<span class="number">180</span> * np.pi</span><br><span class="line">    costheta1 = np.cos(theta1)</span><br><span class="line">    n1_r = n1.real</span><br><span class="line">    n2_r = n2.real</span><br><span class="line">    costheta2_2 = <span class="number">1</span>-(n1_r/n2_r*np.sin(theta1))**<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> costheta2_2 &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> n1 &gt; n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#全反射</span></span><br><span class="line">        tande_s = np.sqrt(np.sin(theta1)**<span class="number">2</span>-n2**<span class="number">2</span>/n1**<span class="number">2</span>)/costheta1</span><br><span class="line">        a = (n2**<span class="number">2</span>)/(n1**<span class="number">2</span>) * (costheta1)</span><br><span class="line">        b = np.sqrt(np.sin(theta1)**<span class="number">2</span> - n2**<span class="number">2</span>/n1**<span class="number">2</span>)</span><br><span class="line">        tande_p = -(a)/(b)</span><br><span class="line">        <span class="keyword">return</span> np.arctan(tande_p)/np.pi*<span class="number">180</span>,np.arctan(tande_s)/np.pi*<span class="number">180</span></span><br><span class="line"></span><br><span class="line">theta_ls = np.linspace(<span class="number">0</span>, <span class="number">90</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">N_Bk7 = <span class="number">1.5214145</span></span><br><span class="line">N_air = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p光数据</span></span><br><span class="line">Rp_ls = []</span><br><span class="line">Tp_ls = []</span><br><span class="line"><span class="comment"># s光数据</span></span><br><span class="line">Rs_ls = []</span><br><span class="line">Ts_ls = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> theta <span class="keyword">in</span> theta_ls:</span><br><span class="line">    dep,des = Phase(N_Bk7, N_air, theta)</span><br><span class="line">    Rp_ls.append(dep)</span><br><span class="line">    Rs_ls.append(des)</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.plot(theta_ls,Rp_ls,color=<span class="string">&quot;green&quot;</span>,label = <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">plt.plot(theta_ls,Rs_ls,color=<span class="string">&quot;blue&quot;</span>,label = <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/image/202406052139055.png"alt="全反射" /><figcaption aria-hidden="true">全反射</figcaption></figure><h2 id="参考资料">参考资料</h2><p>[1] 唐晋发.现代光学薄膜技术.浙江大学出版社.2006年</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;光在界面的传播是薄膜理论的基础，本文从麦克斯韦方程组出发推导菲涅尔公式。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="物理" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%A9%E7%90%86/"/>
    
    
    <category term="光学" scheme="https://splendidwave.github.io/tags/%E5%85%89%E5%AD%A6/"/>
    
    <category term="薄膜" scheme="https://splendidwave.github.io/tags/%E8%96%84%E8%86%9C/"/>
    
  </entry>
  
  <entry>
    <title>像差理论</title>
    <link href="https://splendidwave.github.io/2023/11/24/2023-11/%E5%83%8F%E5%B7%AE%E7%90%86%E8%AE%BA/"/>
    <id>https://splendidwave.github.io/2023/11/24/2023-11/%E5%83%8F%E5%B7%AE%E7%90%86%E8%AE%BA/</id>
    <published>2023-11-24T11:07:01.000Z</published>
    <updated>2024-06-05T13:48:39.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>像差（Aberration）是光学系统中常见的一个概念，用于描述由于光线在透镜或镜面上折射或反射时引起的偏差或失真。像差理论涉及到光线聚焦时产生的偏离理想图像的情况，本文将针对不同类型的像差做出形成原因的介绍，并提供简单的消除的方法。</p><span id="more"></span><h2 id="像差分类和多色像差">1.像差分类和多色像差</h2><p>对于一个简单的光学系统，假设物是一个垂直于光学系统主轴的平面，完美的像就需要包括以下几个条件</p><ol type="1"><li>上面的每一个发光点应该成一个清晰的像点。</li><li>所有的像点必须在同一平面，且该平面也要垂直于光学系统的主轴</li><li>各个像点的横向放大率必须都是常数</li><li>像的各个部分应该和物有相同的颜色</li></ol><p>如果条件12不满足，像就会出现模糊不清晰的情况；如果23不满足，像会出现变形；如果4不满足，像会出现<strong>色差</strong>。</p><p>色差通常来说是由于光学材料的色散引起的，具体表现为在图片中出现颜色偏差的情况，如下图。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231124141022.png"alt="色差" /><figcaption aria-hidden="true">色差</figcaption></figure><p><a href="https://zhuanlan.zhihu.com/p/486148333">图片来源</a></p><p>根据不同平面的波长色散，色差可以分为两种类型：纵向色差（子午色差）和横向色差（弧矢色差）。子午色差可以通过缩小镜头光圈来大幅度减少。使用类似冕玻璃（低折射低色散）和火石玻璃（高折射高色散）组合形成的复合透镜也是消除色差的。</p><p>单色像差的分类就比较多了，如近轴物宽光束引起的球差和慧差，远轴物窄光束引起的像散，场曲和畸变。</p><h2 id="球差">2.球差</h2><p>主轴上的一个物点所发出的宽光束由透镜折射后并不会聚于单独的一个像点，而是成为弥散的圆斑，这种现象被称为球差。球差的形成原因是光线通过光学系统后的射线与主轴的交点不重合。球差也是唯一的轴上像差。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231124152414.png"alt="球差" /><figcaption aria-hidden="true">球差</figcaption></figure><p><a href="https://zhuanlan.zhihu.com/p/73397254">图片来源</a></p><p>球差的一种朴素解决方法是缩小光圈，进入的光线越是接近主轴越是趋向于理想成像。其次是使用非球面透镜，这种透镜有复杂的曲率形状，使得光线更均匀的聚焦，但是会给加工带来很大的麻烦。目前较优的解决方案是使用复合透镜，通过将多个透镜组合在一起，使得每个透镜的球差效应相互抵消，从而减少整个系统的球差影响。</p><h2 id="慧差">3.慧差</h2><p>慧差是光学系统中常见的一种像差，它导致来自非轴向点源的光线在焦点上形成呈彗星状的像。在宽光束大视场的情况下会尤为明显。</p><p>校准方式：孔径和视场都会影响慧差，一种方法是缩小孔径和视场，但通常不这么使用。第二是利用对称光学系统，以<spanclass="math inline">\(\beta = -1\)</span>成像。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2024/01/20240106154449.png"alt="慧差" /><figcaption aria-hidden="true">慧差</figcaption></figure><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231124165233.png"alt="对称系统" /><figcaption aria-hidden="true">对称系统</figcaption></figure><p>但这种严格对称系统，不具备放大像的作用，在一些其他场景通常会做相对的取舍。</p><h2 id="像散">4.像散</h2><p>子午像点和弧矢像点不重合。通常在实际中会被慧差遮盖无法直观看出。主要受到视场影响，处理方法一是控制视场，二是使用柱状镜。像散在眼科中被称为散光，像散对成像质量的影响会比慧差小一些，更像是窄光束下的慧差。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2024/01/20240106154520.png"alt="像散" /><figcaption aria-hidden="true">像散</figcaption></figure><h2 id="场曲">5.场曲</h2><p>场曲又被称为像面弯曲。轴外物点对各光线的交点偏离高斯像面的距离被称为场曲，发生场曲后的成像最佳像面是曲面。像散的产生必然导致场曲，但存在场曲不一定有色散。</p><p>校准方法：正负光焦度组合（正负透镜组，弯月型厚透镜）</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2024/01/20240106154558.png"alt="场曲" /><figcaption aria-hidden="true">场曲</figcaption></figure><h2 id="畸变">5.畸变</h2><p>畸变又被称为失真，不同视场的主光线通过光学系统后与高斯像面的交点高度不等于理想高度，其中的差异就是畸变。场曲是成像是曲面，畸变是指像面上的成像出现弯曲。根据凸出的方向可以分为桶型畸变和枕型畸变。畸变只会影响像形状不会影响清晰度。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231124181015.png"alt="畸变1" /><figcaption aria-hidden="true">畸变1</figcaption></figure><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2024/01/20240106154632.png"alt="畸变2" /><figcaption aria-hidden="true">畸变2</figcaption></figure><p>校准方法：一是利用对称光学系统，以<span class="math inline">\(\beta =-1\)</span>成像。二是设置孔径光阑位置</p><h2 id="参考资料">参考资料</h2><ol type="1"><li><ahref="https://www.bilibili.com/video/BV1J84y1v7Jy/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">工程光学-光学设计篇-像差-慧差、像散</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;像差（Aberration）是光学系统中常见的一个概念，用于描述由于光线在透镜或镜面上折射或反射时引起的偏差或失真。像差理论涉及到光线聚焦时产生的偏离理想图像的情况，本文将针对不同类型的像差做出形成原因的介绍，并提供简单的消除的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="物理" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%A9%E7%90%86/"/>
    
    
    <category term="光学" scheme="https://splendidwave.github.io/tags/%E5%85%89%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>加速度传感器校准方法分析</title>
    <link href="https://splendidwave.github.io/2023/11/16/2023-11/%E5%8A%A0%E9%80%9F%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%A1%E5%87%86%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://splendidwave.github.io/2023/11/16/2023-11/%E5%8A%A0%E9%80%9F%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%A1%E5%87%86%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2023-11-16T01:20:11.000Z</published>
    <updated>2023-11-16T01:30:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>为防止俯仰角、四元数等概念干扰主题，这里以测xy平面角度的水平尺应用为例介绍加速度传感器的误差来源与校准方法，使用两个维度便于理解，扩展到多个维度同理可得。</p><span id="more"></span><h2 id="加速度传感器原理">加速度传感器原理</h2><p>根据牛顿第二定律<spanclass="math inline">\(F=ma\)</span>可知测量加速度等价于测量受力，在三维笛卡尔空间中，力又可以分解为三个坐标轴上的分量。因此在一个轴上，传感器可以简化等效为下图模型。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231116092435.png"alt="加速度传感器原理" /><figcaption aria-hidden="true">加速度传感器原理</figcaption></figure><p>传感器芯片通过电容读取到加速度的大小并进行编码，总线上发出指令后它就会将测量到的数据传输出来。三轴应用最广泛的是在手机上，用于检测手机的朝向并进行屏幕的翻转。</p><p>测量xy平面的角度需要两个轴，计算方法就是简单的三角函数<spanclass="math inline">\(\arctan(\frac{y}{x})\)</span>，示意图如下。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231116092457.png"alt="角度计算" /><figcaption aria-hidden="true">角度计算</figcaption></figure><h2 id="误差分析">误差分析</h2><p>实际使用三角函数公式去处理传感器的返回值得到的角度肯定是不准确的，因为传感器的测量值本身存在误差。下面是几个典型的误差。</p><h3 id="零点偏移">零点偏移</h3><p>零点偏移是指在实际值为0g的时候传感器的输出值，示意图如下。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231116092516.png"alt="零点偏移" /><figcaption aria-hidden="true">零点偏移</figcaption></figure><p>零点偏移产生的原因有很多种，比如出厂时ProofMass并没有在中间的位置，温度也会影响零点位置。这里统一视作是零点偏移。这部分误差使用加减差值来处理。</p><h3 id="尺度误差">尺度误差</h3><p>这部分的误差来自于传感器的数字信号向物理量转换的误差，就和尺子一样，如果其刻度不均匀，量出的值也会不同。在测角度案例中通常体现为不同轴的数值不能等价。</p><p>这部分误差可以通过缩放来处理。</p><h3 id="正交误差">正交误差</h3><p>传感器的三个轴不一定是完全正交的，这个很好理解就不多解释了。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231116092710.png"alt="正交误差" /><figcaption aria-hidden="true">正交误差</figcaption></figure><h3 id="机械误差">机械误差</h3><p>这部分误差是指传感器在贴片和组装为成品过程中产生的误差。</p><h3 id="随机误差">随机误差</h3><p>白噪声和随机游走等干扰也会对测量产生误差，这类随机误差通常需要ALLAN方差校准来处理，也是比较难消除的一类误差。</p><h2 id="校准方法">校准方法</h2><h3 id="粗略校准法">粗略校准法</h3><p>在一个水平面上正向测出数据，如何旋转180°测得第二个值，在90°面上重复这一操作。可以获得4个数据，分别记为:</p><p><span class="math display">\[[x_{max},y_{o1}],[x_{min},y_{o2}],[x_{o1},y_{max}],[x_{o2},y_{min}]\]</span></p><p>可以获得零偏和尺度，<span class="math inline">\(X_{offset} =\frac{x_{max}+x_{min}}{2}\)</span>,<spanclass="math inline">\(Y_{offset} =\frac{y_{max}+y_{min}}{2}\)</span>,<span class="math inline">\(S_{x} =\frac{x_{max}-x_{min}}{2}\)</span>,<span class="math inline">\(S_{y} =\frac{y_{max}-y_{min}}{2}\)</span></p><p>当然这是非常简单粗暴的做法。</p><h3 id="六面校准法">六面校准法</h3><p>结合上述的噪声(Bias and Noise)、尺度因子(Scale errors)和轴偏差(Axismisalignments)。建立加速度传感器的测量模型如下</p><p><span class="math display">\[a^{B} = R T K (a^S + b + \nu)\]</span></p><p>其中<spanclass="math inline">\(a^{B}\)</span>表示正交参考系坐标系下的加速度值，<spanclass="math inline">\(a^S\)</span>表示传感器对应的非正交坐标系下的加速度值，R表示机械误差的旋转校正矩阵，T表示轴偏校正的变化矩阵，K表示尺度因子，<spanclass="math inline">\(b\)</span>和<spanclass="math inline">\(\nu\)</span>分别表示零偏和随机噪声。</p><p>以两个轴为例，a是一个<spanclass="math inline">\(2\times1\)</span>的矩阵，RTK相乘视作一个<spanclass="math inline">\(2\times2\)</span>的矩阵，忽略<spanclass="math inline">\(\nu\)</span>，将<spanclass="math inline">\(b\)</span>视作常数。可以得到如下方程</p><p><span class="math display">\[\begin{bmatrix}A_x\\A_y\end{bmatrix}=\begin{bmatrix}a &amp; b\\c &amp; d\end{bmatrix}\begin{bmatrix}A_{mx}\\A_{my}\end{bmatrix}+\begin{bmatrix}off_x\\off_y\end{bmatrix}\]</span></p><p>变为齐次方程坐标形式有</p><p><span class="math display">\[\begin{bmatrix}A_{mx}&amp;A_{my}&amp;1\end{bmatrix}\begin{bmatrix}a &amp; c  \\b &amp; d  \\off_x &amp; off_y\end{bmatrix} = \begin{bmatrix}A_x &amp; A_y\end{bmatrix}\]</span></p><p>使用最小二乘法求解上述方程，<span class="math inline">\(\beta = (X^TX)^{-1}X^T Y\)</span>，其中<spanclass="math inline">\(\beta\)</span>是参数矩阵，X是测量值，Y是理论值。理论值是将传感器按轴向位置放置测量。这里只给出了2个轴向的方程推导，3轴校准也是同理，参见参考资料<ahref="#refer-anchor-1"><sup>[2]</sup></a></p><h3 id="椭圆校准法">椭圆校准法</h3><p>理想的xy轴数据在坐标系中的分布应当为圆形，但由于受到误差影响，实际会呈现出椭圆形状，如下图所示</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231116092732.png"alt="椭圆数据点" /><figcaption aria-hidden="true">椭圆数据点</figcaption></figure><p>椭圆的方程为</p><p><span class="math display">\[\left ( \frac{x-x_0}{A} \right )^2 + \left (  \frac{y-y0}{B} \right ) ^2= 1\]</span></p><p>其中<span class="math inline">\(x_0\)</span>和<spanclass="math inline">\(y_0\)</span>为椭圆中心的偏移值即零偏误差，<spanclass="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span>是椭圆的两个轴即尺度因子。所以通过最小二乘法拟合椭圆参数即可得到校准值。将上式展开有</p><p><span class="math display">\[x^2+ay^2+cx+dy+f = 0\]</span></p><p>其中<span class="math inline">\(a = \frac{A^2}{B^2},c =-2x_0,d=-2Y_0\frac{A^2}{B^2},f = x_0^2 +  \frac{A^2}{B^2}y_0^2 -A^2\)</span></p><p>取误差函数为</p><p><span class="math display">\[e_i(a,c,d,f) = x_i^2+ay_i^2+cx_i+dy_i+f\]</span></p><p>则误差的平方和为</p><p><span class="math display">\[E_i = \sum_{i=1}^{N} e_i^2\]</span></p><p>要求对<spanclass="math inline">\(a,c,d,f\)</span>的一阶偏导为零，可得方程组</p><p><span class="math display">\[\left\{\begin{matrix}\frac{\partial E}{\partial a}=0\\\frac{\partial E}{\partial c}=0\\\frac{\partial E}{\partial d}=0\\\frac{\partial E}{\partial f}=0\end{matrix}\right.  \Longrightarrow\left\{\begin{matrix}\sum_{i=1}^{N}  e_i y_i^2 = 0\\\sum_{i=1}^{N}  e_i x_i = 0\\\sum_{i=1}^{N}  e_i y_i = 0\\\sum_{i=1}^{N}  e_i = 0\end{matrix}\right.\]</span></p><p>使用<span class="math inline">\(\bar{x}\)</span>代替平均值<spanclass="math inline">\(\frac{1}{N}\sum_{i=1}^{N}x_i\)</span>的记法，将上式展开，有</p><p><span class="math display">\[\left\{\begin{matrix}\overline{x^2y^2} + a \overline{y^4} + c\overline{xy^2} + d\overline{y^3} + f \overline{y^2} = 0  \\\overline{x^3} + a \overline{x y^2} + c\overline{x^2} + d \overline{xy}+ f \overline{x} = 0\\\overline{x^2y} + a \overline{y^3} + c\overline{xy} + d \overline{y^2} +f \overline{y} = 0 \\\overline{x^2} + a \overline{y} + c\overline{x} + d \overline{y} + f  =0\end{matrix}\right.\]</span></p><p>写成矩阵形式有</p><p><span class="math display">\[\begin{bmatrix}\overline{y^4} &amp; \overline{xy^2} &amp; \overline{y^3} &amp;\overline{y^2}\\\overline{x y^2} &amp; \overline{x^2} &amp; \overline{xy} &amp;\overline{x}\\\overline{y^3} &amp; \overline{xy} &amp; \overline{y^2} &amp;\overline{y}\\\overline{y} &amp; \overline{x} &amp; \overline{y} &amp; 1\end{bmatrix}\begin{bmatrix}a\\c\\d\\f\end{bmatrix} = \begin{bmatrix}-\overline{x^2y^2}\\-\overline{x^3}\\-\overline{x^2y} \\-\overline{x^2}\end{bmatrix}\]</span></p><p>求解方程即可计算出几个参数的值，使用python进行数据计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">&quot;data.csv&quot;</span>)</span><br><span class="line">x = np.array(data.loc[:, <span class="string">&quot;x&quot;</span>])</span><br><span class="line">y = np.array(data.loc[:, <span class="string">&quot;y&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_points = <span class="built_in">len</span>(x)</span><br><span class="line"><span class="comment"># 绘制数据点</span></span><br><span class="line">plt.scatter(x, y, label=<span class="string">&#x27;Data Points&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次统计平均</span></span><br><span class="line">x_var = <span class="built_in">sum</span>(x)/num_points</span><br><span class="line">y_var = <span class="built_in">sum</span>(y)/num_points</span><br><span class="line"><span class="comment"># 二次统计平均</span></span><br><span class="line">xx_var = <span class="built_in">sum</span>(x**<span class="number">2</span>)/num_points</span><br><span class="line">yy_var = <span class="built_in">sum</span>(y**<span class="number">2</span>)/num_points</span><br><span class="line">xy_var = <span class="built_in">sum</span>(x*y)/num_points</span><br><span class="line"><span class="comment"># 三次统计平均</span></span><br><span class="line">xxx_var = <span class="built_in">sum</span>(x*x*x)/num_points</span><br><span class="line">yyy_var = <span class="built_in">sum</span>(y*y*y)/num_points</span><br><span class="line">xxy_var = <span class="built_in">sum</span>(x*x*y)/num_points</span><br><span class="line">xyy_var = <span class="built_in">sum</span>(x*y*y)/num_points</span><br><span class="line"><span class="comment"># 四次统计平均</span></span><br><span class="line">xxxx_var = <span class="built_in">sum</span>(x*x*x*x)/num_points</span><br><span class="line">yyyy_var = <span class="built_in">sum</span>(y*y*y*y)/num_points</span><br><span class="line">xxyy_var = <span class="built_in">sum</span>(x*x*y*y)/num_points</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A0 = np.array([[yyyy_var,xyy_var,yyy_var,yy_var],</span><br><span class="line">              [xyy_var,xx_var,xy_var,x_var],</span><br><span class="line">              [yyy_var,xy_var,yy_var,y_var],</span><br><span class="line">              [yy_var,x_var,y_var,<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">b = np.array([-xxyy_var,-xxx_var,-xxy_var,-xx_var]).T</span><br><span class="line"></span><br><span class="line">A1 = np.linalg.inv(A0)</span><br><span class="line">resoult = np.dot(A1,b)</span><br><span class="line"></span><br><span class="line">x0 = -resoult[<span class="number">1</span>]/<span class="number">2</span></span><br><span class="line">y0 = -resoult[<span class="number">2</span>]/(<span class="number">2</span>*resoult[<span class="number">0</span>])</span><br><span class="line">AA = np.sqrt(x0*x0 + resoult[<span class="number">0</span>]*y0*y0 - resoult[<span class="number">3</span>])</span><br><span class="line">BB = AA/np.sqrt(resoult[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x0,y0,AA,BB)</span><br><span class="line"><span class="comment"># 生成角度值</span></span><br><span class="line">theta = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算椭圆上的点坐标</span></span><br><span class="line">x_fit = x0 + AA * np.cos(theta)</span><br><span class="line">y_fit = y0 + BB * np.sin(theta)</span><br><span class="line">plt.plot(x_fit, y_fit, color = <span class="string">&#x27;r&#x27;</span>,label=<span class="string">&#x27;fit ellipse&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Ellipse Fit&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拟合结果如下：</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231116092754.png"alt="椭圆拟合结果" /><figcaption aria-hidden="true">椭圆拟合结果</figcaption></figure><p>椭球校准推导和matlab代码见参考资料<ahref="#refer-anchor-1"><sup>[3]</sup></a></p><h2 id="参考资料">参考资料</h2><div id="refer-anchor-1"></div><ol type="1"><li><ahref="https://zhuanlan.zhihu.com/p/544296512">IMU原理介绍及误差分析</a></li><li><ahref="https://www.cnblogs.com/buxiaoyi/p/7541974.html">IMU误差模型和校准</a></li><li><ahref="https://blog.csdn.net/hj199404182515/article/details/59480954">空间二次曲面数据拟合算法推导及仿真分析</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;为防止俯仰角、四元数等概念干扰主题，这里以测xy平面角度的水平尺应用为例介绍加速度传感器的误差来源与校准方法，使用两个维度便于理解，扩展到多个维度同理可得。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90/"/>
    
    
    <category term="电子信息" scheme="https://splendidwave.github.io/tags/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>I2C详解--以51单片机和MMA8451Q为例</title>
    <link href="https://splendidwave.github.io/2023/08/05/2023-8/I2C%E8%AF%A6%E8%A7%A3/"/>
    <id>https://splendidwave.github.io/2023/08/05/2023-8/I2C%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-05T01:15:11.000Z</published>
    <updated>2023-08-05T01:17:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>I2C(Inter－IntegratedCircuit)是由NXP(恩智浦)半导体开发的一种简单的双向两线制总线协议标准。它作为电子行业中最常见的串行通讯协议，虽然书面可以写成I2C，但实际它实际写法是<spanclass="math inline">\(I^2C\)</span> 读作[I fang C]。</p><p>它只需要2个引脚--SDA（双向数据线）和SCL(时钟线)，就可以完成芯片间的通信，这种便捷的应答机制的提出让微控制器，电源、显示、传感器等芯片间能够简单快速的互联互通。</p><p>本文详细介绍了I2C的几种传输信号，并以51架构的芯片和三轴加速度传感器为例提供了一套模拟I2C的解决方案。</p><span id="more"></span><h2 id="i2c协议">1.I2C协议</h2><p>参考<a href="https://zhuanlan.zhihu.com/p/362287272">知乎文章一文看懂I2C协议</a></p><p>I2C协议可以工作在以下5种速率模式下，不同的器件可能支持不同的速率。</p><ul><li>标准模式(Standard)：100kbps</li><li>快速模式(Fast)：400kbps</li><li>快速模式+(Fast-Plus)：1Mbps</li><li>高速模式(High-speed)：3.4Mbps</li><li>超快模式(Ultra-Fast)：5Mbps（单向传输）</li></ul><p>对于I2C协议来说其实只有非常基础的几种信号：起始、停止、数据、应答和非应答信号。</p><ol type="1"><li><p>起始信号：I2C协议规定，SCL处于高电平时，SDA由高到低变化，这种信号是<strong>起始信号</strong>。</p></li><li><p>停止信号：SCL处于高电平，SDA由低到高变化，这种信号是<strong>停止信号</strong>。</p></li><li><p>数据信号：I2C协议对数据的采样发生在SCL高电平期间，除了起始和停止信号，在数据传输期间，SCL为高电平时，SDA必须保持稳定，不允许改变，在SCL低电平时才可以进行变化。而且一次允许传输的是1个字节的数据量。</p></li><li><p>应答信号：应答信号出现在1个字节传输完成之后，即第9个SCL时钟周期内，此时主机需要释放SDA总线，把总线控制权交给从机，由于上拉电阻的作用，此时总线为高电平，如果从机正确的收到了主机发来的数据，会把SDA拉低，表示应答响应。</p></li><li><p>非应答信号：当第9个SCL时钟周期时，SDA保持高电平，表示非应答信号，通常在读到数据时不需要从机回应，主机可以不放开总线控制权。</p></li></ol><h2 id="i2c读写时序图阅读">2.I2C读写时序图阅读</h2><p>在芯片手册中通常可以找到芯片的I2C时序图，下面以MMA8451Q为例，其时序图如下</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/08/20230805091314.png"alt="MMA8451Q时序图" /><figcaption aria-hidden="true">MMA8451Q时序图</figcaption></figure><p>左上角的“&lt;&gt;”中代表着是想要进行的操作，如single-byteread，意思是进行单字节读取。下面的master和slave分别代表主机需要进行的操作和从机需要进行的操作。这里主机指的是主控芯片，从机指的是MMA8451Q。</p><p>如果想要从从机这读取单个数据，主机需要先发送一个ST + device address +w，即发送一个起始信号+设备地址数据信号+写信号，其中地址信号是7位的，写信号是1位，加起来就是一个字节的数据信号。随后主机放开控制权，从机会返回一个应答信号，表示通信正常。然后主机将需要读取的寄存器信号地址发送给从机，再收到一个应答，这时候主机需要再发送一个起始信号+设备地址信号+读信号，从机在发送应答后会发送数据给主机，这时候主机收到信号不需要应答，发送一个停止信号即可。</p><p>这就是一个完整的读取信息通信过程。</p><h2 id="i2c读写程序编写">3.I2C读写程序编写</h2><p>在使用单片机时，通常芯片厂商会配置好硬件I2C，只需要根据例程修改即可使用。但有时可能会出现硬件功能无法正常使用等情况。同时为了更好的了解I2C协议，这里使用模拟I2C来实现通信。</p><p>首先需要在硬件原理图中找到I2C通信的两个端口，并将它们初始化为开漏输出模式，注意硬件部分的端口需要加一个上拉电阻，否则无法输出高电平。</p><p>为了方便起见，这里使用宏定义将引脚换个名字，我以51架构芯片的P44和P45脚为例，这里请根据自己的主控芯片和硬件原理图进行修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define I2C_SDA P45</span><br><span class="line">#define I2C_SCL P44</span><br></pre></td></tr></table></figure><p>MMA8451的读写地址和寄存器位置也可以在芯片手册中找到。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define  MMA8451Q_WRITE    0x38/*Write Cmd*/</span><br><span class="line">#define  MMA8451Q_READ          0x39     /*Read  Cmd*/</span><br><span class="line"></span><br><span class="line">#define MMA8451Q_CTRL_REG1      0x2A        /*control registers*/</span><br><span class="line">#define MMA8451Q_CTRL_REG2      0x2B</span><br><span class="line">#define MMA8451Q_WHO_AM_I       0x0D</span><br></pre></td></tr></table></figure></p><p>下面是示例代码，注意要根据主控芯片和传感器自行修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">/*****************************************************************************</span><br><span class="line"> ** \brief I2C_Delay</span><br><span class="line"> ** \param </span><br><span class="line"> **            </span><br><span class="line"> ** \return  </span><br><span class="line"> ** \note  </span><br><span class="line"> *****************************************************************************/</span><br><span class="line">static void I2C_Delay(void)</span><br><span class="line">&#123;</span><br><span class="line">uint16_t i;</span><br><span class="line">for(i=0;i&lt;1;i++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*****************************************************************************</span><br><span class="line"> ** \brief I2C_Start</span><br><span class="line"> ** \param </span><br><span class="line"> **            </span><br><span class="line"> ** \return  </span><br><span class="line"> ** \note  </span><br><span class="line"> *****************************************************************************/</span><br><span class="line">void I2C_Start(void)&#123;</span><br><span class="line">I2C_SDA=1;</span><br><span class="line">I2C_SCL=1;</span><br><span class="line">I2C_Delay();</span><br><span class="line">I2C_SDA=0;</span><br><span class="line">I2C_Delay();</span><br><span class="line">I2C_SCL=0;</span><br><span class="line">I2C_Delay();</span><br><span class="line">&#125;</span><br><span class="line">/*****************************************************************************</span><br><span class="line"> ** \brief I2C_Stop</span><br><span class="line"> ** \param </span><br><span class="line"> **            </span><br><span class="line"> ** \return  </span><br><span class="line"> ** \note  </span><br><span class="line"> *****************************************************************************/</span><br><span class="line">void I2C_Stop(void)&#123;</span><br><span class="line">I2C_SDA=0;</span><br><span class="line">I2C_SCL=1;</span><br><span class="line">I2C_Delay();</span><br><span class="line">I2C_SDA=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*****************************************************************************</span><br><span class="line"> ** \brief I2C_ReadAck</span><br><span class="line"> ** \param </span><br><span class="line"> **            </span><br><span class="line"> ** \return  </span><br><span class="line"> ** \note  </span><br><span class="line"> *****************************************************************************/</span><br><span class="line">bit I2C_ReadAck()//主机接收应答</span><br><span class="line">&#123;</span><br><span class="line">bit ack=0;</span><br><span class="line">I2C_SDA=1;//释放总线</span><br><span class="line">I2C_Delay();</span><br><span class="line">I2C_SCL=1;</span><br><span class="line">I2C_Delay();</span><br><span class="line">ack=I2C_SDA;</span><br><span class="line">I2C_SCL=0;</span><br><span class="line"></span><br><span class="line">return ack;</span><br><span class="line">&#125;</span><br><span class="line">/*****************************************************************************</span><br><span class="line"> ** \brief I2C_Sendbyte(u8 byte)</span><br><span class="line"> ** \param </span><br><span class="line"> **            </span><br><span class="line"> ** \return  </span><br><span class="line"> ** \note  I2C总线主机发送一个字节数据</span><br><span class="line"> *****************************************************************************/</span><br><span class="line">void I2C_Sendbyte(u8 byte)//主机发送一个字节的数据</span><br><span class="line">&#123;</span><br><span class="line">u8 i=0;</span><br><span class="line">I2C_Delay();</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">I2C_SDA=byte&amp;(0x80&gt;&gt;i);</span><br><span class="line">I2C_Delay();</span><br><span class="line">I2C_SCL=1;</span><br><span class="line">I2C_Delay();</span><br><span class="line">I2C_SCL=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*****************************************************************************</span><br><span class="line"> ** \brief I2C_Readbyte</span><br><span class="line"> ** \param   </span><br><span class="line"> **            </span><br><span class="line"> ** \return  </span><br><span class="line"> ** \note  I2C总线主机接收一个字节数据</span><br><span class="line"> *****************************************************************************/</span><br><span class="line">u8 I2C_Readbyte()//主机接收一个字节数据</span><br><span class="line">&#123;</span><br><span class="line">u8 i;</span><br><span class="line">u8 byte=0;</span><br><span class="line">I2C_SDA = 1;//释放总线</span><br><span class="line"></span><br><span class="line">P4TRIS &amp;= ~(0x20);//设置为输入模式</span><br><span class="line"></span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">I2C_SCL = 1;</span><br><span class="line">I2C_Delay();</span><br><span class="line">byte &lt;&lt;= 1;</span><br><span class="line">//读取I2C_SDA上的数据</span><br><span class="line">if(I2C_SDA)&#123;</span><br><span class="line">byte++;</span><br><span class="line">&#125;</span><br><span class="line">I2C_SCL=0;</span><br><span class="line">I2C_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P4TRIS |= 0x20; //改回输出模式</span><br><span class="line">P4OD |= 0x20;   //改为开漏输出</span><br><span class="line"></span><br><span class="line">return byte;</span><br><span class="line">&#125;</span><br><span class="line">/*****************************************************************************</span><br><span class="line"> ** \brief MMA8451Q_write_byte</span><br><span class="line"> ** \param   addr地址 byte数据</span><br><span class="line"> **            </span><br><span class="line"> ** \return  </span><br><span class="line"> ** \note  写入一个字节数据</span><br><span class="line"> *****************************************************************************/</span><br><span class="line">void MMA8451Q_write_byte(u8 addr, u8 byte)</span><br><span class="line">&#123;</span><br><span class="line">bit ack=0;</span><br><span class="line">I2C_Start();</span><br><span class="line">I2C_Sendbyte(MMA8451Q_WRITE);</span><br><span class="line">ack=I2C_ReadAck();</span><br><span class="line">I2C_Sendbyte(addr);</span><br><span class="line">ack=I2C_ReadAck();</span><br><span class="line">I2C_Sendbyte(byte);</span><br><span class="line">ack=I2C_ReadAck();</span><br><span class="line">I2C_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*****************************************************************************</span><br><span class="line"> ** \brief MMA8451Q_read_byte</span><br><span class="line"> ** \param   addr地址 byte数据</span><br><span class="line"> **            </span><br><span class="line"> ** \return  </span><br><span class="line"> ** \note  读取一个字节数据</span><br><span class="line"> *****************************************************************************/</span><br><span class="line">u8 MMA8451Q_read_byte(u8 addr)</span><br><span class="line">&#123;</span><br><span class="line">u8 byte=0;</span><br><span class="line">bit ack=0;</span><br><span class="line">u8 i=0;</span><br><span class="line">I2C_Start();</span><br><span class="line">I2C_Sendbyte(MMA8451Q_WRITE);</span><br><span class="line">ack = I2C_ReadAck();</span><br><span class="line">I2C_Sendbyte(addr);</span><br><span class="line">ack = I2C_ReadAck();</span><br><span class="line">I2C_Delay();</span><br><span class="line">I2C_Start();</span><br><span class="line">I2C_Sendbyte(MMA8451Q_READ);</span><br><span class="line">ack=I2C_ReadAck();</span><br><span class="line">byte=I2C_Readbyte();</span><br><span class="line">I2C_Stop();</span><br><span class="line">return byte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完后可以读取传感器中的只读寄存器进行测试。比如WHO_AM_I寄存器，其他传感器要自行查询芯片手册。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;I2C(Inter－Integrated
Circuit)是由NXP(恩智浦)半导体开发的一种简单的双向两线制总线协议标准。它作为电子行业中最常见的串行通讯协议，虽然书面可以写成I2C，但实际它实际写法是&lt;span
class=&quot;math inline&quot;&gt;\(I^2C\)&lt;/span&gt; 读作[I fang C]。&lt;/p&gt;
&lt;p&gt;它只需要2个引脚--SDA（双向数据线）和SCL(时钟线)，就可以完成芯片间的通信，这种便捷的应答机制的提出让微控制器，电源、显示、传感器等芯片间能够简单快速的互联互通。&lt;/p&gt;
&lt;p&gt;本文详细介绍了I2C的几种传输信号，并以51架构的芯片和三轴加速度传感器为例提供了一套模拟I2C的解决方案。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90/"/>
    
    
    <category term="电子信息" scheme="https://splendidwave.github.io/tags/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>SEGGER Embedded Studio 安装及新建工程</title>
    <link href="https://splendidwave.github.io/2023/06/18/2023-6/SEGGER%20Embedded%20Studio%20%E5%AE%89%E8%A3%85%E5%8F%8A%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/"/>
    <id>https://splendidwave.github.io/2023/06/18/2023-6/SEGGER%20Embedded%20Studio%20%E5%AE%89%E8%A3%85%E5%8F%8A%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/</id>
    <published>2023-06-18T05:54:11.000Z</published>
    <updated>2023-08-05T01:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>SEGGER Embedded Studio(SES)是一个集成开发环境（IDE），是SEGGERMicrocontroller公司开发出来专门用于嵌入式系统开发使用的。值得一提的是J-Link也是segger公司开发的。SES提供了一套全面的工具和功能，以便于嵌入式系统的开发过程，并且对目前来说使用SES学习和评估都是免费的。</p><p>过程参考网络资料以及官方手册<ahref="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/non-image/EmbeddedStudio_ARM_v730_manual.pdf">EmbeddedStudio for ARM Reference Manual Version: 7.30</a></p><span id="more"></span><h2 id="安装">1.安装</h2><p>下载地址：<ahref="https://www.segger.cn/downloads/embedded-studio/">Embedded StudioDownloads</a></p><p>这里根据使用的芯片架构和电脑系统下载对应版本，这里使用的芯片是GD32F10x，是ARM架构的。系统是win10，因此选择EmbeddedStudio for ARM下的Windows。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230618144342.png"alt="下载" /><figcaption aria-hidden="true">下载</figcaption></figure><p>安装流程比较简单，双击安装包启动后只需要修改一下安装路径，一直点next就行。</p><h2 id="界面简介">2.界面简介</h2><p>进去之后选accept，可以看见如下图的画面，图中将几个分区用不同颜色的选框标记出来了。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230618200117.png"alt="SES界面" /><figcaption aria-hidden="true">SES界面</figcaption></figure><p>如果没有工具栏，可以在菜单栏中的veiw中开启。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230618201815.png"alt="开启工具栏" /><figcaption aria-hidden="true">开启工具栏</figcaption></figure><p>点击菜单栏的Target选择连接模拟器，再点击工具栏第一个按钮或者使用菜单栏的debug就会进入debug状态，会出现调试器窗口和输出窗口。调试例子就会出现如下现象。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230618202320.png"alt="模拟debug" /><figcaption aria-hidden="true">模拟debug</figcaption></figure><h2 id="新建工程">3.新建工程</h2><p>点击菜单栏 file-&gt; newProject创建项目，在弹出的窗口中选择新建solution，一般一个solution可以挂多个project。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230618202559.png"alt="选择新建项目" /><figcaption aria-hidden="true">选择新建项目</figcaption></figure><p>这里需要先下载一下板子所需的支持包。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230618203040.png"alt="下载板子支持包" /><figcaption aria-hidden="true">下载板子支持包</figcaption></figure><p>这里以gd32f10x为例</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230618203438.png"alt="gd32f10x" /><figcaption aria-hidden="true">gd32f10x</figcaption></figure><p>如果下载失败也可以在菜单栏 Tools -&gt; packageManage中再次查找下载，在Show InstalledPackages中可以查看下好的支持包。</p><p>随后回到上一步，选择第一个</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230618204137.png"alt="创建" /><figcaption aria-hidden="true">创建</figcaption></figure><p>详细的配置先不用管，一路默认就行。创建完可以成功build和debug就算成功。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;SEGGER Embedded Studio(SES)是一个集成开发环境（IDE），是SEGGER
Microcontroller公司开发出来专门用于嵌入式系统开发使用的。值得一提的是J-Link也是segger公司开发的。SES提供了一套全面的工具和功能，以便于嵌入式系统的开发过程，并且对目前来说使用SES学习和评估都是免费的。&lt;/p&gt;
&lt;p&gt;过程参考网络资料以及官方手册&lt;a
href=&quot;https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/non-image/EmbeddedStudio_ARM_v730_manual.pdf&quot;&gt;Embedded
Studio for ARM Reference Manual Version: 7.30&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90/"/>
    
    
    <category term="电子信息" scheme="https://splendidwave.github.io/tags/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>信号与系统(1)--信号与系统</title>
    <link href="https://splendidwave.github.io/2023/05/26/2023-5/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F(1)--%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"/>
    <id>https://splendidwave.github.io/2023/05/26/2023-5/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F(1)--%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-05-26T08:42:01.000Z</published>
    <updated>2024-06-05T13:57:01.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>信号与系统是电子信息类的专业基础课程，本系列将奥本海姆的《信号与系统》一书，系统地复习该课程。本篇将介绍什么是信号，什么是系统。</p><span id="more"></span><h2 id="信号">1.信号</h2><h3 id="什么是信号">1.1 什么是信号？</h3><p>我们的大脑无时无刻不在处理神经元传来的电信号，计算机每一秒都在处理数以亿记的01信号。其中的信号是什么？它们是如何被处理的？在数学上，信号可以表示为一个或多个变量的函数，比如我们接收到了一个语音信号波形如下。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/05/20230529190945.png"alt="语音信号波形" /><figcaption aria-hidden="true">语音信号波形</figcaption></figure><p>这是一句“亮灯”的语音信号波形。这类自变量和应变量都是连续的信号被称为<strong>连续信号</strong>，相反如果一个信号的自变量或应变量是离散值，我们记其为<strong>离散信号</strong>，二者差异可见下图。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230601143053.png"alt="连续信号和离散信号" /><figcaption aria-hidden="true">连续信号和离散信号</figcaption></figure><p>为了区分连续信号和离散信号，我们做出如下约定自变量如果是连续时间，我们记为t，信号函数记为<spanclass="math inline">\(x(t)\)</span>。如果是离散时间则记为n，信号函数记为<spanclass="math inline">\(x[n]\)</span>。</p><h3 id="信号的变换">1.2 信号的变换</h3><p>借助数学形式，我们可以将很多时间为自变量的信号都函数化，这样一些函数的性质也可以作用于信号上。一种非常简单但同时很重要的变化例子就是<strong>时移</strong>(timeshift)。在不同位置的接收机收到发射机的信号会因距离不等而造成传播时间上的差别，这就可以使用时移变化来描述。</p><p>第二种典型的自变量变化就是<strong>时间反转</strong>(timereversal)，常见的处理过程就是倒放，另一种处理方法是倍速，对应了<strong>时间尺度变化</strong>(timescaling)。</p><p>综合上述几种变化，对应到数学函数上无非就是<spanclass="math inline">\(x(t)\)</span>--&gt;<spanclass="math inline">\(x(\alpha t +\beta)\)</span>。这里变化并不复杂，就不给出具体实例了，需要熟练掌握的可以翻看任意教材的信号变化部分习题。</p><h3 id="奇偶与周期">1.3 奇偶与周期</h3><p>函数具有奇偶性，如果一个信号以原点为轴反转后不变，就称其为<strong>偶</strong>(even)信号。<span class="math display">\[x(-t) = x(t)\]</span> 如果是 <span class="math display">\[x(-t)=-x(t)\]</span> 则称其为<strong>奇</strong>(odd)信号。</p><p>一个重要的事实是，任何信号都可以看作是一个奇信号和一个偶信号的和。<span class="math display">\[\begin{align}Ev\left \{  x(t) \right \} = \frac{1}{2}[x(t)+x(-t)] \nonumber \\Od\left \{ x(t) \right \} = \frac{1}{2}[x(t)-x(-t)]\nonumber\end{align}\]</span></p><p><strong>周期</strong>(periodic)信号也是一种非常常见的信号，对于一个周期连续时间信号有:</p><p><span class="math display">\[x(t) = x(t+T)\]</span></p><p>其周期为T。如果对于任意的t和任意的整数m都有<spanclass="math inline">\(x(t)=x(t+mT)\)</span>则使式成立的最小正值T称为<spanclass="math inline">\(x(t)\)</span>的<strong>基波周期</strong>(fundamentalperiod)。</p><h3 id="三角函数与指数">1.4 三角函数与指数</h3><p><strong>正弦信号</strong>(sinusoidalsignal)是一种非常典型的信号，其数学表达式为: <spanclass="math display">\[x(t)=A\cos{(\omega_0 t + \phi)}\]</span></p><p>其中通常使用秒作为t的单位，则<spanclass="math inline">\(\phi\)</span>的单位为弧度(rad),<spanclass="math inline">\(\omega_0\)</span>的单位就是rad/s。</p><p>根据欧拉公式，正弦信号可以用<strong>复指数信号</strong>(complexexponential signal)来表示</p><p><span class="math display">\[A \cos{(\omega_0 t + \phi)}=\frac{A}{2}e^{j\phi}e^{j\omega_0t} +\frac{A}{2}e^{-j\phi}e^{-j\omega_0t}\]</span></p><p><span class="math display">\[\begin{aligned}A\cos(\omega_0t+\phi) &amp; = ARe\{ e^{j(\omega_0t+\phi)}\} \\A\sin(\omega_0t+\phi) &amp; = AIm\{ e^{j(\omega_0t+\phi)}\}\end{aligned}\]</span> 其中<span class="math inline">\(Re\)</span>和<spanclass="math inline">\(Im\)</span>分别是取实部和取虚部。</p><h3 id="能量与功率">1.5 能量与功率</h3><p>数学函数可以表示信号，但信号只有结合物理才有实际意义，电信号是常见的信号，例如，设<spanclass="math inline">\(v(t)\)</span>和<spanclass="math inline">\(i(t)\)</span>分别是阻值为R的电阻上的电压和电流信号，那么其瞬时功率就是：</p><p><span class="math display">\[p(t)=v(t)i(t)=\frac{1}{R}v^2(t)\]</span></p><p>在时间<spanclass="math inline">\([t_1,t_2]\)</span>间消耗的总能量为<spanclass="math inline">\(\int_{t_1}^{t_2}p(t)dt\)</span>,其<strong>平均功率</strong>(averagepower)为:</p><p><span class="math display">\[\frac{1}{t_2-t_1}\int_{t_1}^{t_2}p(t)dt=  \frac{1}{t_2-t_1}\int_{t_1}^{t_2}\frac{1}{R}v^2(t)dt\]</span></p><p>根据平均功率，我们可以将信号分为三类：</p><ol type="1"><li>有限能量信号(<span class="math inline">\(E_\infty &lt;\infty\)</span>),这类信号的平均功率必须为0，否则积分后能量就会变成无穷大</li><li>有限功率信号(<span class="math inline">\(P_\infty &lt;\infty\)</span>)，这类信号能量是无穷大的，但平均功率不是。</li><li>无限功率信号，一个典型的例子是<span class="math inline">\(x(t) =t\)</span></li></ol><h3 id="单位阶跃与单位脉冲">1.6 单位阶跃与单位脉冲</h3><p>连续时间的单位阶跃函数<spanclass="math inline">\(u(t)\)</span>的定义是</p><p><span class="math display">\[u(t) =\left \{ \begin{matrix}  0, t &lt; 0\\1, t&gt;0\end{matrix}\right.\]</span></p><p>单位阶跃再<spanclass="math inline">\(t=0\)</span>点处是不连续的，对其取一次微分就得到了冲激函数<spanclass="math inline">\(\delta(t)\)</span>,这个函数在数学中是不存在的，但是在物理学中它很好用于是就被拿来用了。在工学中这个函数也是极具理论价值，但为了能实际应用，冲激函数被近似认为是非常短的时间间隔<spanclass="math inline">\(\Delta\)</span>内完成的从0到1的阶跃函数的微分。</p><p>离散时间的单位脉冲和单位阶跃序列也是同理，积分和微分分别对应求和和差分。</p><h2 id="系统">2.系统</h2><h3 id="什么是系统">2.1 什么是系统？</h3><p>在实际过程中信号仅仅是作为输入或者输出的一部分内容，信号是如何被处理的还得通过系统。通常使用如下的方式来表示连续时间的输入输出关系：</p><p><span class="math display">\[x(t) \to y(t)\]</span></p><p>同理，离散的表示符号为：</p><p><span class="math display">\[x[n] \to y[n]\]</span></p><p>还是以电路作为例子，下面是一个简单的RC电路：</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230602173436.png"alt="RC电路" /><figcaption aria-hidden="true">RC电路</figcaption></figure><p>这可以看作是一个简单的系统，其中输入电压是<spanclass="math inline">\(u_i(t)\)</span>,输出信号是<spanclass="math inline">\(u_o(t)\)</span>，根据欧姆定律有，流经电阻的电流<spanclass="math inline">\(i(t)\)</span>应当正比于电阻上的电压。</p><p><span class="math display">\[i(t) = \frac{u_i(t)-u_o(t)}{R}\]</span></p><p>同时电流还可以通过电容器上的电压变化率计算得到：</p><p><span class="math display">\[i(t) = C\frac{du_o(t)}{dt}\]</span></p><p>联立两式即可得到输入输出的微分关系方程</p><p><span class="math display">\[\frac{du_o(t)}{dt} +\frac{1}{RC}u_o(t) = \frac{1}{RC} v_i(t)\]</span></p><p>这是一个非常常见的系统，同时也是一个简单的一阶线性微分方程，这样一来系统也数学化了，系统代表了一个方程或者等式。</p><h3 id="系统的互联">2.2 系统的互联</h3><p>很多实践中的系统其实都是非常简单的系统组合而成，常见的组合方法有<strong>串联</strong>(seriesinterconnection)或<strong>级联</strong>(cascadeinterconnection)、<strong>并联</strong>(parallelinterconnection)、<strong>反馈互联</strong>(feedbackinterconnection)。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230607145902.png"alt="互联" /><figcaption aria-hidden="true">互联</figcaption></figure><p>虽然图像表示得已经很清楚了，这里还是需要补充一些。</p><p>级联通常发生在对信号连续处理的过程，比如收音机收到信号后进行解调后通过放大器放大信号。反馈也是一个重要的系统类型，比如在定速巡航中，汽车会通过监控车速来控制能量的传递，而车速快慢是由发动机提供的能量决定的。</p><p>最后这三种互联方式也可以进行彼此间组合形成更复杂的系统。</p><h3 id="系统的性质">2.3 系统的性质</h3><h4 id="记忆性">2.3.1 记忆性</h4><p>如果系统的输出仅仅取决于该时刻的输入，该系统就被称为<strong>无记忆(memoryless)系统</strong>，一个简单的例子就是<strong>恒等系统(identitiysystem)</strong>,该系统的输出就等于输入。</p><p>一个典型的有记忆系统就是积分器，或者对应离散信号的<strong>累加器(accumulator)</strong>。在实际中，使用储能元件，如电容，就可以实现这一系统。又记忆系统不仅包括存储过去信息，存储将来信息也算是有记忆系统。</p><h4 id="可逆性">2.3.2 可逆性</h4><p>一个系统如果在不同输入下会产生不同输出，该系统就是<strong>可逆的(invertible)</strong>,它就会有一个对应<strong>逆系统(inversesystem)</strong>,当原系统和逆系统进行级联后，输入就会等于输出，系统就变成了一个恒等系统。</p><p>不可逆系统的不同输入可能会对应同一种输出，比如说<spanclass="math inline">\(y(t)=x^2(t)\)</span>。</p><h4 id="因果性">2.3.3 因果性</h4><p>如果一个系统在任何时刻的输出只取决于现在的输入和过去的输入，该系统就被称为<strong>因果(causal)</strong>系统。因果系统是无法根据输出预测未来的输入值的，且对于一个因果系统两个输入直到某一时间都是相同的，那其输出必然相同。</p><p>时间相关的现实系统几乎都是因果的，但对于一些数据处理系统，它并不局限于因果，比如图像处理中的窗口平滑系统。</p><h4 id="稳定性">2.3.4 稳定性</h4><p><strong>稳定性(stability)</strong>是指系统在很小的输入下响应不会发散。如单摆、RC电路中，能量会逐渐消耗并趋向于稳定。而对于不稳定系统，其输出会不断增加，想要判别系统是不稳定系统就学要找出一个特定的有界的输入使得输出无界。</p><h4 id="线性">2.3.5 线性</h4><p>线性系统的一个重要特征就是<strong>叠加性质(superpositionproperty)</strong>，叠加性说的是：如果系统的输入是几个信号的加权和组成，那么输出信号也是每一个输入信号通过系统后的输出加权和。</p><p>用公式表示，简记小写字母为输入，大写字母为系统的对应输出,系统为函数f，输入为a时输出为<spanclass="math inline">\(A=f(a)\)</span>。</p><p>对于系统有，当<span class="math inline">\(a=b+c+d\)</span>时，<spanclass="math inline">\(A=f(b)+f(c)+f(d)=B+C+D\)</span>。这被称为<strong>可加性(additivity)</strong>。还是这个系统，<spanclass="math inline">\(k_1\)</span>是一个常数，当输入<spanclass="math inline">\(k_1a\)</span>时，输出<spanclass="math inline">\(A=k_1f(a)\)</span>。这被称为<strong>齐次性(homogeneity)</strong></p><h4 id="时不变性">2.3.6 时不变性</h4><p>通俗来说，只要系统的特性和行为不随时间改变，这个系统就是时不变的。今天研发出的系统到了明天性质就变了，那我们就失去了研发的意义，因此时不变性也是非常重要的一个性质。在实际生活中线性时不变系统是最为常用的一种系统。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;信号与系统是电子信息类的专业基础课程，本系列将奥本海姆的《信号与系统》一书，系统地复习该课程。本篇将介绍什么是信号，什么是系统。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90/"/>
    
    
    <category term="电子信息" scheme="https://splendidwave.github.io/tags/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    <category term="信号与系统" scheme="https://splendidwave.github.io/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>电动汽车选配指南--以比亚迪为例</title>
    <link href="https://splendidwave.github.io/2023/04/28/2023-4/%E7%94%B5%E5%8A%A8%E6%B1%BD%E8%BD%A6%E9%80%89%E9%85%8D%E6%8C%87%E5%8D%97--%E4%BB%A5%E6%AF%94%E4%BA%9A%E8%BF%AA%E4%B8%BA%E4%BE%8B/"/>
    <id>https://splendidwave.github.io/2023/04/28/2023-4/%E7%94%B5%E5%8A%A8%E6%B1%BD%E8%BD%A6%E9%80%89%E9%85%8D%E6%8C%87%E5%8D%97--%E4%BB%A5%E6%AF%94%E4%BA%9A%E8%BF%AA%E4%B8%BA%E4%BE%8B/</id>
    <published>2023-04-28T08:57:01.000Z</published>
    <updated>2023-05-05T12:16:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>随着清洁能源技术的不断进步和国家政策的推动，越来越多的年轻用户选择科技感更强的电动汽车。比起以往的燃油车，电动汽车更像是一种能够移动的电子设备，其日新月异的新技术也使得许多老车主纷纷表示被“背刺”了。本文将以科普的角度，简要介绍电动汽车的分类、结构。并以比亚迪的汉EV千山翠限量版和宋PLUSDM-i为例介绍展开介绍。</p><p>注：本文主要介绍汽车的一些原理和名词解释，并拿了市面上销量较好的比亚迪举例子，并无消费导向，大家根据实际需求购买（除非byd给我打广告费）。</p><span id="more"></span><h2 id="明确需求">1.明确需求</h2><h3 id="电动车和燃油车的区别">1.1 电动车和燃油车的区别</h3><p>目前选购一辆代步车大部分人会在燃油车和新能源车中纠结一下。为此需要了解两者的异同才能更好地做出抉择。</p><p>传统燃油车是由如下几个部分组成:</p><ul><li><strong>车身主体</strong>：汽车的车身结构大部分由高强度材料组成，起到支撑车体和保护驾驶员安全的作用。部分车型会将前后车身做得偏软，发生碰撞可以用来缓冲防止行人或他车车主受到伤害。</li><li><strong>发动机</strong>：发动机是汽车的心脏部分，它将燃油的化学能转化为机械能，驱动汽车前进，由于发动机开始工作时需要进气引导，工作过程中需要不停点火，所以燃油车会配上一块蓄电池用于提供这部分所需能量。</li><li><strong>传动装置</strong>：传动轴和齿轮将发动机产生的动力传递到车轮，从而使车辆运动，同时它可以利用齿轮组的传动比将发动机的高速低扭转化为车轮的低速高扭。由于传动杆的存在，我们可以看见车子中轴线会存在一条凸起。</li><li><strong>悬架系统</strong>：悬架又称底盘，它起到了支撑车身重量，并减缓路面的颠簸和震动，控制转弯等功能。</li><li><strong>控制系统</strong>：车子的控制主要分为机械控制和电子控制两部分，用于辅助驾驶员控制汽车，通常以方向盘、踏板、机械开关或者车机交互的方法实现。</li></ul><p>相比之下，电动汽车主要的改动点就在于采用电动机代替了发动机再搭载一块大电池，电机的效率更高更节能。它在低速状态下可以输出极大的扭矩，而且不需要排放尾气。这也是国家大力推动新能源汽车发展的重要原因之一。</p><h3 id="油电混动车型">1.2 油电混动车型</h3><p>但新能源汽车发展早期存在电池技术不成熟，充电桩寻找困难、充电速度慢等问题，再加上BBA（宝马、奔驰、奥迪）和日系合资车的社会认可度更高，导致电动车选购率低，就算是选择新能源车也会选择混动类型的。</p><p>混动类型可以分为如下三种：</p><ul><li><strong>增程式</strong>：增程式是指内燃机只负责发电，不需要考虑驱动车辆，燃油只负责增加行驶路程的功能。</li><li><strong>插电混合</strong>：插电混动是指既可以随意使用电机又可以使用发动机驱动，它解决了电池充电慢，远距离续航不足的问题，会受到更多人的青睐。</li><li><strong>油电混合</strong>：油电混动是指车子在行驶过程中同时使用电和油，它结合了电车起步快和油车行驶稳定的优势，这种类型因为还是会排放大量尾气所以通常不被上绿牌不享受新能源政策，只是相当于一个省油的油车。</li></ul><p>纯电车是完全依赖电池行驶，虽然会有里程焦虑但是电车的养护成本会比油车低很多。</p><h3 id="如何选取">1.3 如何选取</h3><p>在选购车子的时候可以根据如下3点进行判断。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/05/20230505171127.png"alt="选车" /><figcaption aria-hidden="true">选车</figcaption></figure><p>主要还是根据使用场景进行选购，决定好买油车还是电车后再结合预算要SUV、轿车、越野车还是跑车就可以将购车范围缩小到几种车，然后针对性地去4s店看车和试驾。如果对自己使用需求不明确或者对外观要求较高的，可以先去车展看看效率比较高。一般来说选择市场认可度比较高的会更有保障，真出问题了也可以联合更多人去找厂商的问题。</p><p>接下来针对一些细节结构进行展开介绍。</p><h2 id="车身尺寸">2.车身尺寸</h2><h3 id="车柱与轴距">2.1 车柱与轴距</h3><p>车身承担了兼具实用（保护驾驶员安全）和美观（车型外观）两个重要因素。下图标注了聊车身经常会提到的几个名词指代的位置，如A柱、B柱、轴距。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/04/20230425202425.png"alt="车柱" /><figcaption aria-hidden="true">车柱</figcaption></figure><p>这张图中位于上方的车就是轿车，位于下方的则是SUV。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/04/20230425202640.png"alt="轴距" /><figcaption aria-hidden="true">轴距</figcaption></figure><p>根据轴距可以将车分为如下几个类型，下表只是一个参考标准，级别没有明确的定义。</p><table><thead><tr class="header"><th>级别</th><th>定义</th><th>轴距范围</th></tr></thead><tbody><tr class="odd"><td>A0级</td><td>微型车</td><td>≤ 2,490 mm</td></tr><tr class="even"><td>A级</td><td>小型车</td><td>2,491 mm - 2,700 mm</td></tr><tr class="odd"><td>B级</td><td>中型车</td><td>2,701 mm - 2,900 mm</td></tr><tr class="even"><td>C级</td><td>大型车</td><td>≥ 2,901 mm</td></tr></tbody></table><p>轴距越大乘坐体验就会越舒适，但对司机的驾驶要求会相对提升一些，中国老百姓普遍喜欢买大一些的车，显得气派。千山翠的是轴距在2920，车长4995，属于是B和C之间，但因为它后备箱空间不是很大所以后排体验是有C级车的标准的，后座使用的是隐私玻璃，定位也是商务车的定位。宋plus轴距是2765属于是中型的SUV。</p><h3 id="车漆">2.2 车漆</h3><p>汽车的车漆是车身保护和美观的关键组成部分。通常认为原厂的车漆要比后补的更好，尤其是像千山翠这类特制车漆，会比同配置的汉EV四驱版贵上两万，同时刮蹭后补漆价格也会更高。</p><p>对于轻微刮痕通常处理方法有，不处理、车漆笔、抛光等操作，如果刮痕比较深或者涉及到较大的区域，可能需要进行磨砂和补漆处理。</p><p>车漆的保护方法有定期洗车、避免太阳直射、车衣、镀晶/镀膜等。不过我去提车的时候4S店并不推荐我加车衣，也不推荐车座垫，给了车窗膜和底盘护甲。</p><h2 id="动力系统">3.动力系统</h2><h3 id="电机类型">3.1 电机类型</h3><p>目前电机主流使用的是以特斯拉为首的交流异步电机和以比亚迪为老大的永磁同步电机。</p><p>交流异步电机(Asynchronous AC Motor, AC InductionMotor)的工作原理是通过交流电源产生的旋转磁场诱导出转子中的电流，由于转子电流在磁场作用下会产生转矩，从而驱动转子旋转。然而，由于转子电流的产生和变化需要一定的时间，因此转子的旋转速度不能完全跟随旋转磁场的频率，产生了一定的转速差，因此被称为“异步”。</p><p>永磁同步电机(Permanent Magnet Synchronous Motor,PMSM)的转子由永磁体组成，永磁体的磁场与定子磁场相互作用，从而使转子转动。为了使永磁同步电机能够稳定运行，其定子的磁场必须保持同步旋转，这需要通过控制定子的电流和频率来实现</p><p>千山翠使用的是交流永磁同步电机(Permanent Magnet Synchronous Motorwith ACDrive)。这是一种结合了永磁同步电机和交流异步电机的特点的电机。它的转子由永磁体组成，因此具有永磁同步电机的高效率、高功率密度和响应速度快的特点。同时，它的定子采用交流异步电机的设计，可以通过变频器来控制其电流和频率，从而实现精确的转速控制和调节。</p><p>宋plus是插电类型的车，使用的是比亚迪自研的骁云-插混专用发动机，相对来说技术上还是比较有优势的。</p><h3 id="电机的指标">3.2 电机的指标</h3><p>电机性能的参数通常包括以下几个方面：</p><p>额定功率和额定转速：电机额定功率和额定转速是电机性能的基本参数，通常在电机铭牌上标明。额定功率是指电机在额定转速下所能输出的最大功率，单位为千瓦（kW）；额定转速是指电机在额定电压、额定电流下所能达到的转速，单位为转每分钟（rpm）。</p><p>转矩和转速曲线：电机的转矩和转速曲线反映了电机输出功率的变化规律，也是电机性能的重要参数。转矩和转速曲线通常以图表形式表示，可以用于评估电机在不同负载下的输出能力和效率。</p><p>效率：电机的效率是指电机输出功率与输入功率之比，通常以百分比表示。电机的效率直接关系到电机的能耗和工作效率，是评估电机性能的重要指标。</p><p>功率因数：电机的功率因数是指电机输出功率与电机视在功率之比，通常以小数形式表示。功率因数反映了电机的电能利用效率，高功率因数的电机能够降低电网负荷和能耗。</p><p>但通常汽车动力性能中标注的是最大功率和最大扭矩。越大说明汽车动力越足。</p><h3 id="驱动类型">3.3 驱动类型</h3><p>驱动类型通常指汽车的动力传动方式，主要分为前驱、后驱和四驱三种类型。</p><ul><li><p><strong>前驱</strong>是指汽车动力由发动机传输到前轮驱动，通过前轮驱动车辆前部的重心提供更好的牵引力和稳定性。前驱车型通常比较节省油耗和制造成本，但在高速行驶时会出现轻微的转向不稳定和过弯时的欠稳定性。</p></li><li><p><strong>后驱</strong>是指汽车动力由发动机传输到后轮驱动，通过后轮驱动车辆后部的重心提供更好的牵引力和操控性。后驱车型通常有更好的平衡性和操控性，但在低摩擦路面上的牵引能力相对较差。</p></li><li><p><strong>四驱</strong>是指所有车轮都有动力输出，通过动力分配系统将动力传递到不同的车轮，以提供更好的牵引和操控性能。四驱车型通常适用于路况复杂、陡坡、泥泞等恶劣路况下行驶，但相对于前驱和后驱车型，制造成本和油耗较高。</p></li></ul><p>不同驱动类型的汽车有各自的优缺点，在购买时需要根据自己的需求和用途进行选择，不同类型在驾驶过程没有明显区别，但是不差钱的可以无脑四驱。</p><h3 id="续航里程">3.4 续航里程</h3><p>在国内续航里程通常是按工信部制定的国家标准进行测评，其中最常用的标准为CLTC（ChinaLight-Duty Test Cycle）。</p><p>CLTC是一种基于欧盟NEDC（New European DrivingCycle）标准进行修改和优化的测试循环。CLTC包括两个部分：低速城市循环和高速公路循环，其中低速城市循环主要测试低速、停车、加速和制动等行驶状态，高速公路循环主要测试高速巡航状态。</p><p>在CLTC标准下，电动车续航里程的测量通常是在室温（20℃~30℃）下进行，电池充满电的情况下，以模拟真实驾驶情况，按照标准测试循环进行测试，最终得出一个标准化的续航里程数值。</p><p>除了里程外还需要关注的是汽车的电车容量和充电时间，一般在高速上跑和在冬天跑都会使续航里程打折，而且一般电车不会将电全部用完，在估算续航时都需要考虑在内。</p><h2 id="制动及悬架系统">4.制动及悬架系统</h2><h3 id="制动类型">4.1 制动类型</h3><p>制动类型主要有两类，一类是盘式制动，一类是鼓式制动。</p><p>盘式制动是通过刹车片钳住制动盘来实现制动，刹车片通常会听到brembo这个牌子，这是一个意大利牌子，以其制造高品质刹车和离合器组件而闻名于世界。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/04/20230428124054.png"alt="盘式制动" /><figcaption aria-hidden="true">盘式制动</figcaption></figure><p>鼓式制动也是利用摩擦制动，不同的是它使用圆柱形的鼓式制动器来刹车，但这种方法因为散热问题，稳定性不如盘式，其复杂结构也会导致高故障率。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/04/20230428124700.png"alt="鼓式制动" /><figcaption aria-hidden="true">鼓式制动</figcaption></figure><p>主流还是盘式用的比较多，千山翠用的是比亚迪自研的通风打孔盘式，作为自己调教的刹车片，会更适合自家的车型。</p><h3 id="悬架">4.2 悬架</h3><p>悬架系统主要由弹簧、减震器、连接杆等部件组成，起到提高了车辆的稳定性和驾驶舒适性等功能。独立悬架是目前主流的悬架形式，它能够独立支撑每个车轮，提高了车辆的操控性和行驶稳定性。通常按连杆类型又可以分为如下几种：</p><ul><li>麦弗逊悬架：麦弗逊悬架适用于大多数前驱车和后驱车的前悬架，其结构简单、可靠性高、成本低，是目前最常见的悬架类型之一。但它的行程比较受限而且对侧向受力化解比较乏力。</li><li>双连杆悬架：双连杆使用了两个控制臂来支撑和控制车轮，会比麦弗逊操控性更强。</li><li>多连杆悬架：三连杆、四连杆、五连杆都统称多连杆，多连杆悬架还可以提供更高的悬挂行程和更优秀的悬架响应，但其成本和车辆重量也会随之提升。</li></ul><p>主动悬架可以根据车辆运动和路况状况实时调整悬架系统的硬度、行程和其他参数，从而提高车辆的驾驶稳定性和悬架性能。需要软件和硬件相互配合实现，比亚迪的<ahref="https://www.bilibili.com/video/BV1wv4y1H7Zv/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">云辇</a>技术就是一个典型。</p><p>千山翠使用的是千麦弗逊后多连杆，在22款的低配汉ev车型中使用的是铁制连杆，所以被网友戏称“筷子悬挂”，在23款比亚迪就将底盘换成了铝合金了。</p><h3 id="轮胎">4.3 轮胎</h3><p>汽车轮胎直接与路面接触，承受着汽车的重量和各种力量，影响着汽车的操控性能、安全性能和舒适性能。比较出名的公司就是米其林。</p><p>轮胎标注一般会提供断面宽度(指轮胎正面的宽度)、扁平比(截面高度与截面宽度的比值)、尺寸(轮胎的内径)信息。其中扁平比可以会比较难理解，通俗来说较低的扁平比通常意味着高车辆的操控性和响应速度，但可能会牺牲一些乘坐舒适性。较高的扁平比则意味着轮胎的侧壁更高，对路面的减震效果更好，但可能会降低车辆的操控性。</p><p>千山翠的轮胎规格标注是245/45R19表示这是一款断面宽度为245毫米、扁平比为45%、结构类型为径向轮胎，适合安装在直径为19英寸的轮毂上的轮胎。千山翠的轮胎是米其林和固特异混发的，两者区别倒是不是很大。</p><h2 id="控制与辅助系统">5.控制与辅助系统</h2><p>这里列一下千山翠的一些控制辅助系统，因为是比亚迪王朝系列的顶配，基本市面上有的计算都加装了，需要的可以自行搜索阅读，没需求的可以直接跳过。</p><ul><li>自适应巡航控制（Adaptive CruiseControl，ACC）：一种智能驾驶辅助系统，能够通过雷达或激光等技术实现车辆的自动跟车和自动减速，使驾驶者在高速公路等道路上行驶更加轻松和安全。</li><li>智能车距控制（Intelligent CruiseControl，ICC）：也是适应巡航控制（Adaptive CruiseControl）系统的一种，除了保持与前车的安全距离外，还可以自动减速或停车以避免追尾事故的发生，相比之下更加智能。</li><li>交通拥堵辅助系统（Traffic Jam Assist,TJA）：是一种智能驾驶辅助系统，主要用于缓解城市拥堵时的驾驶压力，提高行驶安全性。</li><li>前方碰撞预警系统（Forward Collision Warning,FCW）：是一种车辆安全辅助系统，主要用于预警驾驶员前方可能发生的碰撞风险，以避免或减轻碰撞事故的后果。</li><li>自动紧急制动系统（Automatic Emergency Braking,AEB）：是一种紧急制动系统，通常和交通标志识别系统（Camera-based TrafficSign Recognition, CCR）和行人车辆识别系统（Vulnerable RoadUsers，VRU）联合使用。</li><li>紧急制动辅助系统（Emergency Brake Assist,EBA）：是一种汽车安全辅助系统，可以帮助驾驶员在紧急制动时更快更稳地停车，从而减少事故的发生。通常与ESP（电子稳定控制系统）和ABS（防抱死制动系统），以提高车辆的稳定性和安全性。</li><li>紧急制动信号系统（Emergency Stop Signal,ESS）：是一种汽车安全辅助系统，可以在紧急制动时自动闪烁制动灯，以提醒后方车辆注意。</li><li>车道偏离警示系统（Lane Departure Warning System,LDWS）：是一种车辆安全辅助系统，用于提醒驾驶员车辆偏离了车道。</li><li>车道保持系统（Lane Keeping System,LKS）：是一种车辆安全辅助系统，可以帮助驾驶员在车辆行驶过程中保持在正确的车道内。</li><li>智能远近光灯系统（Headlamp Matrix System,HMA）:是一种基于车辆摄像头和电子控制单元的智能车灯系统。</li><li>道路交通标志识别系统（Traffic Sign Recognition System,TSR）：是一种智能驾驶辅助系统，可以自动识别道路上的交通标志并显示在驾驶员的仪表盘上，帮助驾驶员更好地了解当前行驶状态和交通规则。</li><li>高速公路辅助驾驶系统（Highway Assist,HWA）：是一种智能驾驶辅助系统，可以在高速公路上为驾驶员提供自动加速、减速、转向和车道保持等功能，从而降低驾驶员的疲劳度和驾驶风险，提高驾驶舒适性和安全性。</li><li>交互式变道辅助系统（ILCA）：是一种智能驾驶辅助系统，又称拨杆变道辅助，在车速60-130km/h范围内，开启智能领航模式下，用户只需拨动转向拨杆，系统便会在确保安全前提下自动控制车辆变道。</li><li>前方交通穿行提示系统（Front Cross Traffic Alert,FCTA）：是一种车辆安全辅助系统，可用于检测和提示车辆前方横穿路口或停车位存在车辆或行人。同理还有后方交通穿行提示（RCTA）。</li><li>紧急车道保持辅助（Emergency Lane Keeping Assist,ELKA）：是一种智能辅助驾驶系统，当汽车发生意外偏离车道后,会发出提醒并通过制动或转向等手段停入紧急车道。</li><li>盲点监测系统（Blind Spot Detection,BSD）：是一种车辆驾驶辅助系统，可以帮助驾驶员检测车辆侧后方的盲区，以便更好地掌握交通状况和避免潜在的碰撞事故。</li><li>开门预警：打开门时如果后方有来车或来人会提示。</li><li>3D全息透明影像：这个功能非常的方便，特别是过窄路和停车的时候，新手或者车感不好的人一定要配一个。</li><li>遥控驾驶：用手机app可以遥控汽车。</li></ul><h2 id="购车流程和注意事项">6.购车流程和注意事项</h2><p>看车（4s店/车展）--&gt; 试驾（需要驾驶证） --&gt;谈价格（可以留意优惠和政府补贴） --&gt; 付定金 --&gt; 提车（!）</p><p>价格方面油车可能更容易打一些，而且挑淡季去谈优惠幅度会很大。比亚迪的价格是全国统一的，没法谈，只能多要点4s店的优惠。如果选购的是新能源车，23年是免购置税的，可能还会接着延长。其次国家的新能源车补贴是没有了，但地方政府的补贴还会不定期发放。其次买车还需要上牌费和保险之类的，会比裸车价高出一些。基本上想拿到一个比较优惠的价格就多去几家4s店。</p><p>提车这里需要注意的事项会比较多。特别是车子质量要仔细检查漆面是否有问题，轮胎和玻璃型号，发动机，排气口里程数之类的。如果发现小问题可以让4S店适当补偿。然后合同上价格明细和赠送要全部备注清楚。尽量在4S店买车在流程上会更有保障，其次要等保险生效后再把车开回家。</p><p>最后祝各位都能顺利喜提爱车。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;随着清洁能源技术的不断进步和国家政策的推动，越来越多的年轻用户选择科技感更强的电动汽车。比起以往的燃油车，电动汽车更像是一种能够移动的电子设备，其日新月异的新技术也使得许多老车主纷纷表示被“背刺”了。本文将以科普的角度，简要介绍电动汽车的分类、结构。并以比亚迪的汉EV千山翠限量版和宋PLUS
DM-i为例介绍展开介绍。&lt;/p&gt;
&lt;p&gt;注：本文主要介绍汽车的一些原理和名词解释，并拿了市面上销量较好的比亚迪举例子，并无消费导向，大家根据实际需求购买（除非byd给我打广告费）。&lt;/p&gt;</summary>
    
    
    
    <category term="文化娱乐" scheme="https://splendidwave.github.io/categories/%E6%96%87%E5%8C%96%E5%A8%B1%E4%B9%90/"/>
    
    <category term="逻辑与科普" scheme="https://splendidwave.github.io/categories/%E6%96%87%E5%8C%96%E5%A8%B1%E4%B9%90/%E9%80%BB%E8%BE%91%E4%B8%8E%E7%A7%91%E6%99%AE/"/>
    
    
    <category term="科普" scheme="https://splendidwave.github.io/tags/%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>C语言复习-进阶篇</title>
    <link href="https://splendidwave.github.io/2023/04/23/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    <id>https://splendidwave.github.io/2023/04/23/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E8%BF%9B%E9%98%B6%E7%AF%87/</id>
    <published>2023-04-23T08:02:01.000Z</published>
    <updated>2023-05-05T10:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>复习一下C语言的进阶应用。</p><p>基础篇：<ahref="https://splendidwave.github.io/2023/04/22/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E5%9F%BA%E7%A1%80%E7%AF%87/">C语言复习-基础篇</a></p><span id="more"></span><h2 id="内存管理">1.内存管理</h2><p>在C语言中，程序内存可以分为代码段、数据段、堆区(stack)和栈区(heap)。</p><h3 id="代码段">1.1 代码段</h3><p>代码段也称为文本段，是存储程序代码的区域，通常是只读的，且不允许在程序运行时进行修改。在程序执行时，代码段中的指令被复制到处理器中执行。</p><h3 id="数据段">1.2 数据段</h3><p>数据段是存储静态变量和全局变量的区域，包括已初始化和未初始化的变量。已初始化的变量在编译时就被赋初值，而未初始化的变量在程序运行时会被初始化为0或空指针。数据段也是只读的，不允许在程序运行时进行修改。</p><h3 id="堆区">1.3 堆区</h3><p>堆区是程序运行时动态分配内存的区域，通过malloc、realloc等函数来申请和释放内存。堆区的大小是在程序运行时动态变化的，因此需要开发者自行管理内存的分配和释放，这种相信程序员的方法带来方便的同时也会带来风险。</p><p>堆区是由操作系统进行管理的，当申请内存时，操作系统会在堆区中分配一块连续的空间，并返回一个指向该空间的指针。释放内存时，操作系统将该空间标记为可用，并将其返回给堆区。</p><h4 id="malloc函数">1.3.1 malloc函数</h4><p>malloc函数用来动态地分配指定字节数的内存空间，如果分配成功，则返回一个指向分配内存的指针，否则返回空指针。malloc函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>其中，size_t是一个无符号整数类型，表示要分配的内存字节数。如果调用成功，则返回一个指向分配内存的指针；否则返回空指针。void类型不能定义变量但是可以定义指针，这是一个指针函数。</p><h4 id="realloc函数">1.3.2 realloc函数</h4><p>realloc函数用来重新分配内存空间的大小，可以用来扩大或缩小原有的内存空间。如果成功，则返回指向新分配内存的指针，否则返回空指针。realloc函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>其中，ptr是一个指向原有内存的指针，size是新的内存大小。如果调用成功，则返回一个指向新分配内存的指针；否则返回空指针。</p><h4 id="free函数">1.3.3 free函数</h4><p>free函数用来释放已经分配的内存空间。free函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><p>其中，ptr是指向要释放的内存空间的指针。使用free函数时需要注意，必须传递给它一个之前由malloc或realloc函数返回的指针，否则会出现内存泄漏的问题。</p><h3 id="栈区">1.4 栈区</h3><p>栈区是用于存储局部变量、函数参数和函数返回地址等信息的区域，是由编译器自动管理的。每当一个函数被调用时，该函数的参数和局部变量就会被存储在栈区中。栈区是一个先进后出的结构，当一个函数返回时，该函数的所有局部变量和参数就会被弹出栈区。栈区的大小通常是固定的，但可以通过编译器选项进行调整。</p><p>需要注意的是，堆区和栈区的内存都属于虚拟内存范畴，具体的内存分配和管理是由操作系统进行管理的。在使用堆区和栈区时，需要注意内存的使用情况和分配方式，以避免内存泄漏和野指针等问题。</p><h2 id="函数指针">2.函数指针</h2><p>函数指针是指可以存储函数地址的变量，通过函数指针，可以动态地调用不同的函数，实现程序的灵活性和可扩展性。</p><h3 id="普通函数指针">2.1 普通函数指针</h3><p>函数指针的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*fptr)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>这个函数指针可以用来存储指向接受两个 int 类型参数并返回 int类型结果的函数的地址。</p><h3 id="回调函数">2.2 回调函数</h3><p>回调函数指被传递给另一个函数，并由另一个函数在需要时调用的函数。回调函数通常用于事件处理、错误处理和异步通信等任务中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">callback</span><span class="params">(<span class="type">int</span> result)</span><span class="comment">//定义回调函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_something</span><span class="params">(<span class="type">int</span> (*fptr)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">void</span> (*callback)(<span class="type">int</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = fptr(x, y);</span><br><span class="line">    callback(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    do_something(add, <span class="number">3</span>, <span class="number">4</span>, callback);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序在主函数中，我们调用 do_something 函数，传递 add函数的地址、两个整数和回调函数的地址。do_something 函数调用 add函数，并将结果传递给回调函数。回调函数的好处在于，它可以将程序的控制权交给另一个函数，使程序更加灵活和可扩展。</p><h3 id="函数指针作为成员">2.3 函数指针作为成员</h3><p>函数指针数组是指一个数组，其中的每个元素都是一个指向函数的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*fptr_arr[<span class="number">3</span>])(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>这个函数指针数组可以用来存储指向三个不同的函数的地址，这些函数都接受两个int 类型参数并返回 int 类型结果。</p><p>另一个做法是将函数指针放入结构体中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*fptr)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> <span class="title">s</span>;</span></span><br><span class="line">    s.fptr = add;</span><br><span class="line">    <span class="type">int</span> result = s.fptr(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>my_struct 结构体包含一个指向 int 类型函数的指针fptr。在主函数中，我们将 add 函数的地址存储到结构体的 fptr成员中，然后使用结构体中的 fptr 成员调用 add 函数。</p><p>另外函数指针还可以应用于动态加载库和多态性，这部分内容可能更偏向于C++这里先不展开。</p><h2 id="多文件程序">3.多文件程序</h2><p>一个工程通常将程序代码分布在多个文件中，以便于代码的组织、维护和共享。C语言中通常包括的是头文件（.h文件）和源文件（.c 文件）。</p><p>头文件定义了函数的原型和常量等信息，供其他文件引用。通常包含#ifndef、#define 和 #endif 三个预处理指令来防止头文件被重复引用。</p><p>源文件包含函数的实现代码，多个源文件可以通过头文件来共享函数的定义，从而实现模块化的程序设计。下面给出头文件中通常包含的一些内容。</p><h3 id="标准库函数">3.1 标准库函数</h3><p>下面列举了一些C标准库中常用的函数：</p><ul><li>stdio.h：输入输出函数，包括文件操作函数、格式化输入输出函数、字符输入输出函数等。</li><li>string.h：字符串操作函数，包括字符串复制函数、字符串连接函数、字符串比较函数等。</li><li>math.h：数学函数，包括三角函数、指数函数、对数函数、幂函数等。</li><li>time.h：日期和时间函数，包括获取当前时间函数、时间格式化函数、计时函数等。</li><li>stdlib.h：常用的函数，包括动态内存分配函数、字符串转换函数、系统调用函数等。</li><li>ctype.h：字符处理函数，包括字符分类函数、字符转换函数等。</li><li>assert.h：调试宏，用于在程序中检查错误和异常情况。</li><li>errno.h：错误码定义，用于表示函数执行过程中的错误信息。</li></ul><h3 id="宏定义">3.2 宏定义</h3><p>宏定义是C语言中常用的一种预处理指令，用于在编译时将某些代码段替换为指定的文本内容。标准语法为<code>#define 宏名 替换文本</code>其中，宏名是用户自定义的宏名称，替换文本是指在编译时需要替换的文本内容。当程序中出现该宏名称时，编译器会将其替换为指定的文本内容，从而达到代码重用的效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="type">double</span> radius = <span class="number">10.0</span>;</span><br><span class="line"><span class="type">double</span> area = PI * radius * radius;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> max = MAX(a, b);</span><br></pre></td></tr></table></figure><p>宏定义并非真正意义上的函数调用，而是将代码中的某些部分替换为指定的文本内容。因此，在使用宏定义时，需要特别注意其替换内容是否合法，以及是否会产生意料之外的副作用。</p><h2 id="数据结构">4.数据结构</h2><p>这里只给出简约版提供复习用。</p><h3 id="链表">4.1 链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">// 节点数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedList</span> &#123;</span></span><br><span class="line">    Node* head;         <span class="comment">// 头结点指针</span></span><br><span class="line">    Node* tail;         <span class="comment">// 尾结点指针</span></span><br><span class="line">    <span class="type">int</span> length;         <span class="comment">// 链表长度</span></span><br><span class="line">&#125; LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(LinkedList* <span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈">4.2 栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *data; <span class="comment">// 存储栈元素的数组</span></span><br><span class="line">    <span class="type">int</span> top;   <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="type">int</span> size;  <span class="comment">// 栈的大小</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈的初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(Stack *s, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    s-&gt;data = (<span class="type">int</span> *) <span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    s-&gt;size = size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个栈可以实现动态分配内存。</p><h3 id="队">4.3 队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_QUEUE_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_QUEUE_SIZE];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(Queue *q)</span> &#123;</span><br><span class="line">    q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    q-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树">4.4 树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义二叉树节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;复习一下C语言的进阶应用。&lt;/p&gt;
&lt;p&gt;基础篇：&lt;a
href=&quot;https://splendidwave.github.io/2023/04/22/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E5%9F%BA%E7%A1%80%E7%AF%87/&quot;&gt;C语言复习-基础篇&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90/"/>
    
    
    <category term="嵌入式开发" scheme="https://splendidwave.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="C语言" scheme="https://splendidwave.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言复习-基础篇</title>
    <link href="https://splendidwave.github.io/2023/04/22/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>https://splendidwave.github.io/2023/04/22/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2023-04-22T08:02:01.000Z</published>
    <updated>2023-05-05T10:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>简单复习一下C语言。</p><p>进阶篇：<ahref="https://splendidwave.github.io/2023/04/23/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E8%BF%9B%E9%98%B6%E7%AF%87/">C语言复习-进阶篇</a></p><span id="more"></span><h2 id="c程序的构成">1.C程序的构成</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> <span class="comment">//头文件、预处理</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;      <span class="comment">//定义主函数（主函数只能有一个）</span></span><br><span class="line">  <span class="comment">//定义变量（C语言的变量要定义后才能使用）</span></span><br><span class="line">  <span class="comment">//程序主体</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello word\n&quot;</span>); <span class="comment">//输出结果（每一行结束都要有分号）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译过程：源程序(.c)--编译--&gt;目标程序(.obj)--链接--&gt;可执行程序(.exe)</p><h2 id="关键字">2.关键字</h2><p>大部分内容参考自知乎文章<ahref="https://zhuanlan.zhihu.com/p/37908790">C语言中32个关键字详解</a></p><h3 id="基本数据类型5个">2.1 基本数据类型（5个）</h3><p>注：括号内字节数指在32位arm处理器下</p><ul><li>void：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果</li><li>char：字符型类型数据，属于整型数据的一种（1个字节）</li><li>int：整型数据，通常为编译器指定的机器字长(4个字节)</li><li>float：单精度浮点型数据，属于浮点数据的一种(4个字节)</li><li>double：双精度浮点型数据，属于浮点数据的一种（8个字节）</li></ul><p>注：C中没有string类型，要使用需要头文件里定义<code>#include&lt;string.h&gt;</code>,C++里的定义是<code>#include&lt;string&gt;</code>，字符串的结尾为<code>'\0'</code></p><p>注：指针都是4个字节</p><h3 id="修饰关键字4个">2.2 修饰关键字（4个）</h3><ul><li>short：修饰int，短整型数据，可省略被修饰的int（2个字节）</li><li>long：修饰int，长整形数据，可省略被修饰的int（4个字节 long long8个字节）</li><li>signed：修饰整型数据，有符号数据类型</li><li>unsigned：修饰整型数据，无符号数据类型</li></ul><h3 id="复杂类型关键字5个">2.3 复杂类型关键字（5个）</h3><ul><li>struct：结构体声明 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义数据类型，一些类型集合组成的一个类型</span></span><br><span class="line"><span class="comment">//语法   struct 类型名称  &#123;成员列表&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//分数</span></span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;s3;</span><br></pre></td></tr></table></figure></li><li>union：共用体声明 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个联合变量（共用体）的长度等于各成员中最长的长度</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">StateMachine</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> character;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="type">char</span> *str;</span><br><span class="line"><span class="type">double</span> <span class="built_in">exp</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//StateMachine 的空间大小就是double 数据类型的大小</span></span><br><span class="line"><span class="comment">//在C++里，union 的成员默认属性页为public。</span></span><br><span class="line"><span class="comment">//union 主要用来压缩空间。如果一些数据不可能在同一时间同时被用到，则可以使用union。</span></span><br><span class="line"><span class="comment">//一种常见的手法是使用union判断存储方式是大端还是小端。</span></span><br></pre></td></tr></table></figure></li><li>enum：枚举声明 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">season</span> &#123;</span> spring, summer, autumn, winter &#125;;</span><br><span class="line"><span class="comment">//默认情况下spring为0，summer为1，依此类推。也可以自行赋值</span></span><br><span class="line"><span class="comment">//可以默认安排值，主要是阅读方便</span></span><br></pre></td></tr></table></figure></li><li>typedef：声明类型别名</li><li>sizeof：得到特定类型或特定类型变量的大小</li></ul><h3 id="存储级别关键字6个">2.4 存储级别关键字（6个）</h3><ul><li>auto：指定为自动变量，由编译器自动分配及释放。通常在栈上分配</li><li>static：指定为静态变量，分配在静态变量区。修饰函数时，指定函数作用域为文件内部。</li><li>register：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数</li><li>extern：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的对象的一个“引用”</li><li>const：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//在防御性编程中可以多用const</span><br></pre></td></tr></table></figure></li><li>volatile：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//volatile通常用于如下三种情况</span><br><span class="line">//1.程序使用RTOS，多线程中都会读写的全局变量</span><br><span class="line">//2.中断和主函数中都要读写的全局变量</span><br><span class="line">//3.单片机的寄存器定义</span><br></pre></td></tr></table></figure></li></ul><h3 id="跳转结构关键字4个">2.5 跳转结构关键字（4个）</h3><ul><li>return：用在函数体中，返回特定值（或者是void值，即不返回值）</li><li>continue：结束当前循环，开始下一轮循环</li><li>break：跳出当前循环或switch结构</li><li>goto：无条件跳转语句</li></ul><h3 id="分支结构关键字5个">2.6 分支结构关键字（5个）</h3><ul><li>if：条件语句</li><li>else：条件语句否定分支（与if连用）</li><li>switch：开关语句（多重分支语句）</li><li>case：开关语句中的分支标记</li><li>default：开关语句中的“其他”分治，可选</li></ul><h3 id="循环结构关键字3个">2.7 循环结构关键字（3个）</h3><ul><li>for：for(1;2;3)4;的执行顺序为1-&gt;2-&gt;4-&gt;3-&gt;2...循环，其中2为循环条件</li><li>do：do 1 while(2);的执行顺序是1-&gt;2-&gt;1...循环，2为循环条件</li><li>while：while(1) 2;的执行顺序是1-&gt;2-&gt;1...循环，1为循环条件</li></ul><h2 id="输入输出">3.输入输出</h2><h3 id="转义字符表">3.1 转义字符表</h3><table><thead><tr class="header"><th>转义字符</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>\'</code></td><td>单引号</td></tr><tr class="even"><td><code>\"</code></td><td>双引号</td></tr><tr class="odd"><td><code>\\</code></td><td>反斜杠</td></tr><tr class="even"><td><code>\n</code></td><td>换行符</td></tr><tr class="odd"><td><code>\r</code></td><td>回车符</td></tr><tr class="even"><td><code>\t</code></td><td>制表符</td></tr><tr class="odd"><td><code>\b</code></td><td>退格符</td></tr><tr class="even"><td><code>\f</code></td><td>换页符</td></tr><tr class="odd"><td><code>\v</code></td><td>垂直制表符</td></tr><tr class="even"><td><code>\a</code></td><td>响铃符</td></tr><tr class="odd"><td><code>\0</code></td><td>空字符</td></tr></tbody></table><h3 id="printf函数">3.2 printf()函数</h3><p>这个函数用于将格式化的字符串输出到标准输出流（通常是终端）。printf()函数的常见用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!&quot;</span>);  <span class="comment">// 输出简单的字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My age is %d&quot;</span>, age);  <span class="comment">// 输出格式化的字符串</span></span><br></pre></td></tr></table></figure><p>其中，%d是一个占位符，用于表示将要输出的变量的数据类型。例如，上面的代码中，%d表示将要输出一个整数类型的变量age。</p><p>下面是类型符号及其含义 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%d - 整型格式说明符，用于输出整数值。</span><br><span class="line">%f - 浮点型格式说明符，用于输出浮点数值。</span><br><span class="line">%c - 字符型格式说明符，用于输出单个字符。</span><br><span class="line">%s - 字符串格式说明符，用于输出字符串值。</span><br><span class="line">%p - 指针型格式说明符，用于输出内存地址。</span><br><span class="line">%x 或 %X - 十六进制格式说明符，用于以十六进制格式输出整数值。</span><br><span class="line">%o - 八进制格式说明符，用于以八进制格式输出整数值。</span><br><span class="line">%e 或 %E - 科学计数法格式说明符，用于以科学计数法格式输出浮点数值。</span><br><span class="line">%g 或 %G - 自动格式说明符，根据输出变量的大小决定使用 %f 或 %e 格式。</span><br></pre></td></tr></table></figure></p><p>通过在百分号后面加指令可以控制固定精度输出，如<code>%.2f</code>指输出小数点后2位的浮点数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="type">float</span> pi = <span class="number">3.1415926535</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi = %.3f\n&quot;</span>, pi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi = %.*f\n&quot;</span>, <span class="number">3</span>, pi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi = %g\n&quot;</span>, pi);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">pi = <span class="number">3.142</span></span><br><span class="line">pi = <span class="number">3.142</span></span><br><span class="line">pi = <span class="number">3.14159</span></span><br></pre></td></tr></table></figure></p><h3 id="scanf函数">3.3 scanf()函数</h3><p>这个函数用于从标准输入流中读取数据。scanf()函数的常见用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);  <span class="comment">// 读取一个整数类型的变量</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;score);  <span class="comment">// 读取一个浮点数类型的变量</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);  <span class="comment">// 读取一个字符串类型的变量</span></span><br></pre></td></tr></table></figure><p>scanf()函数中的%符号也是一个占位符，用于表示将要读取的变量的数据类型。&amp;符号用于表示将要读取的变量的地址。在使用scanf()函数时，需要注意数据类型匹配和错误处理等问题。</p><h3 id="getchar函数和putchar函数">3.4 getchar()函数和putchar()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = getchar();  <span class="comment">// 读取一个字符</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>);  <span class="comment">// 输出一个字符</span></span><br></pre></td></tr></table></figure><p>getchar()函数会等待用户输入一个字符，并将该字符作为返回值返回，而putchar()函数则将给定的字符输出到标准输出流。</p><h3 id="gets函数和puts函数">3.5 gets()函数和puts()函数</h3><p>gets()函数用于从标准输入流中读取一行字符串，直到遇到换行符为止。</p><p>puts()函数则将给定的字符串输出到标准输出流，并在字符串末尾自动添加一个换行符。它们的常见用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">gets(str);  <span class="comment">// 读取一行字符串</span></span><br><span class="line"><span class="built_in">puts</span>(str);  <span class="comment">// 输出字符串并添加一个换行符</span></span><br></pre></td></tr></table></figure><p>gets()函数的安全性不高，容易引发缓冲区溢出等安全问题，因此建议使用fgets()函数代替gets()函数进行字符串输入。</p><h3 id="文件读写">3.6 文件读写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);  <span class="comment">// 打开文件</span></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File does not exist.&quot;</span>);  <span class="comment">// 检查文件是否打开成功</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);  <span class="comment">// 如果文件打开失败，则终止程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">fgets(str, <span class="number">100</span>, fp);  <span class="comment">// 从文件中读取一行字符串</span></span><br><span class="line">fclose(fp);  <span class="comment">// 关闭文件</span></span><br></pre></td></tr></table></figure><h2 id="符号运算优先级">4.符号运算优先级</h2><table><thead><tr class="header"><th>优先级</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr class="odd"><td>1</td><td>( )</td><td>左右</td></tr><tr class="even"><td>2</td><td>! ~ -</td><td>右到左</td></tr><tr class="odd"><td>3</td><td>* / %</td><td>左到右</td></tr><tr class="even"><td>4</td><td>+ -</td><td>左到右</td></tr><tr class="odd"><td>5</td><td>&lt;&lt; &gt;&gt;</td><td>左到右</td></tr><tr class="even"><td>6</td><td>&lt; &lt;= &gt; &gt;=</td><td>左到右</td></tr><tr class="odd"><td>7</td><td>== !=</td><td>左到右</td></tr><tr class="even"><td>8</td><td>&amp;</td><td>左到右</td></tr><tr class="odd"><td>9</td><td>^</td><td>左到右</td></tr><tr class="even"><td>10</td><td>|</td><td>左到右</td></tr><tr class="odd"><td>11</td><td>&amp;&amp;</td><td>左到右</td></tr><tr class="even"><td>12</td><td>||</td><td>左到右</td></tr><tr class="odd"><td>13</td><td>? :</td><td>右到左</td></tr><tr class="even"><td>14</td><td>= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;=</td><td>右到左</td></tr></tbody></table><h2 id="数组">5.数组</h2><p>在C语言中，数组是一组相同数据类型的元素的集合。数组中的每个元素都可以通过下标来访问，下标从0开始计数。数组的定义方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type array_name[array_size];</span><br></pre></td></tr></table></figure><p>其中，type表示数组中元素的数据类型，array_name表示数组的名称，array_size表示数组中元素的个数。在数组中，第一个元素的下标为0，最后一个元素的下标为<code>array_size-1</code>。可以通过下标来访问数组中的元素。</p><h2 id="指针">6.指针</h2><p>在C语言中，指针是一种特殊的变量类型，它可以存储变量的地址。指针的定义方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type *pointer_name;</span><br></pre></td></tr></table></figure><p>其中，type表示指针所指向变量的数据类型，pointer_name表示指针的名称。指针变量需要指向某个内存地址才能使用，可以通过取地址运算符<code>&amp;</code>来获取变量的地址，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;  <span class="comment">// 将指针p指向变量a的地址</span></span><br><span class="line"><span class="type">int</span> b = *p;  <span class="comment">// 将b赋值为指针p所指向的变量的值</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = a;  <span class="comment">// 将指针p指向数组a的第一个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));  <span class="comment">// 通过指针访问数组中的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;简单复习一下C语言。&lt;/p&gt;
&lt;p&gt;进阶篇：&lt;a
href=&quot;https://splendidwave.github.io/2023/04/23/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E8%BF%9B%E9%98%B6%E7%AF%87/&quot;&gt;C语言复习-进阶篇&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90/"/>
    
    
    <category term="嵌入式开发" scheme="https://splendidwave.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="C语言" scheme="https://splendidwave.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>统计学习(7)--最大熵模型</title>
    <link href="https://splendidwave.github.io/2023/01/04/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(7)--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <id>https://splendidwave.github.io/2023/01/04/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(7)--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</id>
    <published>2023-01-04T08:10:03.000Z</published>
    <updated>2023-04-19T07:37:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>支持向量机的学习的目标也是在特征空间中找到一个分离超平面，能将实例分到不同的类。不同与感知机的解有无穷多个，线性可分支持向量机利用间隔最大化求最优分离超平面，解是唯一的。</p><span id="more"></span><h2 id="间隔">1.间隔</h2><p>一般来说，一个点距离分离超平面的远近可以表示分类预测的确信程度。在超平面确定的情况下，点<spanclass="math inline">\(x_i\)</span>与超平面的距离可以表示为函数</p><p><span class="math display">\[\left|\frac{1}{\|w\|_{2}} \cdot\left(w \cdot x_i+b\right)\right|\]</span></p><p>定义函数间隔（functional margin）为下式</p><p><span class="math display">\[\hat{\gamma}_{i}=y_{i}\left(w \cdot x_{i}+b\right)\]</span></p><p>记函数间隔<spanclass="math inline">\(\hat{\gamma}_{i}\)</span>的最小值为<spanclass="math inline">\(\hat{\gamma}\)</span>，函数间隔可以表示分类预测的正确性及准确度。对超平面的法向量添加约束，就可以得到几何间隔（geometricmargin），定义如下</p><p><span class="math display">\[\gamma_{i}=y_{i}\left(\frac{w}{\|w\|} \cdot x_{i}+\frac{b}{\|w\|}\right)\]</span></p><h3 id="最大间隔分离">1.1 最大间隔分离</h3><p>最大间隔具有存在性和唯一性，训练数据集的样本点中与分离超平面距离最近的样本点的实例称为支持向量（supportvector），在决定分离超平面时只有支持向量起作用，而其他实例点并不起作用。如果移动支持向量将改变所求的解；但是如果在间隔边界以外移动其他实例点，甚至去掉这些点，则解是不会改变的。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/01/20230104162422.png"alt="支持向量" /><figcaption aria-hidden="true">支持向量</figcaption></figure><h3 id="硬间隔">1.2 硬间隔</h3><p>硬间隔(hardmargin)：假定训练样本在样本空间或特征空间中是线性可分的，即存在一个超平面能将不同类的样本完全划分开。</p><p>对于硬间隔分类，可以将问题转化为优化问题，即求</p><p><span class="math display">\[\max _{w, b} \quad  \hat{\gamma}_{i}\]</span></p><p><span class="math display">\[\text { s.t. }  y_{i}\left(\frac{w}{\|w\|} \cdotx_{i}+\frac{b}{\|w\|}\right) \geqslant \hat{\gamma}, \quad i=1,2,\cdots, N\]</span></p><p>使用几何间隔来替代间隔函数，这样对超平面的参数<spanclass="math inline">\(w,b\)</span>的缩放就不影响结果，可以令几何最小间隔<spanclass="math inline">\(\hat{\gamma}=1\)</span>，将所求表达式转换为如下形式</p><p><span class="math display">\[\max _{w, b} \frac{1}{\|w\|}\]</span></p><p><span class="math display">\[\text { s.t. } \quad y_{i}\left(w \cdot x_{i}+b\right) \geqslant 1,\quad i=1,2, \cdots, N\]</span></p><p>可以进一步可以变为求最小值优化</p><p><span class="math display">\[\min _{w, b} \frac{1}{2}\|w\|^{2}\]</span></p><p><span class="math display">\[\text { s.t. } \quad y_{i}\left(w \cdot x_{i}+b\right)-1 \geqslant 0,\quad i=1,2, \cdots, N\]</span></p><h3 id="软间隔">1.3 软间隔</h3><p>实际中训练数据的不等式约束并不能都成立。并不能满足硬间隔，这就需要修改硬间隔最大化，使其成为软间隔最大化。</p><p>为了解决这个问题，可以对每个样本点<spanclass="math inline">\((x_i,y_i)\)</span>引进一个松弛变量<spanclass="math inline">\(\xi_{\mathrm{i}} \geq0\)</span>，使函数间隔加上松弛变量大于等于1。这样，约束条件变为</p><p><span class="math display">\[y_{i}\left(w \cdot x_{i}+b\right) \geqslant 1-\xi_{i}\]</span></p><h2 id="对偶算法">2.对偶算法</h2><h3 id="对偶关系证明">2.1 对偶关系证明</h3><p>使用拉格朗日乘子法引入对偶算法，注意这里要用小于0的约束条件</p><p><span class="math display">\[L(w, b, \lambda)=\frac{1}{2}\|w\|^{2}+\sum_{i=1}^{N} \lambda_{i}(1-y_{i}\left(w \cdot x_{i}+b\right))\]</span></p><p>其中<spanclass="math inline">\(\lambda\)</span>是拉格朗日乘子，要求大于等于0</p><p>原问题就转化为</p><p><span class="math display">\[\max _{\lambda} \min _{w, b}  L(w, b, \lambda)\]</span></p><p><span class="math display">\[\text { s.t. } \lambda_{i} \geqslant 0\]</span></p><p>这里解释一下取极大极小值的意义，。先将<spanclass="math inline">\(\frac{1}{2}\|w\|^{2}\)</span>记为<spanclass="math inline">\(f(w)\)</span>,后一项记为<spanclass="math inline">\(\lambda g(w,b)\)</span> <spanclass="math display">\[\begin{align}\max _{\lambda}\min _{w, b}  L(w, b, \lambda) &amp;=\max_{\lambda}\min_{w, b}  f(w)+ \max_{\lambda}\min_{w, b} \lambdag(w,b)\nonumber \\&amp;= \min_{w} f(w) +  \max_{\lambda}\min_{w, b} \lambda g(w,b)\nonumber\end{align}\]</span></p><p>因为<span class="math inline">\(y_{i}\left(w \cdotx_{i}+b\right)\geqslant 1\)</span>，所以<spanclass="math inline">\(g(w,b)\)</span>小于等于0，上式后一项的最大值就是0，即</p><p><span class="math display">\[\max _{\lambda}\min _{w, b}  L(w, b, \lambda) =\min_{w}\frac{1}{2}\|w\|^{2}\]</span></p><p>和原式等价。</p><p>有些视频和书上最大最小符号前后是换位的，在该问题下是等价的，因为有<spanclass="math inline">\(g(w,b)\)</span>小于等于0，所以</p><p><span class="math display">\[\max_{\lambda} L(w,b,\lambda) = f(w)\]</span></p><p>所以有</p><p><span class="math display">\[\min_{w,b} f(w) = \min_{w,b} \max_{\lambda} L(w,b,\lambda) = \max_{\lambda}\min _{w, b} L(w, b, \lambda)\]</span></p><h3 id="拉格朗日求解">2.2 拉格朗日求解</h3><p>将拉格朗日函数分别对<span class="math inline">\(w,b\)</span>求导</p><p><span class="math display">\[\nabla_{w} L(w, b, \lambda)=w-\sum_{i=1}^{N} \lambda_{i} y_{i} x_{i}=0\]</span></p><p><span class="math display">\[\nabla_{b} L(w, b, \lambda)=\sum_{i=1}^{N} \lambda_{i} y_{i}=0\]</span></p><p>所以有</p><p><span class="math display">\[w=\sum_{i=1}^{N} \lambda_{i} y_{i} x_{i}\]</span></p><p><span class="math display">\[\sum_{i=1}^{N} \lambda_{i} y_{i}=0\]</span></p><p>将上式回代<span class="math inline">\(L(w, b, \lambda)\)</span>得</p><p><span class="math display">\[\begin{aligned}L(w, b,  \lambda) &amp; =\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N}\lambda_{i} \lambda_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)\\&amp;-\sum_{i=1}^{N} \lambda_{i} y_{i}\left(\left(\sum_{j=1}^{N}\lambda_{j} y_{j} x_{j}\right) \cdot x_{i}+b\right)+\sum_{i=1}^{N}\lambda_{i} \\&amp; =-\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \lambda_{i}\lambda_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)+\sum_{i=1}^{N}\lambda_{i}\end{aligned}\]</span></p><p>这就是<span class="math inline">\(\min _{w, b} L(w, b,\lambda)\)</span>，接下来对它求极大值</p><p>即求负的极小值</p><p><span class="math display">\[\min _{\lambda} \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \lambda_{i}\lambda_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)+\sum_{i=1}^{N}\lambda_{i}\]</span></p><p><span class="math display">\[\begin{array}{ll}\text { s.t. } &amp; \sum_{i=1}^{N} \lambda_{i} y_{i}=0 \\&amp; \lambda_{i} \geqslant 0, \quad i=1,2, \cdots, N\end{array}\]</span></p><!-- ## 3.线性支持向量机## 4.非线性支持向量机## 5.SMO --><h2 id="参考资料">参考资料</h2><p>[1] 《统计学习方法》 李航</p><p>[2] <ahref="https://www.cnblogs.com/mo-wang/p/4775548.html">【整理】深入理解拉格朗日乘子法（LagrangeMultiplier) 和KKT条件</a></p><p>[3] <ahref="https://www.bilibili.com/video/BV1Hs411w7ci/?p=2&amp;spm_id_from=333.880.my_history.page.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">机器学习-白板推导系列(六)-支持向量机SVM（SupportVector Machine）</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;支持向量机的学习的目标也是在特征空间中找到一个分离超平面，能将实例分到不同的类。不同与感知机的解有无穷多个，线性可分支持向量机利用间隔最大化求最优分离超平面，解是唯一的。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="统计学习" scheme="https://splendidwave.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>统计学习(6)--逻辑斯谛回归</title>
    <link href="https://splendidwave.github.io/2022/12/26/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(6)--%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92/"/>
    <id>https://splendidwave.github.io/2022/12/26/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(6)--%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92/</id>
    <published>2022-12-26T01:46:03.000Z</published>
    <updated>2022-12-30T09:13:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>逻辑斯谛回归模型利用了逻辑斯谛方程的对数特性，将特征参数映射到[0，1]之间，将问题转换为概率预测，从而实现判别。</p><span id="more"></span><h2 id="逻辑斯谛方程">1.逻辑斯谛方程</h2><p>学过数学建模的应该都知道，逻辑斯谛方程最早提出是用于人口增长模型。下面进行一个简单的推导。</p><p>假设人口随时间的函数是<spanclass="math inline">\(W(t)\)</span>，人口增长率为<spanclass="math inline">\(\beta\)</span>，则人口增长的微分方程为</p><p><span class="math display">\[\frac{\mathrm{d} W(t)}{\mathrm{d} t}  = \beta W(t)\]</span></p><p>解得</p><p><span class="math display">\[W(t) = \exp （\beta t + C）\]</span></p><p>这种指数爆炸型增长是不太可能发生的，毕竟资源是有限的，所以人口增长应该还要和生物容量<spanclass="math inline">\(K\)</span>有关，再重新写出微分方程,这里的<spanclass="math inline">\(\beta\)</span>和上面的可能存在数值上的差异。</p><p><span class="math display">\[\frac{\mathrm{d} W(t)}{\mathrm{d} t}  = \beta W(t) (K-W(t))\]</span></p><p>这就是逻辑斯谛方程的微分形式，其实这个方程虽然是推猜出来的，但其蕴含了一定的自然规律，所以他从人口模型应用到了其他各个领域，这点和傅里叶变换不谋而合。</p><h2 id="逻辑斯谛分布">2.逻辑斯谛分布</h2><p>现在我不关心数量了，我更想知道现在的人口占总容量的多少，记比例为<spanclass="math inline">\(P(t)\)</span>我们有<spanclass="math inline">\(P(t)=W(t)/K\)</span></p><p>对于P(t)有</p><p><span class="math display">\[\begin{align}\frac{\mathrm{d} P(t)}{\mathrm{d} t}  &amp;= \frac{\mathrm{d}(W(t)/K)}{\mathrm{d} t} \\&amp;= \frac{\beta}{K}W(t)(K-W(t)) \\&amp;= K\beta P(t)[1-P(t)]\end{align}\]</span></p><p>等式就变成了微分方程 <span class="math display">\[\frac{1}{P[1-P]} P \mathrm{d} P =  C * \mathrm{d} t\]</span> 其中C是常数</p><p>解方程得</p><p><span class="math display">\[P = \frac{\exp{(\alpha+\beta t)}}{1+\exp{(\alpha+\beta t)}}\tag{式1}\]</span></p><p>其中<span class="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\beta\)</span>是常数，令<spanclass="math inline">\(x = \alpha+\beta t\)</span></p><p>将上式函数绘制出来就如下图</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221230151405.png"alt="逻辑斯谛分布" /><figcaption aria-hidden="true">逻辑斯谛分布</figcaption></figure><p>P的物理意义是占比，也就是说它的取值范围在<spanclass="math inline">\([0-1]\)</span>之间，这和概率不谋而合，将这个函数视作概率密度函数，可以得到逻辑斯谛分布函数方程和图如下</p><p><span class="math display">\[F(x)=P(X \leqslant x)=\frac{1}{1+\mathrm{e}^{-(x-\mu) / \gamma}}\]</span></p><p><span class="math display">\[f(x)=F^{\prime}(x)=\frac{\mathrm{e}^{-(x-\mu) /\gamma}}{\gamma\left(1+\mathrm{e}^{-(x-\mu) / \gamma}\right)^{2}}\]</span></p><p>其中<span class="math inline">\(\mu\)</span>为位置参数，<spanclass="math inline">\(\gamma&gt;0\)</span>是形状参数。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221230151747.png"alt="分布函数" /><figcaption aria-hidden="true">分布函数</figcaption></figure><h2 id="二项逻辑斯谛回归模型">3.二项逻辑斯谛回归模型</h2><p>对于二分类问题，使用统计学习中常用的<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>来代替式1的<spanclass="math inline">\(\beta\)</span>和<spanclass="math inline">\(\alpha\)</span>,可以得到</p><p><span class="math display">\[P = \frac{\exp (w \cdot x+b)}{1+\exp (w \cdot x+b)}\]</span></p><p>我们人为假定这个P是实例x在参数<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>条件下分类为1的概率，毕竟参数是可以训练的，那么有</p><p><span class="math display">\[P(Y=0 \mid x)=\frac{1}{1+\exp (w \cdot x+b)}\]</span></p><p>两者的和为1，使用训练集训练数据后，对于新实例，只需要计算两者的概率让后进行归类即可。</p><p>模型的参数可以使用极大似然估计法来得到，设</p><p><span class="math display">\[P(Y=1 \mid x)=\pi(x), \quad P(Y=0 \mid x)=1-\pi(x)\]</span></p><p>似然函数为</p><p><span class="math display">\[\prod_{i=1}^{N}\left[\pi\left(x_{i}\right)\right]^{y_{i}}\left[1-\pi\left(x_{i}\right)\right]^{1-y_{i}}\]</span></p><p>对数似然函数为</p><p><span class="math display">\[\begin{aligned}L(w) &amp; =\sum_{i=1}^{N}\left[y_{i} \log\pi\left(x_{i}\right)+\left(1-y_{i}\right) \log\left(1-\pi\left(x_{i}\right)\right)\right] \\&amp; =\sum_{i=1}^{N}\left[y_{i} \log\frac{\pi\left(x_{i}\right)}{1-\pi\left(x_{i}\right)}+\log\left(1-\pi\left(x_{i}\right)\right)\right] \\&amp; =\sum_{i=1}^{N}\left[y_{i}\left(w \cdot x_{i}\right)-\log\left(1+\exp \left(w \cdot x_{i}\right)\right]\right.\end{aligned}\]</span></p><p>对<spanclass="math inline">\(L(w)\)</span>用梯度下降法求极大值即可得到估计值。</p><p>最后给出多项逻辑斯谛回归的公式</p><p><span class="math display">\[P(Y=k \mid x)=\frac{\exp \left(w_{k} \cdot x\right)}{1+\sum_{k=1}^{K-1}\exp \left(w_{k} \cdot x\right)}, \quad k=1,2, \cdots, K-1\]</span></p><h2 id="参考资料">参考资料</h2><p>[1] 《统计学习方法》 李航</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;逻辑斯谛回归模型利用了逻辑斯谛方程的对数特性，将特征参数映射到[0，1]之间，将问题转换为概率预测，从而实现判别。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="统计学习" scheme="https://splendidwave.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>统计学习(5)--决策树</title>
    <link href="https://splendidwave.github.io/2022/12/18/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(5)--%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>https://splendidwave.github.io/2022/12/18/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(5)--%E5%86%B3%E7%AD%96%E6%A0%91/</id>
    <published>2022-12-18T01:12:03.000Z</published>
    <updated>2023-01-07T13:32:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>决策树是一种基本的分类和回归方法，其具有可读性好，分类快等优点。在西瓜书中，决策树就作为例子引入了机器学习，说明了树模型是适合于新手入门学习的内容。本文会从基本概念逐一展开介绍几种决策树的基本算法。<span id="more"></span></p><h2 id="什么是决策树">1.什么是决策树</h2><p>分类决策树是一种描述对实例进行分类的树形结构，正如书中西瓜好不好的决策判别。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221218092612.png"alt="决策树判断西瓜是好瓜还是坏瓜" /><figcaption aria-hidden="true">决策树判断西瓜是好瓜还是坏瓜</figcaption></figure><p>人可以同个经验来判别好坏瓜的条件，那对于机器来说，要如何实现并构造决策树呢？不可避免的我们需要一个判别依据，好在信息论里能够给我们一些启发。</p><h2 id="信息熵">2.信息熵</h2><p>信息熵是用来衡量一个体系的不确定度的物理量，熵这个词也是借用的热力学，信息熵越大，不确定性越强。计算公式如下</p><p><span class="math display">\[H(X)=-\sum_{i=1}^{M} P\left(x_{i}\right) \log _{2} P\left(x_{i}\right)\tag{1.1}\]</span></p><p>如果不太清楚这个概念可以通过该链接去了解一下<ahref="https://splendidwave.github.io/2022/08/20/2022-8/%E4%BF%A1%E6%81%AF%E9%87%8F%E5%92%8C%E4%BF%A1%E6%81%AF%E7%86%B5/">信息量和信息熵</a></p><p>在理解信息熵这个概念后，这里再补充一个<strong>条件熵</strong>，它指的是在某一条件Y下体系具有的信息熵。公式如下</p><p><span class="math display">\[H(X \mid Y)=-\sum_{i=1}^{M} P(x_i \mid Y) \log _{2} P(x_i \mid Y)\tag{1.2}\]</span></p><p>显然系统的条件熵要比信息熵要小一些，因为条件Y的发生让系统更加确定了一些，它们差值不妨就叫做<strong>信息增益</strong>。公式如下</p><p><span class="math display">\[I(X, Y)=H(X)-H(X \mid Y)\tag{1.3}\]</span></p><h2 id="判别条件">2.判别条件</h2><p>有了以上几个量化概念，我们就可以用来量化决策树。</p><p>可以看一个具体的例子，有一副去掉大小王的扑克牌(52张)，我从中随机抽取一张，想让机器狗旺财来帮我判别它是<strong>红色还是黑色</strong>。旺财无法直接识别颜色，它只能看见点数和花色,所以它需要用决策树的方法来处理这个问题。</p><p>旺财计算了一下该问题的信息熵</p><p><span class="math display">\[\begin{align}H(X) &amp; = -\sum_{i=1}^{M} P\left(x_{i}\right) \log _{2}P\left(x_{i}\right)\nonumber\\&amp; = \frac{1}{2} + \frac{1}{2} \nonumber \\&amp; = 1 \nonumber\end{align}\]</span></p><h3 id="使用点数决策-y_1">2.1 使用点数决策 <spanclass="math inline">\(Y_1\)</span></h3><p>它决定先试试点数，<strong>决策条件为点数大于等于10的都是红色</strong>。</p><p>那么条件熵为</p><p><span class="math display">\[H(X \mid Y_1) = (\frac{4}{13}+\frac{9}{13})\cdot(\frac{1}{4}\log_{2}{4}-\frac{3}{4}\log_{2}\frac{3}{4}) \approx 0.811\]</span></p><p>好像这个条件并没有起到任何帮助，信息增益为<spanclass="math inline">\(I(X, Y_1)=0.189\)</span></p><h3 id="使用花色决策-y_2">2.2 使用花色决策 <spanclass="math inline">\(Y_2\)</span></h3><p>旺财改变了策略，<strong>红桃的牌都是红色</strong>。</p><p>红桃牌的概率是1/4且全是红色 那么条件熵为</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200707.jpg"alt="决策2" /><figcaption aria-hidden="true">决策2</figcaption></figure><p><span class="math display">\[H(X \mid Y_2) = \frac{1}{4} \cdot 0 + \frac{3}{4} \cdot 0.91829 \approx0.689\]</span></p><p>信息增益为<span class="math inline">\(I(X,Y_2)=0.311\)</span>，看起来好了一些。</p><h3 id="花色决策2.0-y_3">2.3 花色决策2.0 <spanclass="math inline">\(Y_3\)</span></h3><p>旺财注意到上述决策中左节点的信息熵已经是0了，可以停止优化，而右节点的信息熵接近父节点的信息熵，说明优化空间很大，于是它对右节点再采策略认为<strong>方片也是红的</strong>。</p><p>毫无疑问信息信息增益达到了最大，旺财完美地完成了任务。</p><h2 id="id3算法">3.ID3算法</h2><p>ID 是 IterativeDichotomiser的缩写，迭代二分器/二叉树，虽然决策树不一定是二叉树，但通常情况下是二分的，3大概是第三代的意思吧。</p><p>上述这种以<strong>信息增益作为特征选择的度量</strong>，使用自顶向下的贪心算法遍历决策树空间的算法即为ID3算法。</p><p>通俗的讲该算法就是每一步都选择可以实现信息增益最大的特征作为该节点的分类条件直到特征用完或者分类结束。</p><p>程序流程图就放在后面给，现在来看看ID3算法优缺点。</p><h3 id="id3的优点">3.1 ID3的优点</h3><ol type="1"><li>简单，只需要算信息熵就完了。</li><li>鲁棒性强，不容易受到噪声的影响</li><li>搜索空间完整，基本上会遍历所有特征</li></ol><h3 id="id3的缺点">3.2 ID3的缺点</h3><ol type="1"><li>ID3算法会去选择可取值类别多的特征，这是信息熵的计算方法导致的，分得越细，确定性就会越高。</li><li>只能计算离散值</li><li>无法处理信息缺失</li><li>容易过拟合，因为它会遍历所有特征</li></ol><h2 id="c4.5算法">4.C4.5算法</h2><p>ID3 算法的发明人RossQuinlan也意识到了这些缺点，有问题就解决呗，ID3会对多分类有个偏好，这是因为信息增益的计算方式导致的，为了解决这一问题，必须将判别条件改变。</p><p>为此分裂信息的定义被提出，计算公式如下：</p><p><span class="math display">\[SplitInfo_A(D)=-\sum_{i=1}^{n} \frac{\left|D_{i}\right|}{|D|} \log _{2}\frac{\left|D_{i}\right|}{|D|}\tag{4.1}\]</span></p><p>其中D是数据集，<spanclass="math inline">\(D_i\)</span>是D在特征A下的第i个分类子集。可以看出分裂信息也特征的类别越多值就会越大。</p><p>所以只要将信息增益除以分裂信息就可以得到一个消除倾向的判别条件，我们称为<strong>信息增益率</strong>，计算公式如下：</p><p><span class="math display">\[\operatorname{GainRatio}(D,A)=\frac{I(D,A)}{\operatorname{SplitInfo_A}(D)} \tag{4.2}\]</span></p><p>对于连续的特征值，可以选择遍历这些值找到信息增益最大的分界点来实现对值的二分离散化。</p><p>信息缺失可以选择补上期望值，过拟合就采用剪枝的方法来完成。</p><p>这样问题就解决了不少，但这类算法还是存在硬伤。一是算法只能用于分类，二是构造过程需要反复遍历，比较大小，还是对数运算，算法效率低。</p><h2 id="cart3算法">5.CART3算法</h2><h3 id="不如换个判别条件">5.1 不如换个判别条件</h3><p>既然对数运算费时，不如直接抛开熵这个数值条件，重新找一个判别依据，公式如下</p><p><span class="math display">\[\operatorname{Gini}(D)=\sum_{k=1}^{K}\frac{\left|C_{k}\right|}{|D|}\left(1-\frac{\left|C_{k}\right|}{|D|}\right)=1-\sum_{k=1}^{K}p_{k}^{2} \tag{5.1}\]</span></p><p>我们称它为基尼系数，其中k为类别，<spanclass="math inline">\(p_k\)</span>是k类别的概率，它可以识别当前集合的纯度。来看一个具体例子，当k只能取两个值时，如红色牌的概率为<spanclass="math inline">\(p_1\)</span> 黑色牌概率为<spanclass="math inline">\(p_2\)</span>，而且有<spanclass="math inline">\(p_1=1-p_2\)</span>，代入式(5.1)可得基尼系数是一个关于<spanclass="math inline">\(p_1\)</span>的二次函数，关系如下图</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200727.jpg"alt="基尼系数" /><figcaption aria-hidden="true">基尼系数</figcaption></figure><p>当集合中只有红色时，即概率<spanclass="math inline">\(p=1\)</span>，这时基尼系数为0，当红黑参半时，基尼系数会达到最大。由此可见，基尼系数越小，代表集合纯度越高。</p><p>我们可以以此为参考依据，遍历特征，选出加权基尼系数最小的分类方法作为策略。同时CART3永远对数据二分，离散连续一视同仁，二叉树的便捷性也是显而易见的。</p><h3 id="谁说树只能分类">5.2 谁说树只能分类</h3><p>CART树全名是Classification and RegressionTree，这说明它既能分类也能回归，回归树的构建本质上是用<strong>平方误差最小化准则</strong>进行特征选择，去生成二叉树。</p><p>其判别的条件又不是基尼系数了，而是最小均方差值，公式如下</p><p><span class="math display">\[\min_{j, s}\left[\min_{c_{1}} \sum_{x_{i} \in R_{1}(j,s)}\left(y_{i}-c_{1}\right)^{2}+\min_{c_2} \sum_{x_{i} \in R_{2}(j,s)}\left(y_{i}-c_{2}\right)^{2}\right] \tag{5.2}\]</span></p><p>其中因为特征是连续值，该公式的意思是选择第j个特征的s为切分点，这样集合就分为了<spanclass="math inline">\(R_1\)</span>和<spanclass="math inline">\(R_2\)</span>，使得两个区域的label值和该划分区域的值c平方和最小。得到j和s作为划分的依据，其中<spanclass="math inline">\(c_1\)</span>、<spanclass="math inline">\(c_2\)</span>取集合的均值： <spanclass="math display">\[c_{1}=\frac{1}{N_{1}} \sum_{x_{i} \in R_{1}} y_{i}, \quadc_{2}=\frac{1}{N_{2}} \sum_{x_{i} \in R_{2}} y_{i}\]</span></p><p>回归树但看公式可能有些困难，最好找道例题或者自己敲遍代码加强理解。另外cart算法也容易过拟合，需要配合减枝。</p><h2 id="随机森林">6.随机森林</h2><p>树看起来内容差不多了，但有很多树的时候，就形成了森林。为什么需要很多树？这是因为我们在处理问题时可能会不知道那些特征是有用的，那些特征是没有用的，为此不妨多训练几颗树，让每个树的特征随机选取。最后通过统计所有树的输出结果少数服从多数得到答案。</p><p>随机森林的结构简单而高效，当不知道用什么算法时不妨试试随机森林。而且这类集成学习的方法也不单单适用于决策树，同时也可以集成神经网络。</p><h2 id="boosting算法">7.Boosting算法</h2><p>Boosting是提升的意思，Boosting算法是通过把弱学习器加强成强学习器。一个典型的例子是GBDT算法</p><p>GBDT全称是Gradient Boosting DecisionTree，它利用CART的回归树作为弱学习器。这里只给出实现思路，具体公式暂不呈现。</p><p>我们引入一个残差的概念，它指的是模型的预测值和真实值的差距。当我们训练了一个树，它的输出结果会与真实值存在残差，我们可以再训练一个树来预测残差，当然这个预测残差的树也必然会与真实残差存在一个残差。不过没关系，我们可以套娃，套到结果可以接受的样子，大概的思路类似梯度下降法，同时公式也是用的一阶导数（负梯度）来近似残差。</p><p>另外还有XGBoost算法，XG是ExtremeGradient的意思，XGBoost在GBDT的基础上又做了改进，使用了二阶导数的信息，同时又加了一个正则项来防止过拟合。</p><h2 id="参考资料">参考资料</h2><p>[1] 《统计学习方法》 李航</p><p>[2] 《机器学习》 周志华</p><p>[3] 知乎文章 <ahref="https://zhuanlan.zhihu.com/p/399549773">零基础一文读懂树模型：从决策树到LightGBM</a></p><p>[4] 知乎文章 <ahref="https://zhuanlan.zhihu.com/p/158633779">【预估排序】Xgboost、GBDT、CART等树模型联系和区别（超级详细）</a></p><p>[5] CSDN文章 <ahref="https://blog.csdn.net/weixin_45834080/article/details/103036401">对ID3算法的理解及其优缺点</a></p><p>[6] b站视频 <ahref="https://www.bilibili.com/video/BV1VA411A7AQ?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">决策树算法例题</a></p><p>[7] b站视频 <ahref="https://www.bilibili.com/video/BV1ar4y137GD?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">[5分钟学算法]#03 决策树 小明毕业当行长</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;决策树是一种基本的分类和回归方法，其具有可读性好，分类快等优点。在西瓜书中，决策树就作为例子引入了机器学习，说明了树模型是适合于新手入门学习的内容。本文会从基本概念逐一展开介绍几种决策树的基本算法。</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="统计学习" scheme="https://splendidwave.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用python进行科研绘图入门--共用坐标、全局字体</title>
    <link href="https://splendidwave.github.io/2022/12/14/2022-12/%E4%BD%BF%E7%94%A8python%E8%BF%9B%E8%A1%8C%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE%E5%85%A5%E9%97%A8--%E5%85%B1%E7%94%A8%E5%9D%90%E6%A0%87%E3%80%81%E5%85%A8%E5%B1%80%E5%AD%97%E4%BD%93/"/>
    <id>https://splendidwave.github.io/2022/12/14/2022-12/%E4%BD%BF%E7%94%A8python%E8%BF%9B%E8%A1%8C%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE%E5%85%A5%E9%97%A8--%E5%85%B1%E7%94%A8%E5%9D%90%E6%A0%87%E3%80%81%E5%85%A8%E5%B1%80%E5%AD%97%E4%BD%93/</id>
    <published>2022-12-14T06:11:33.000Z</published>
    <updated>2022-12-14T06:22:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>python绘图技巧备忘录</p><p>使用Matplotlib，以代码呈现为主</p><p>字体修改，公用x轴坐标 <span id="more"></span></p><h2 id="全局字体修改">1. 全局字体修改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import rcParams</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">    &quot;font.family&quot;:&#x27;serif&#x27;,</span><br><span class="line">    &quot;font.size&quot;: 35,</span><br><span class="line">    &quot;mathtext.fontset&quot;:&#x27;stix&#x27;,</span><br><span class="line">    &quot;font.serif&quot;: [&#x27;SimSun&#x27;],</span><br><span class="line">&#125;</span><br><span class="line">rcParams.update(config)</span><br></pre></td></tr></table></figure><h2 id="局部字体">2.局部字体</h2><p>label <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.ylabel(r&#x27;Wavenumber $\left (  cm^&#123;-1&#125; \right )$&#x27;, fontdict=&#123;&#x27;family&#x27; : &#x27;Times New Roman&#x27;, &#x27;size&#x27;   : 35&#125;)</span><br></pre></td></tr></table></figure> plt自带latex语法</p><p>text <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax2.text(12,12,r&#x27;$A_g^3$&#x27;,ha = &#x27;center&#x27;,va = &#x27;bottom&#x27;,fontsize=35)</span><br></pre></td></tr></table></figure></p><h2 id="共用x坐标">3.共用x坐标</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 开启画布</span><br><span class="line">plt.figure(1)</span><br><span class="line">x_major_locator=MultipleLocator(2)#准备刻度</span><br><span class="line"># 绘制第一幅图像</span><br><span class="line">ax1=plt.gca()</span><br><span class="line">ax1.xaxis.set_major_locator(x_major_locator)</span><br><span class="line">ax1.set_yticks(np.linspace(50, 100, 11)) </span><br><span class="line">plt.plot(x2,nih,linewidth=3.0,color=&#x27;#2878b5&#x27;)</span><br><span class="line">plt.tick_params(axis=&#x27;y&#x27;,colors=&#x27;#2878b5&#x27;)</span><br><span class="line"></span><br><span class="line"># 共用坐标</span><br><span class="line">ax2 = ax1.twinx()</span><br><span class="line">ax2.set_yticks(np.linspace(0, 50, 11))</span><br><span class="line">plt.plot(x1,nil,linewidth=3.0,color=&#x27;#c82423&#x27;)</span><br><span class="line">plt.tick_params(axis=&#x27;y&#x27;,colors=&#x27;#c82423&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图如下</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221214142028.png"alt="共用x坐标" /><figcaption aria-hidden="true">共用x坐标</figcaption></figure><h2 id="参考资料">参考资料</h2><p>[1] <ahref="https://blog.csdn.net/weixin_42710615/article/details/124297710">Matplotlib文字处理</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;python绘图技巧备忘录&lt;/p&gt;
&lt;p&gt;使用Matplotlib，以代码呈现为主&lt;/p&gt;
&lt;p&gt;字体修改，公用x轴坐标</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="科研" scheme="https://splendidwave.github.io/tags/%E7%A7%91%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>统计学习(4)--朴素贝叶斯法</title>
    <link href="https://splendidwave.github.io/2022/12/10/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(4)--%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/"/>
    <id>https://splendidwave.github.io/2022/12/10/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(4)--%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/</id>
    <published>2022-12-10T11:45:03.000Z</published>
    <updated>2022-12-18T01:11:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>朴素贝叶斯法是基于贝叶斯定理与特征独立假设的分类方法，假设出数据集的输入输出的联合概率分布，然后基于此模型利用贝叶斯定理求出给定的输入x对应的后验概率最大的输出y。</p><span id="more"></span><h2 id="贝叶斯定理">1.贝叶斯定理</h2><p>贝叶斯学派认为概率是客观事实的可信度，事件A发生存在一个<strong>先验概率</strong><spanclass="math inline">\(P(A)\)</span></p><p>在事件A条件下事件B发生的概率记为<spanclass="math inline">\(P(B|A)\)</span>，称为<strong>似然概率</strong></p><p>相反的，在知道事件B条件下事件A发生的概率为<spanclass="math inline">\(P(A|B)\)</span>，称为<strong>后验概率</strong></p><p>他们之间存在关系</p><p><span class="math display">\[P(A \mid B)=P(A) \frac{P(B \mid A)}{P(B)}\]</span></p><h2 id="朴素贝叶斯法">2.朴素贝叶斯法</h2><p>以分类问题为例，假设要判别的数据<spanclass="math inline">\(Y\)</span>是事件A，已知新实例的特征<spanclass="math inline">\(X\)</span>为事件B，则先验概率为</p><p><span class="math display">\[P\left(Y=c_{k}\right), \quad k=1,2, \cdots, K\]</span></p><p>其中c是分类的类别一共有K种。先验概率由主观可能性认定。</p><p>在已知新实例特征的情况下，该实例为类别<spanclass="math inline">\(c_k\)</span>的可能性为后验概率<spanclass="math inline">\(P(Y=c_k \mid X = x)\)</span></p><p>根据贝叶斯公式上式可以等价于</p><p><span class="math display">\[P\left(Y=c_{k} \mid X=x\right)=\frac{P\left(X=x \mid Y=c_{k}\right)P\left(Y=c_{k}\right)}{\sum_{k} P\left(X=x \mid Y=c_{k}\right)P\left(Y=c_{k}\right)}\]</span></p><p>显然后验概率最大的最有可能是这个实例的正确分类。</p><p>朴素贝叶斯之所以前面有个朴素，是因为它假设了所有实例特征之间相互独立，根据概率论的知识，独立的事件同时发生的概率就是它们的乘积。</p><p>所以上式又可以改写为</p><p><span class="math display">\[y=f(x)=\arg \max _{c_{i}} \frac{P\left(Y=c_{k}\right) \prod_{j}P\left(X^{(j)}=x^{(j)} \mid Y=c_{k}\right)}{\sum_{k}P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} \midY=c_{k}\right)}\]</span></p><p>由于上式中的分母都是相同的，而且只要求最大值而不是准确值，所以还可以进一步简化为</p><p><span class="math display">\[y=\arg \max _{c_{k}} P\left(Y=c_{k}\right) \prod_{j}P\left(X^{(j)}=x^{(j)} \mid Y=c_{k}\right)\]</span></p><p>值得一提的是，后验概率最大化等价于期望风险最小化。</p><h2 id="极大似然估计法">3.极大似然估计法</h2><p>我们现在只要知道先验概率和条件概率，就可以估计出新实例是属于哪一类的了。</p><p>某一类别的先验概率可以用训练集中该类的数量占总数量的比例来似然估计，即</p><p><span class="math display">\[P\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N}I\left(y_{i}=c_{k}\right)}{N}, k=1,2, \cdots, K\]</span></p><p>其中N是样本总量，I是判别函数。</p><p>同理条件概率也可以同个数数获得，当第j个特征<spanclass="math inline">\(x^{(j)}\)</span>的可能取值为<spanclass="math inline">\({a_{j1},a_{j2},...,a_{js}}\)</span>时</p><p><span class="math display">\[P\left(X^{(j)}=a_{j l} \mid Y=c_{k}\right)=\frac{\sum_{i=1}^{N}I\left(x_{i}^{(j)}=a_{j l}, y_{i}=c_{k}\right)}{\sum_{i=1}^{N}I\left(y_{i}=c_{k}\right)}\]</span></p><h2 id="贝叶斯估计">4.贝叶斯估计</h2><p>极大似然估计符合人类对样本的直观感受，但可能会因为数据集的问题出现要估计的概率值为0的情况，这可能会影响到后面的计算结果。</p><p>为此引入贝叶斯估计，条件概率的贝叶斯估计是</p><p><span class="math display">\[P_{\lambda}\left(X^{(j)}=a_{j l} \midY=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(j)}=a_{j l},y_{i}=c_{k}\right)+\lambda}{\sum_{i=1}^{N}I\left(y_{i}=c_{k}\right)+S_{j} \lambda}\]</span></p><p>其中<span class="math inline">\(\lambda \ge0\)</span>等价于在随机变量的各个取值中都赋予一个正数，为1时，称为拉普拉斯平滑。<spanclass="math inline">\(S_{j} \lambda\)</span>是为了加上分子中<spanclass="math inline">\(\lambda\)</span>后使概率和仍为1.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;朴素贝叶斯法是基于贝叶斯定理与特征独立假设的分类方法，假设出数据集的输入输出的联合概率分布，然后基于此模型利用贝叶斯定理求出给定的输入x对应的后验概率最大的输出y。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="统计学习" scheme="https://splendidwave.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>统计学习(3)--k近邻和k均值</title>
    <link href="https://splendidwave.github.io/2022/11/25/2022-11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(3)--k%E8%BF%91%E9%82%BB%E5%92%8Ck%E5%9D%87%E5%80%BC/"/>
    <id>https://splendidwave.github.io/2022/11/25/2022-11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(3)--k%E8%BF%91%E9%82%BB%E5%92%8Ck%E5%9D%87%E5%80%BC/</id>
    <published>2022-11-25T05:02:03.000Z</published>
    <updated>2022-12-10T11:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>k-NN和k-mean介绍</p><span id="more"></span><h2 id="k近邻算法">1.k近邻算法</h2><p>k近邻法（k-nearest neighbor，k-NN）是一种基本分类与回归方法。</p><p>k近邻法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。</p><p>具体对于新的实例x，在训练集中找到与之相邻的k个实例，这k个实例的多数属于哪一类，就把这个实例分到哪一类中。当k为1时，称为最近邻算法。</p><h3 id="k近邻模型">2.k近邻模型</h3><p>k近邻的算法非常简单，主要在于距离度量、k值和分类决策三者的选取。</p><ol type="1"><li>度量距离<ol type="1"><li>欧氏距离</li><li>Lp距离（Lp distance）</li><li>Minkowski距离（Minkowski distance）</li></ol></li><li>k值<ol type="1"><li>选小会比较敏感</li><li>增大意味着整体模型变得简单</li></ol></li><li>分类决策<ol type="1"><li>多数表决等价于经验风险最小化</li></ol></li></ol><h3 id="kd树">3.kd树</h3><p>k近邻没有给出一个显式的表达式，而是每一次判定都是需要计算所有点到实例的距离，然后选取最近的k个点表决。所以当总量N越来越大时，算法会变得越来越慢。</p><p>为实现快速k近邻搜索，可以采用特殊结构存储，称为kd树。kd树是二叉树，表示对k维空间的一个划分（partition）。构造kd树相当于不断地用垂直于坐标轴的超平面将k维空间切分，构成一系列的k维超矩形区域。kd树的每个结点对应于一个k维超矩形区域。</p><h4 id="构造">3.1 构造</h4><p>输入：实例</p><p>输出：kd树</p><p>具体构造方式如下：</p><p>输入k维空间数据集：</p><p><span class="math display">\[\mathrm{T}=\left\{\mathrm{x}_{1}, \mathrm{x}_{2}, \ldots,\mathrm{x}_{\mathrm{N}}\right\}\]</span></p><p>其中</p><p><span class="math display">\[x_{i}=\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots,x_{i}^{(k)}\right)^{\mathrm{T}} , i  =1,2, \ldots, \mathrm{N}\]</span></p><ol type="1"><li>构造根节点</li></ol><p>选取<spanclass="math inline">\(x^{(1)}\)</span>为坐标轴（这里也可以从方差最大的开始选），以所有数据的<spanclass="math inline">\(x^{(1)}\)</span>特征的中位数作为切分点，生出深度为1的左右子节点。左小右大。</p><ol start="2" type="1"><li>重复分割</li></ol><p>对深度为j的节点，选取<spanclass="math inline">\(x^{(l)}\)</span>为切分坐标轴，<spanclass="math inline">\(l=j(mod\enspace k)+1\)</span></p><p>生成j+1的左右子节点。</p><ol start="3" type="1"><li>直到两个子区域没有实例</li></ol><h4 id="搜索">3.2 搜索</h4><p>输入：kd树，目标x</p><p>输出：x的最近邻点</p><ol type="1"><li><p>从根节点出发递归地向下访问kd树。若目标点x当前维的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点。直到子结点为叶结点为止。</p></li><li><p>记当前叶节点为最近点</p></li><li><p>检查另一子结点对应的区域是否与以目标点为球心、以目标点与“当前最近点”间的距离为半径的超球体相交。如果相交，移动到另一个子结点进行递归最近邻搜索；如果不相交，向上回退。如果存在更近点则更新最近点。</p></li></ol><p>(4)退回根节点后的最近点即为最近点。</p><h2 id="k-mean">4.k-mean</h2><p>k-means是一种聚类算法，是无监督学习算法。它将训练数据分为k组，每一组是一个簇，随机选择k个实例作为初始的聚类中心点，对于每一个实例，计算它和这k个聚类中心的距离，然后把它分配到与它距离最近的聚类中心所在的簇中去；计算每个簇中所有实例的平均值，作为新的聚类中心点，以此往复，直至聚类中心点不再发生明显变化。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;k-NN和k-mean介绍&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="统计学习" scheme="https://splendidwave.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>统计学习(2)--感知机</title>
    <link href="https://splendidwave.github.io/2022/11/23/2022-11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(2)--%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <id>https://splendidwave.github.io/2022/11/23/2022-11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(2)--%E6%84%9F%E7%9F%A5%E6%9C%BA/</id>
    <published>2022-11-23T02:56:02.000Z</published>
    <updated>2022-12-10T11:55:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>感知机</p><span id="more"></span><h2 id="感知机的定义">1.感知机的定义</h2><p>对于一个输入空间，如果存在一个超平面将实例分为正负两类，那么可以认为输入空间的输出空间可以通过如下函数实现。</p><p><span class="math display">\[f(x)=\operatorname{sign}(w^T \cdot x+b)\]</span></p><p>该模型被称为感知机模型，其中<spanclass="math inline">\(w^T\)</span>和<spanclass="math inline">\(b\)</span>是感知机模型参数，线性方程</p><p><span class="math display">\[w^T \cdot x+b\]</span></p><p>是在特征空间中的一个超平面，其中<spanclass="math inline">\(w\)</span>是超平面的法向量，b是超平面的截距。</p><p><spanclass="math inline">\(\operatorname{sign}\)</span>是符号函数</p><p><span class="math display">\[\operatorname{sign}(x)=\left\{\begin{array}{ll}+1, &amp; x \geqslant 0 \\-1, &amp; x&lt;0\end{array}\right.\]</span></p><h2 id="感知机学习策略">2.感知机学习策略</h2><h3 id="损失函数">2.1 损失函数</h3><p>感知机损失函数的一个自然选择是误分类点的总数，但这样损失函数不是参数<spanclass="math inline">\(w\)</span>、<spanclass="math inline">\(b\)</span>连续可导函数，不容易优化。</p><p>另一个选择是点到超平面S的总距离。</p><p>记空间中点为<span class="math inline">\(X^{(i)}\)</span>，超平面为<span class="math inline">\(w^T \cdot X+b\)</span>，空间中的任意一点到平面的距离 =该点到平面任意一点的向量在平面的法向量上的投影。</p><p><span class="math display">\[\begin{array}{l}D=\left|\frac{w}{\|w\|_{2}} \cdot\left(X^{(i)}-X^{(0)}\right)\right| \\=\left|\frac{1}{\|w\|_{2}} \cdot\left(w^{T} \cdot X^{(i)}-w^{T} \cdotX^{(0)}\right)\right| \\=\left|\frac{1}{\|w\|_{2}} \cdot\left(w^{T} \cdotX^{(i)}+b\right)\right|\end{array}\]</span></p><p>其中<span class="math inline">\(X^{(0)}\)</span>是超平面上的点。</p><p>对于误分类数据<span class="math inline">\(\left(x_{i},y_{i}\right)\)</span>来说，</p><p><span class="math display">\[-y_{i}\left(w^T \cdot x_{i}+b\right)&gt;0\]</span></p><p>假设误分类点集合为<spanclass="math inline">\(M\)</span>,那么所有误分类点到超平面的总距离为</p><p><span class="math display">\[-\frac{1}{\|w\|} \sum_{x_{i} \in M} y_{i}\left(w^T \cdot x_{i}+b\right)\]</span></p><p>不考虑常数<spanclass="math inline">\(\frac{1}{\|w\|}\)</span>,即可得到感知机学习的损失函数。这里省略转置，下同。</p><p><span class="math display">\[L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdot x_{i}+b\right)\]</span></p><p>该损失函数就是感知机的经验风险函数。</p><h3 id="随机梯度下降">2.2 随机梯度下降</h3><p>对于感知机模型来说最优化方法是随机梯度下降法，损失函数如下</p><p><span class="math display">\[\min _{w, b} L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdotx_{i}+b\right)\]</span></p><p>梯度计算如下</p><p><span class="math display">\[\nabla_{w} L(w, b)=-\sum_{x_{j} \in M} y_{i} x_{i} \\\]</span></p><p><span class="math display">\[\nabla_{b} L(w, b)=-\sum_{x_{i} \in M} y_{i}\]</span></p><p>为此选取更新策略为</p><p><span class="math display">\[\begin{array}{c}w \leftarrow w+\eta y_{i} x_{i} \\b \leftarrow b+\eta y_{i}\end{array}\]</span></p><h2 id="收敛性证明">3.收敛性证明</h2><p>将超平面简记为<spanclass="math inline">\(\hat{w}\cdot\hat{x}\)</span></p><p>设训练集线性可分，则存在一个超平面<spanclass="math inline">\(\hat{w}_{opt}\cdot\hat{x}\)</span>使得训练集完全正确分开，令<spanclass="math inline">\(\|\hat{w}_{opt}\|=1\)</span>, 那么对有限的<spanclass="math inline">\(i=1,2,...,N\)</span>均有</p><p><span class="math display">\[y_{i}\left(\hat{w}_{\text {opt }} \cdot\hat{x}_{i}\right)=y_{i}\left(w_{\text {opt }} \cdot x_{i}+b_{\text {opt}}\right) \geqslant \gamma \tag{式1}\]</span></p><p>其中</p><p><span class="math display">\[\gamma=\min _{i}\left\{y_{i}\left(w_{\mathrm{opt}} \cdotx_{i}+b_{\mathrm{opt}}\right)\right\}\]</span></p><p>根据更新公式</p><p><span class="math display">\[\begin{array}{l}w_{k} \leftarrow w_{k-1}+\eta y_{i} x_{i} \\b_{k} \leftarrow b_{k-1}+\eta y_{i}\end{array}\]</span></p><p>可得</p><p><span class="math display">\[\hat{w}_{k}=\hat{w}_{k-1}+\eta y_{i} \hat{x}_{i}\]</span></p><p>假设初始值为<span class="math inline">\(\hat{w}_0 =0\)</span>时,需要k次迭代达到最优值，有</p><p><span class="math display">\[\begin{aligned}\hat{w}_k\cdot\hat{w}_{\text{opt}} &amp; = (\hat{w}_{k-1}+\eta y_{i}\hat{x}_{i})\cdot\hat{w}_{\text{opt}} \\&amp; = \hat{w}_{k-1} \cdot \hat{w}_{\mathrm{opt}}+\eta y_{i}\hat{w}_{\mathrm{opt}} \cdot \hat{x}_{i} \\&amp; \geqslant  \hat{w}_{k-1} \cdot \hat{w}_{\mathrm{opt}}+ \eta \gamma\\&amp; \geqslant \cdots \\&amp; \geqslant  \hat{w}_{0} \cdot \hat{w}_{\mathrm{opt}}+ k\eta \gamma\\&amp;  =  k\eta \gamma\end{aligned}\]</span></p><p>另外有</p><p><span class="math display">\[\begin{aligned}\left\|\hat{w}_{k}\right\|^{2} &amp;=\left\|\hat{w}_{k-1}\right\|^{2}+2\eta y_{i} \hat{w}_{k-1} \cdot\hat{x}_{i}+\eta^{2}\left\|\hat{x}_{i}\right\|^{2} \\&amp;\leqslant\left\|\hat{w}_{k-1}\right\|^{2}+\eta^{2}\left\|\hat{x}_{i}\right\|^{2}\\&amp; \leqslant\left\|\hat{w}_{k-1}\right\|^{2}+\eta^{2} R^{2} \\&amp; \leqslant\left\|\hat{w}_{k-2}\right\|^{2}+2 \eta^{2} R^{2} \\&amp; \leqslant \cdots \\&amp; \leqslant k \eta^{2} R^{2}\end{aligned}\]</span></p><p>结合上述两式可得不等式</p><p><span class="math display">\[k \eta \gamma \leqslant \hat{w}_{k} \cdot \hat{w}_{\mathrm{opt}}\leqslant\left\|\hat{w}_{k}\right\|\left\|\hat{w}_{\mathrm{opt}}\right\|\leqslant \sqrt{k} \eta R\]</span></p><p>即对于k有</p><p><span class="math display">\[k \leqslant\left(\frac{R}{\gamma}\right)^{2}\]</span></p><p>该不等式的意义指出如果空间线性可分，迭代次数是有上界的。</p><h2 id="感知机学习算法的对偶形式">4.感知机学习算法的对偶形式</h2><p>在初始值为0的时候，对于N次迭代后参数<spanclass="math inline">\(w\)</span>、<spanclass="math inline">\(b\)</span>分别为</p><p><span class="math display">\[w=\sum_{i=1}^{N} \alpha_{i} y_{i} x_{i} \tag{式2}\]</span></p><p><span class="math display">\[b=\sum_{i=1}^{N} \alpha_{i} y_{i}\]</span></p><p>其中<span class="math inline">\(\alpha_{i} =\mathrm{n}_{\mathrm{i}}\eta\)</span>，<spanclass="math inline">\(\eta\)</span>为学习率，当<spanclass="math inline">\(\eta=1\)</span>时，<spanclass="math inline">\(\alpha_{i}\)</span>就代表了第<spanclass="math inline">\(i\)</span>个实例由于误分而进行更新的次数。通常这个点会越接近分离超平面，因为这些点比较难被分类，它们对学习结果的影响最大。</p><p>使用(式2)代替损失函数的<spanclass="math inline">\(w\)</span>值，可得对偶形式的训练条件为</p><p>当</p><p><span class="math display">\[y_{i}\left(\sum_{j=1}^{N} \alpha_{j} y_{j} x_{j} \cdot x_{i}+b\right)\leqslant 0\tag{式3}\]</span></p><p>则</p><p><span class="math display">\[\alpha_{i} \leftarrow \alpha_{i}+\eta\]</span></p><p><span class="math display">\[b \leftarrow b+\eta y_{i}\]</span></p><p>由于(式3)中出现了大量内积形式的训练实例，可以预先将训练集的实例计算出来并储存为Gram矩阵</p><p>Gram矩阵的定义是</p><p><span class="math display">\[G=A^{T} A=\left[\begin{array}{c}\mathbf{a}_{1}^{T} \\\mathbf{a}_{2}^{T} \\\vdots \\\mathbf{a}_{n}^{T}\end{array}\right]\left[\begin{array}{llll}\mathbf{a}_{1} &amp; \mathbf{a}_{2} &amp; \cdots &amp; \mathbf{a}_{n}\end{array}\right]\\=\left[\begin{array}{cccc}\mathbf{a}_{1}^{T} \mathbf{a}_{1} &amp; \mathbf{a}_{1}^{T}\mathbf{a}_{2} &amp; \cdots &amp; \mathbf{a}_{1}^{T} \mathbf{a}_{n} \\\mathbf{a}_{2}^{T} \mathbf{a}_{1} &amp; \mathbf{a}_{2}^{T}\mathbf{a}_{2} &amp; \cdots &amp; \mathbf{a}_{2}^{T} \mathbf{a}_{n} \\\mathbf{a}_{n}^{T} \mathbf{a}_{1} &amp; \mathbf{a}_{n}^{T}\mathbf{a}_{2} &amp; \cdots &amp; \mathbf{a}_{n}^{T} \mathbf{a}_{n}\end{array}\right]\]</span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;感知机&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="统计学习" scheme="https://splendidwave.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>统计学习(1)--定义速查</title>
    <link href="https://splendidwave.github.io/2022/11/18/2022-11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(1)--%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://splendidwave.github.io/2022/11/18/2022-11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(1)--%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2022-11-18T07:01:02.000Z</published>
    <updated>2023-04-19T07:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>统计学习/机器学习基本名词解释</p><span id="more"></span><h2 id="人工智能artificial-intelligence-ai">人工智能(ArtificialIntelligence, AI)</h2><p>人工智能指拥有类似与人类的自主思考甚至学习的计算机程序或系统。可分为弱人工智能和强人工智能。</p><h2 id="统计学习statistical-learning">统计学习(StatisticalLearning)</h2><p>统计学习是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。也被称为统计机器学习(statisticalmachine learning)。</p><p>统计学习是机器学习的数学基础。</p><h2 id="机器学习分类">机器学习分类</h2><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210192601.png"alt="思维导图" /><figcaption aria-hidden="true">思维导图</figcaption></figure><h2 id="机器学习流程">机器学习流程</h2><ol type="1"><li>获取数据</li><li>数据洞见与可视化</li><li>数据清洗与预处理</li><li>模型选择与训练</li><li>调整模型</li><li>启动监控与维护系统</li></ol><h2 id="输入空间输出空间特征空间">输入空间、输出空间、特征空间</h2><p>输入与输出所有可能取值的集合分别称为输入空间（inputspace）与输出空间（output space）。这里的空间通常属于欧式空间。</p><p>输入空间的具体输入是一个实例(instance)，通常使用特征向量(featurevector)表示。特征向量所在的空间称为特征空间(feature space)。</p><p>输入变量与输出变量均为连续变量的预测问题称为回归问题；输出变量为有限个离散变量的预测问题称为分类问题；输入变量与输出变量均为变量序列的预测问题称为标注问题。</p><h2 id="符号表示">符号表示</h2><p>在习惯上将输入变量记作X，输出变量记作Y，输入输出变量的取值用小写字母x/y表示。向量通常为列向量</p><p>输入实例x的特征向量记作</p><p><span class="math display">\[x=\left(x^{(1)}, x^{(2)}, \cdots, x^{(i)}, \cdots,x^{(n)}\right)^{\mathrm{T}}\]</span></p><p>其中<span class="math inline">\(x^{(i)}\)</span>表示<spanclass="math inline">\(x\)</span>的<spanclass="math inline">\(i\)</span>个特征，如果是下标<spanclass="math inline">\(x_i\)</span>则表示这是第<spanclass="math inline">\(i\)</span>个变量。</p><p>监督学习训练数据由输入(或特征向量)与输出对构成，通常表示为 <spanclass="math display">\[T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right),\cdots,\left(x_{N}, y_{N}\right)\right\}\]</span></p><h2 id="统计学习三要素">统计学习三要素</h2><p><strong>方法＝模型＋策略＋算法</strong></p><h3 id="模型">模型</h3><p>称由<strong>决策函数</strong>表示的模型为非概率模型，由<strong>条件概率</strong>表示的模型为概率模型。</p><p>所有模型构成的空间称为假设空间(hypothesis space)</p><h3 id="策略">策略</h3><p><strong>损失函数</strong>，使用损失函数(代价函数)度量模型一次预测的好坏（loss function / cost function）</p><p>常用的损失函数有以下几种： 1. 0-1损失函数</p><p><span class="math display">\[L(Y, f(X))=\left\{\begin{array}{ll}1, &amp; Y \neq f(X) \\0, &amp; Y=f(X)\end{array}\right.\]</span></p><ol start="2" type="1"><li>平方损失函数</li></ol><p><span class="math display">\[L(Y, f(X))=(Y-f(X))^{2}\]</span></p><ol start="3" type="1"><li>绝对损失函数</li></ol><p><span class="math display">\[L(Y, f(X))=|Y-f(X)|\]</span></p><ol start="4" type="1"><li>对数损失函数/对数似然损失函数</li></ol><p><span class="math display">\[L(Y, P(Y \mid X))=-\log P(Y \mid X)\]</span></p><p>损失函数值越小，模型就越好。因此可以计算以下损失函数的数学期望</p><p><span class="math display">\[R_{\exp }(f)=E_{P}[L(Y, f(X))]=\int_{xy} L(y, f(x)) P(x, y) \mathrm{d} x\mathrm{~d} y\]</span></p><p>其中<span class="math inline">\(P(x,y)\)</span>服从<spanclass="math inline">\((X,Y)\)</span>的联合概率分布，<spanclass="math inline">\(R_{\exp }(f)\)</span> 被称为风险函数（riskfunction）或 期望损失（expected loss）或<strong>期望风险</strong>。</p><p>但由于联合分布未知，这里需要使用训练集的平均损失<spanclass="math inline">\(R_{\text {emp}}\)</span>来近似估计期望风险，公式如下</p><p><span class="math display">\[R_{\text {emp }}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i},f\left(x_{i}\right)\right)\]</span></p><p>它被称为<strong>经验风险</strong></p><h3 id="算法">算法</h3><p>算法是指学习模型的<strong>具体计算方法</strong>，习可以利用已有的最优化算法，有时也需要开发独自的最优化算法。</p><h2id="经验风险最小化empirical-risk-minimizationerm">经验风险最小化(empiricalrisk minimization，ERM)</h2><p>当样本容量足够大时，经验风险最小化能保证有很好的学习效果，在现实中被广泛采用。公式为</p><p><span class="math display">\[\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i},f\left(x_{i}\right)\right)\]</span></p><p>其中<span class="math inline">\(\mathcal{F}\)</span>为假设空间</p><h2id="结构风险最小化structural-risk-minimizationsrm">结构风险最小化(structuralrisk minimization，SRM)</h2><p>经验风险最小化的准确度取决于样本，为了防止过拟合，提出了结构风险最小化，结构风险最小化等价于正则化（regularization），定义为</p><p><span class="math display">\[R_{\mathrm{sm}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i},f\left(x_{i}\right)\right)+\lambda J(f)\]</span></p><p>其中<spanclass="math inline">\(J(f)为模型的复杂度\)</span>$是系数通常大于0</p><h2 id="模型的训练与评估">模型的训练与评估</h2><h3 id="训练误差与测试误差">训练误差与测试误差</h3><p>数据集通常分为训练集和测试集，在选定损失函数后，训练误差和测试误差成为学习方法评估的标准。</p><p>训练误差的大小，对判断给定的问题是不是一个容易学习的问题是有意义的，但本质上不重要。测试误差反映了学习方法对未知的测试数据集的预测能力，是学习中的重要概念。显然，给定两种学习方法，测试误差小的方法具有更好的预测能力，是更有效的方法。通常将学习方法对未知数据的预测能力称为泛化能力（generalizationability）</p><h3 id="过拟合">过拟合</h3><p>如果一味追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高。这种现象称为过拟合（over-fitting）。过拟合是指学习时选择的模型所包含的参数过多，以致于出现这一模型对已知数据预测得很好，但对未知数据预测得很差的现象。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210192722.png"alt="训练误差与测试误差" /><figcaption aria-hidden="true">训练误差与测试误差</figcaption></figure><h3 id="正则化">正则化</h3><p>为对抗过拟合的情况，一个典型的方法是引入正则化（regularization），正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大。一般形式如下</p><p><span class="math display">\[\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i},f\left(x_{i}\right)\right)+\lambda J(f)\]</span></p><p>其中第一项是经验风险，第二项是正则化项，<spanclass="math inline">\(\lambda\)</span>是两者关系系数，其值大于0</p><p>通常会使用2范数来作为正则项</p><p><span class="math display">\[L(w)=\frac{1}{N} \sum_{i=1}^{N}\left(f\left(x_{i} ;w\right)-y_{i}\right)^{2}+\frac{\lambda}{2}\|w\|^{2}\]</span></p><p>其中<span class="math inline">\(w\)</span>是特征向量，<spanclass="math inline">\(\|w\|^2\)</span>是向量<spanclass="math inline">\(w\)</span>的2范数</p><h3 id="交叉验证">交叉验证</h3><p>如果给定的样本数据充足，进行模型选择的一种简单方法是随机地将数据集切分成三部分，分别为训练集（trainingset）、验证集（validation set）和测试集（test set）。</p><p>但是，在许多实际应用中数据是不充足的。为了选择好的模型，可以采用交叉验证方法。可以重复多少使用数据。</p><ol type="1"><li><p>简单交叉验证随机将数据分为训练集(通常为70%)和测试集(通常为30%)。</p></li><li><p>S折交叉验证（S-fold cross validation）首先随机地将已给数据切分为S个互不相交的大小相同的子集；然后利用S-1个子集的数据训练模型，利用余下的子集测试模型；将这一过程对可能的S种选择重复进行；最后选出S次评测中平均测试误差最小的模型。</p></li><li><p>留一交叉验证（leave-one-out cross validation）将S折的S取为N，这里N是数据集的总容量。</p></li></ol><h2 id="生成模型与判别模型">生成模型与判别模型</h2><ol type="1"><li>生成模型</li></ol><p>生成方法（generativeapproach）由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型：</p><p><span class="math display">\[P(Y \mid X)=\frac{P(X, Y)}{P(X)}\]</span></p><p>模型表示了给定输入X产生输出Y的生成关系。典型的生成模型有：朴素贝叶斯法和隐马尔可夫模型</p><ol start="2" type="1"><li>判别模型</li></ol><p>判别方法（discriminativeapproach）直接学习决策函数f(X)或者条件概率分布P(Y|X)作为预测的模型，即判别模型。</p><p>典型的判别模型包括：k近邻法、感知机、决策树、逻辑斯谛回归模型、最大熵模型、支持向量机。</p><h2 id="问题分类">问题分类</h2><h3 id="分类问题">分类问题</h3><p>算法从数据中学习一个分类模型或分类决策函数，称为分类器（classifier）。分类器对新的输入进行输出的预测（prediction），称为分类（classification）。可能的输出称为类（class）。</p><p>评价分类器性能的指标一般是分类准确率（accuracy）也就是损失函数为0-1损失函数时测试集上的准确率。</p><p>分类最常见的是二分问题，当然其他分类其实也可以归为多个二分问题。对于二类分类问题常用的评价指标是精确率（precision）与召回率（recall）。将关注的类记为<strong>正类</strong>，其他类为<strong>负类</strong>，根据模型判别的对错可以分为四种情况，将他们出现的总是记为如下符号</p><p>TP——将正类预测为正类数； FN——将正类预测为负类数；FP——将负类预测为正类数； TN——将负类预测为负类数。</p><p><strong>精准率</strong>的定义为</p><p><span class="math display">\[P=\frac{T P}{T P+F P}\]</span></p><p><strong>召回率</strong>的定义为</p><p><span class="math display">\[R=\frac{T P}{T P+F N}\]</span></p><p><strong><spanclass="math inline">\(F_1\)</span>值</strong>是，精准率和召回率的调和均值</p><p><span class="math display">\[\frac{2}{F_1}=\frac{1}{P}+\frac{1}{R}\]</span></p><p><span class="math display">\[F_1=\frac{2 T P}{2 T P+F P+F N}\]</span></p><p><strong>混淆矩阵</strong>（ConfusionMatrix），又称为可能性矩阵或错误矩阵。是分类结果的一个可视化表现。形如</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210192755.png"alt="混淆矩阵" /><figcaption aria-hidden="true">混淆矩阵</figcaption></figure><h3 id="标注问题">标注问题</h3><p>标注（tagging）可以认为是分类问题的一个推广，输入是一组序列，输出也是一组序列。</p><h3 id="回归问题">回归问题</h3><p>回归（regression）用于预测输入变量（自变量）和输出变量（因变量）之间的关系，特别是当输入变量的值发生变化时，输出变量的值随之发生的变化。</p><p>回归学习最常用的损失函数是平方损失函数，在此情况下，回归问题可以由著名的最小二乘法（leastsquares）求解。</p><h2 id="梯度下降法">梯度下降法</h2><p>梯度下降法（Gradientdescent）是迭代法的一种，利用求偏导的方法更新参数，实现找到极值。公式如下</p><p><span class="math display">\[w_{i+1}=w_{i}-\alpha * \frac{d L}{d w_{i}}\]</span></p><p>其中<spanclass="math inline">\(\alpha\)</span>是学习率，其值影响迭代的速度，过大可能导致不收敛，过小收敛速度慢，且可能会陷入局部最优解。</p><p>批量梯度下降（Batch GradientDescent，BGD）每一次迭代会对所有样本进行计算，具有全局性，但计算量大</p><p>随机梯度下降（Stochastic GradientDescent，SGD）随机梯度下降是每次迭代使用一个样本来对参数进行更新，速度快但准确度可能会下降</p><p>小批量梯度下降（Mini-Batch Gradient Descent,MBGD）中和上述两者特性</p><h2 id="感知机">感知机</h2><p>感知机（perceptron）是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，其通过一个超平面分离，输出取+1和–1二值。</p><p>单个感知机不能处理异或问题，多个感知机可以构成神经网络。</p><h2 id="支持向量机">支持向量机</h2><p>支持向量机的学习的目标也是在特征空间中找到一个分离超平面，能将实例分到不同的类。不同与感知机的解有无穷多个，线性可分支持向量机利用间隔最大化求最优分离超平面，解是唯一的。</p><p>支持向量机可以通过变换处理非线性分类问题。</p><h2 id="k近邻算法">k近邻算法</h2><p>k近邻法（k-nearest neighbor，k-NN）是一种基本分类与回归方法。</p><p>k近邻法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。</p><p>具体对于新的实例x，在训练集中找到与之相邻的k个实例，这k个实例的多数属于哪一类，就把这个实例分到哪一类中。当k为1时，称为最近邻算法。</p><h2 id="k-mean">k-mean</h2><p>k-means是一种聚类算法，是无监督学习算法。它将训练数据分为k组，每一组是一个簇，随机选择k个实例作为初始的聚类中心点，对于每一个实例，计算它和这k个聚类中心的距离，然后把它分配到与它距离最近的聚类中心所在的簇中去；计算每个簇中所有实例的平均值，作为新的聚类中心点，以此往复，直至聚类中心点不再发生明显变化。</p><h2 id="朴素贝叶斯">朴素贝叶斯</h2><p>朴素贝叶斯对实际问题进行了简化假设，利用概率最大这一符合人脑对事物的判断的方法实现对输入实例的分类。</p><h2 id="决策树">决策树</h2><p>分类决策树从根节点开始对实例的某个特征进行测试判别，然后将实例分配到对应节点，反复递归最终实现实例的全部分类。</p><p>决策树的特性决定了它会倾向于多分类，为此需要使用剪枝或修改判别依据来优化模型。</p><h2 id="逻辑斯谛回归">逻辑斯谛回归</h2><p>逻辑斯谛回归模型利用了逻辑斯谛方程的对数特性，将特征参数映射到[0，1]之间，将问题转换为概率预测，从而实现判别。</p><h2 id="最大熵">最大熵</h2><p>最大熵原理是概率模型学习的一个准则。其观点认为熵最大的模型就是最好的模型。</p><!-- ## 提升## EM算法## 隐马尔可夫模型## 条件随机场 -->]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;统计学习/机器学习基本名词解释&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="统计学习" scheme="https://splendidwave.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>opencv-python学习(6)--六个图像处理小项目</title>
    <link href="https://splendidwave.github.io/2022/10/29/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(6)--%E5%85%AD%E4%B8%AA%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    <id>https://splendidwave.github.io/2022/10/29/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(6)--%E5%85%AD%E4%B8%AA%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%B0%8F%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-10-29T07:47:32.000Z</published>
    <updated>2022-12-10T12:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>opencv的python图像处理学习笔记</p><p>转像素画、转字符画、图片九宫格、图片蒙太奇、幻影坦克、证件照裁剪。</p><p>部分代码参考互联网。 <span id="more"></span></p><h2 id="图像转像素画">1.图像转像素画</h2><p>效果如下</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200353.png"alt="可莉像素" /><figcaption aria-hidden="true">可莉像素</figcaption></figure><p>实现原理是通过将图片缩小10倍，然后用最邻近插值放大回原来的尺寸。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 图片像素化</span><br><span class="line">def pixel_image(self):</span><br><span class="line">    img = self.image.copy()</span><br><span class="line">    rows, cols = img.shape[:2]</span><br><span class="line">    img = cv2.resize(img,(cols//10,rows//10))</span><br><span class="line">    img = cv2.resize(img,(cols,rows),interpolation=cv2.INTER_NEAREST)</span><br><span class="line">    win_name = &quot;pixel&quot;</span><br><span class="line">    UIFunctions.wait_key(self,img,win_name)</span><br></pre></td></tr></table></figure><p>其中<code>wait_key</code>函数内容是用opencv打开图片，然后接受一些保存等指令的函数。</p><h2 id="图片转字符画">2.图片转字符画</h2><p>效果图</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200413.jpg"alt="字符画" /><figcaption aria-hidden="true">字符画</figcaption></figure><p>原理是把图片转为灰度，然后根据灰度值将像素替换为对应字重的字符最后保存为txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 转为字符画</span><br><span class="line">def character_image(self):</span><br><span class="line">    img = UIFunctions.trun_gray(self,self.image)</span><br><span class="line">    rows, cols = img.shape[:2]</span><br><span class="line">    rows = rows//2</span><br><span class="line">    img = cv2.resize(img,(cols,rows))</span><br><span class="line">    lstChars = self.config.get(&#x27;General&#x27;,&#x27;file_character_list&#x27;)</span><br><span class="line">    output = self.config.get(&#x27;General&#x27;,&#x27;file_save_path&#x27;) + &quot;\\character.txt&quot;</span><br><span class="line">    g2c = 256/len(lstChars)</span><br><span class="line">    </span><br><span class="line">    txt = &quot;&quot;</span><br><span class="line">    for i in range(rows):</span><br><span class="line">        for j in range(cols):</span><br><span class="line">            txt += lstChars[int(img[i,j]/g2c)]</span><br><span class="line">        txt += &#x27;\n&#x27;</span><br><span class="line"></span><br><span class="line">    with open(output, &#x27;w&#x27;) as f:</span><br><span class="line">        f.write(txt)</span><br><span class="line">    QMessageBox.information(None, &#x27;提示&#x27;, &#x27;character.txt输出成功&#x27;,QMessageBox.Ok)</span><br></pre></td></tr></table></figure><p>为了表现效果，这里将高缩了一半。output是文件路径，lstChars是自定义的字符。上图使用的字符串是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$B8&amp;WM*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|1?-_+~&lt;&gt;i!lI,^`.</span><br></pre></td></tr></table></figure><p>注意把字重大的放前面。</p><h2 id="图片九宫格">3.图片九宫格</h2><p>图片九宫格是发朋友圈常用的一种格式，该项目可以辅助将一张图片切割成9张。</p><p>效果</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200430.png"alt="图片九宫格" /><figcaption aria-hidden="true">图片九宫格</figcaption></figure><p>这个没啥说的就是切一下图片,因为懒得pip没用PIL库就直接对数组操作了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 九宫格</span><br><span class="line">def ninegrid_image(self):</span><br><span class="line">    # 切片函数</span><br><span class="line">    def cut_image(img,width):</span><br><span class="line">        box_list = []</span><br><span class="line">        if len(img.shape) == 2:</span><br><span class="line">            for i in range(0, 3):</span><br><span class="line">                for j in range(0, 3):</span><br><span class="line">                    box = img[i * width:(i+1) * width, j * width : (j + 1) * width]</span><br><span class="line">                    box_list.append(box)</span><br><span class="line">        elif len(img.shape) == 3:</span><br><span class="line">            for i in range(0, 3):</span><br><span class="line">                for j in range(0, 3):</span><br><span class="line">                    box = img[i * width:(i+1) * width, j * width : (j + 1) * width,:]</span><br><span class="line">                    box_list.append(box)</span><br><span class="line">        return box_list</span><br><span class="line"></span><br><span class="line">    img = self.image.copy()</span><br><span class="line">    value, ok = QInputDialog.getInt(self, &quot;输入窗口&quot;, &quot;请输入裁剪后的边值像素(正方形):&quot;, 300, 0, 2000, 100)</span><br><span class="line">    if ok:</span><br><span class="line">        value = int(value)*3</span><br><span class="line">        img = cv2.resize(img,(value,value))</span><br><span class="line">        box_list = cut_image(img,value//3)</span><br><span class="line">        for i,box in enumerate(box_list):</span><br><span class="line">            save_name = self.config.get(&#x27;General&#x27;,&#x27;file_save_path&#x27;) + &#x27;\\ninegrid_image\\&#x27; + str(i+1)+&#x27;.png&#x27;</span><br><span class="line">            cv2.imwrite(save_name,box)</span><br><span class="line">        QMessageBox.information(None, &#x27;提示&#x27;, &#x27;ninegrid_image输出成功&#x27;,QMessageBox.Ok)</span><br></pre></td></tr></table></figure><h2 id="图片蒙太奇">4.图片蒙太奇</h2><p>图片蒙太奇是指用一组图片去组合成一张大图的艺术效果。</p><p>图片有点大，放本地打开后再截图的图。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200548.jpg"alt="蒙太奇" /><figcaption aria-hidden="true">蒙太奇</figcaption></figure><p>代码主要参考CSDN<ahref="https://blog.csdn.net/Galen_xia/article/details/107955374">蒙太奇照片制作(Opencv+Python)</a></p><p>原理是缩放待处理图片，然后匹配区块和图片的直方图找到最合适的，最后做一个融合让效果变好些。</p><p>理论上图库内容丰富越好。</p><h2 id="幻影坦克">5.幻影坦克</h2><p>幻影坦克是现代互联网图片表示的艺术，缩略图上看是一张图，但实际点开就变成了另一张，常见于贴吧。</p><p>效果图</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200449.jpg"alt="幻影坦克" /><figcaption aria-hidden="true">幻影坦克</figcaption></figure><p>原理参考b站小迷糊老师的视频《<ahref="https://www.bilibili.com/video/BV1kV411v7fR/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">幻影坦克基础版</a>》</p><p>简单讲就是利用背景白色和黑色来叠加出不一样的图片。</p><p>灰度处理方面借用了《<ahref="https://blog.csdn.net/WinkySpeed/article/details/127079909">基于OpenCV实现的灰度图幻影坦克</a>》一文的思路</p><p>代码 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 幻影坦克</span><br><span class="line">def mirage_tank_image(self):</span><br><span class="line">    inside_pic = np.uint8(self.image.copy() * 0.35)</span><br><span class="line">    h,w = inside_pic.shape[:2]</span><br><span class="line">    get_filename_path, ok = QFileDialog.getOpenFileName(self,&quot;选取表图&quot;,self.config.get(&#x27;General&#x27;,&#x27;file_open_path&#x27;))</span><br><span class="line">    if ok:</span><br><span class="line">        out_pic = cv2.imread(get_filename_path)</span><br><span class="line">        # 调整表图大小 与里图一致</span><br><span class="line">        out_pic = cv2.resize(out_pic,(w,h))</span><br><span class="line">        # 如果强度小于100 拉到100</span><br><span class="line">        out_pic[out_pic&lt;100] = 100</span><br><span class="line">        # 转变为灰度图</span><br><span class="line">        inside_pic = UIFunctions.trun_gray(self,inside_pic)</span><br><span class="line">        out_pic = UIFunctions.trun_gray(self,out_pic)</span><br><span class="line">        # 建立新的画布 </span><br><span class="line">        new_pic = np.zeros((h,w,4), np.uint8)</span><br><span class="line">        # print(new_pic.shape)</span><br><span class="line">        # 遍历图片 套用公式</span><br><span class="line">        for i in range(h):</span><br><span class="line">            for j in range(w):</span><br><span class="line">                alpha = 255 - (out_pic[i,j]-inside_pic[i,j])</span><br><span class="line">                if alpha == 0:</span><br><span class="line">                    alpha = 1</span><br><span class="line">                p_new = np.uint8(255*inside_pic[i,j]/alpha)</span><br><span class="line">                new_pic[i,j,0] = p_new</span><br><span class="line">                new_pic[i,j,1] = p_new</span><br><span class="line">                new_pic[i,j,2] = p_new</span><br><span class="line">                new_pic[i,j,3] = alpha</span><br><span class="line">        win_name = &quot;tank&quot;</span><br><span class="line">        UIFunctions.wait_key(self,new_pic,win_name)</span><br></pre></td></tr></table></figure></p><h2 id="证件照处理">6.证件照处理</h2><p>如果你对证件照态度比较随便的话，可以直接用手机背靠墙拍一张，然后用这个方法处理，直接用打印机打印出来。</p><p>效果图</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200512.jpg"alt="证件照" /><figcaption aria-hidden="true">证件照</figcaption></figure><p>原理是建立对应大小的画布，然后把图片处理成1或2寸的，贴到对应位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"># 证件照处理</span><br><span class="line">def certificate_image(self):</span><br><span class="line">    # 1寸大小</span><br><span class="line">    WIDTH_1IN = 295</span><br><span class="line">    HEIGHT_1IN = 413</span><br><span class="line">    # 2寸大小</span><br><span class="line">    WIDTH_2IN = 413</span><br><span class="line">    HEIGHT_2IN = 626</span><br><span class="line">    # 5寸大小</span><br><span class="line">    WIDTH_5IN = 1500</span><br><span class="line">    HEIGHT_5IN = 1050</span><br><span class="line">    # 非全景6寸照片</span><br><span class="line">    WIDTH_6IN = 1950</span><br><span class="line">    HEIGHT_6IN = 1300</span><br><span class="line">    def cut_photo(photo,choice):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        将照片按照比例进行裁剪并缩放成1寸、2寸</span><br><span class="line">        :param photo: 待处理的照片</span><br><span class="line">        :param choice: &lt;int&gt; 1代表1寸，2代表2寸</span><br><span class="line">        :return: 处理后的照片</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        h,w = photo.shape[:2]</span><br><span class="line">        rate = h / w</span><br><span class="line">        if choice == 1:</span><br><span class="line">            if rate &lt; (HEIGHT_1IN/WIDTH_1IN):</span><br><span class="line">                cut = int((w - int(h / HEIGHT_1IN * WIDTH_1IN)) / 2)</span><br><span class="line">                cut_p = photo[:,cut:w-cut,:]</span><br><span class="line">            else:</span><br><span class="line">                cut = int((h - int(w / WIDTH_1IN * HEIGHT_1IN)) / 2)</span><br><span class="line">                cut_p = photo[cut:w-cut,:,:]</span><br><span class="line">            return cv2.resize(cut_p, (WIDTH_1IN, HEIGHT_1IN))</span><br><span class="line">        if choice == 2:</span><br><span class="line">            if rate &lt; (HEIGHT_2IN/WIDTH_2IN):</span><br><span class="line">                cut = int((w - int(h / HEIGHT_2IN * WIDTH_2IN)) / 2)</span><br><span class="line">                cut_p = photo[:,cut:w-cut,:]</span><br><span class="line">            else:</span><br><span class="line">                cut = int((h - int(w / WIDTH_2IN * HEIGHT_2IN)) / 2)</span><br><span class="line">                cut_p = photo[cut:w-cut,:,:]</span><br><span class="line">            return cv2.resize(cut_p, (WIDTH_2IN, HEIGHT_2IN))</span><br><span class="line"></span><br><span class="line">    # 5寸照排版1</span><br><span class="line">    def layout_photo_5_1(photo):</span><br><span class="line">        photo = cut_photo(photo,1)</span><br><span class="line">        img = np.ones((HEIGHT_5IN,WIDTH_5IN, 3), np.uint8)*255</span><br><span class="line">        img[HEIGHT_5IN//2,:,:] = 128            # 横线</span><br><span class="line">        img[:,int(WIDTH_5IN*0.25),:] = 128      # 竖线1</span><br><span class="line">        img[:,int(WIDTH_5IN*0.5),:] = 128      # 竖线2</span><br><span class="line">        img[:,int(WIDTH_5IN*0.75),:] = 128      # 竖线3</span><br><span class="line">        # 确定位置放上图片</span><br><span class="line">        focus_point = [0.125 * WIDTH_5IN,0.25 * HEIGHT_5IN]</span><br><span class="line">        start_point = [focus_point[0] - 0.5 * WIDTH_1IN, focus_point[1] - 0.5 * HEIGHT_1IN]</span><br><span class="line">        end_point = [focus_point[0] + 0.5 * WIDTH_1IN, focus_point[1] + 0.5 * HEIGHT_1IN]</span><br><span class="line">        for i in range(0,2):</span><br><span class="line">            for j in range(0,4):</span><br><span class="line">                img[int(start_point[1]+0.5*i*HEIGHT_5IN):int(end_point[1]+0.5*i*HEIGHT_5IN),int(start_point[0]+j*WIDTH_5IN/4):int(end_point[0]+j*WIDTH_5IN/4),:] = photo</span><br><span class="line">        return img</span><br><span class="line">    # 5寸混合排版2</span><br><span class="line">    def layout_photo_5_mix(photo):</span><br><span class="line">        photo1 = cut_photo(photo,1)</span><br><span class="line">        photo2 = cut_photo(photo,2)</span><br><span class="line">        photo2 = np.rot90(photo2)</span><br><span class="line">        img = np.ones((HEIGHT_5IN,WIDTH_5IN, 3), np.uint8)*255</span><br><span class="line">        img[HEIGHT_5IN//2,:,:] = 128            # 横线</span><br><span class="line">        img[:,int(WIDTH_5IN*0.25),:] = 128      # 竖线1</span><br><span class="line">        img[:,int(WIDTH_5IN*0.5),:] = 128      # 竖线2</span><br><span class="line">        # 确定位置放上1寸图片</span><br><span class="line">        focus_point = [0.125 * WIDTH_5IN,0.25 * HEIGHT_5IN]</span><br><span class="line">        start_point = [focus_point[0] - 0.5 * WIDTH_1IN, focus_point[1] - 0.5 * HEIGHT_1IN]</span><br><span class="line">        end_point = [focus_point[0] + 0.5 * WIDTH_1IN, focus_point[1] + 0.5 * HEIGHT_1IN]</span><br><span class="line">        for i in range(0,2):</span><br><span class="line">            for j in range(0,2):</span><br><span class="line">                img[int(start_point[1]+0.5*i*HEIGHT_5IN):int(end_point[1]+0.5*i*HEIGHT_5IN),int(start_point[0]+j*WIDTH_5IN/4):int(end_point[0]+j*WIDTH_5IN/4),:] = photo1</span><br><span class="line">        # 确定位置放上2寸图片</span><br><span class="line">        focus_point2 = [0.75 * WIDTH_5IN, 0.25 * HEIGHT_5IN]</span><br><span class="line">        start_point2 = [focus_point2[0] - 0.5 * HEIGHT_2IN, focus_point2[1] - 0.5 * WIDTH_2IN]</span><br><span class="line">        end_point2 = [focus_point2[0] + 0.5 * HEIGHT_2IN, focus_point2[1] + 0.5 * WIDTH_2IN]</span><br><span class="line">        img[int(start_point2[1]):int(end_point2[1]),int(start_point2[0]):int(end_point2[0]),:] = photo2</span><br><span class="line">        img[int(start_point2[1]+ 0.5 * HEIGHT_5IN):int(end_point2[1]+ 0.5 * HEIGHT_5IN),int(start_point2[0]):int(end_point2[0]),:] = photo2</span><br><span class="line">        return img</span><br><span class="line">    # 6寸混合排版1</span><br><span class="line">    def layout_photo_6_mix(photo):</span><br><span class="line">        photo1 = cut_photo(photo,1)</span><br><span class="line">        photo2 = cut_photo(photo,2)</span><br><span class="line">        photo1 = np.rot90(photo1)</span><br><span class="line">        img = np.ones((HEIGHT_6IN,WIDTH_6IN, 3), np.uint8)*255</span><br><span class="line">        img[HEIGHT_6IN//2,:,:] = 128            # 横线1</span><br><span class="line">        img[HEIGHT_6IN//4,:WIDTH_6IN//2,:] = 128 # 横线2</span><br><span class="line">        img[int(HEIGHT_6IN*0.75),:WIDTH_6IN//2,:] = 128 # 横线2</span><br><span class="line">        img[:,int(WIDTH_6IN*0.25),:] = 128      # 竖线1</span><br><span class="line">        img[:,int(WIDTH_6IN*0.5),:] = 128      # 竖线2</span><br><span class="line">        img[:,int(WIDTH_6IN*0.75),:] = 128      # 竖线3</span><br><span class="line">        # 确定位置放上1寸图片</span><br><span class="line">        focus_point = [0.125 * WIDTH_6IN, 0.125 * HEIGHT_6IN]</span><br><span class="line">        start_point = [focus_point[0] - 0.5 * HEIGHT_1IN, focus_point[1] - 0.5 * WIDTH_1IN]</span><br><span class="line">        end_point = [focus_point[0] + 0.5 * HEIGHT_1IN, focus_point[1] + 0.5 * WIDTH_1IN]</span><br><span class="line">        for i in range(0,4):</span><br><span class="line">            for j in range(0,2):</span><br><span class="line">                img[int(start_point[1]+0.25*i*HEIGHT_6IN):int(end_point[1]+0.25*i*HEIGHT_6IN),int(start_point[0]+j*WIDTH_6IN/4):int(end_point[0]+j*WIDTH_6IN/4),:] = photo1</span><br><span class="line">        # 确定位置放上2寸图片</span><br><span class="line">        focus_point2 = [0.625 * WIDTH_6IN, 0.25 * HEIGHT_6IN]</span><br><span class="line">        start_point2 = [focus_point2[0] - 0.5 * WIDTH_2IN, focus_point2[1] - 0.5 * HEIGHT_2IN]</span><br><span class="line">        end_point2 = [focus_point2[0] + 0.5 * WIDTH_2IN, focus_point2[1] + 0.5 * HEIGHT_2IN]</span><br><span class="line">        for i in range(0,2):</span><br><span class="line">            for j in range(0,2):</span><br><span class="line">                img[int(start_point2[1]+0.5*i*HEIGHT_6IN):int(end_point2[1]+0.5*i*HEIGHT_6IN),int(start_point2[0]+j*WIDTH_6IN/4):int(end_point2[0]+j*WIDTH_6IN/4),:] = photo2</span><br><span class="line"></span><br><span class="line">        return img</span><br><span class="line"></span><br><span class="line">    img = self.image.copy()</span><br><span class="line">    items = (&#x27;1寸&#x27;, &#x27;2寸&#x27;, &#x27;5寸(8*1寸)&#x27;, &#x27;5寸(4*1寸+2*2寸)&#x27;, &#x27;6寸(8*1寸+4*2寸)&#x27;)</span><br><span class="line">    item,ok = QInputDialog.getItem(self,&quot;区域分割&quot;,&quot;选择需要分成几块&quot;,items,3,False)</span><br><span class="line">    if ok:</span><br><span class="line">        if item == &#x27;1寸&#x27;:</span><br><span class="line">            img = cut_photo(img,1)</span><br><span class="line">        elif item == &#x27;2寸&#x27;:</span><br><span class="line">            img = cut_photo(img,2)</span><br><span class="line">        elif item == &#x27;5寸(8*1寸)&#x27;:</span><br><span class="line">            img = layout_photo_5_1(img)</span><br><span class="line">        elif item == &#x27;5寸(4*1寸+2*2寸)&#x27;:</span><br><span class="line">            img = layout_photo_5_mix(img)</span><br><span class="line">        elif item == &#x27;6寸(8*1寸+4*2寸)&#x27;:</span><br><span class="line">            img = layout_photo_6_mix(img)</span><br><span class="line"></span><br><span class="line">        win_name = &quot;ID photo&quot;</span><br><span class="line">        UIFunctions.wait_key(self,img,win_name)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;opencv的python图像处理学习笔记&lt;/p&gt;
&lt;p&gt;转像素画、转字符画、图片九宫格、图片蒙太奇、幻影坦克、证件照裁剪。&lt;/p&gt;
&lt;p&gt;部分代码参考互联网。</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://splendidwave.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv-python学习(5)--傅里叶变换与小波变换</title>
    <link href="https://splendidwave.github.io/2022/10/25/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(5)--%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/"/>
    <id>https://splendidwave.github.io/2022/10/25/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(5)--%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/</id>
    <published>2022-10-25T04:51:22.000Z</published>
    <updated>2022-12-10T12:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>opencv的python图像处理学习笔记</p><p>从空间基的角度介绍小波变换</p><span id="more"></span><h2 id="信号的数学表示">1. 信号的数学表示</h2><p>人类探索自然的工具是数学，为此探索的第一步就是将现实中的事物映射到数学上。</p><p>函数就是很好的工具，甚至可以将抽象的数学用图像的方法在坐标系中表示出来。比如一个阶跃信号，被表示为了一个幅值随时间变化的函数。它可以在平面直角坐标系中表示出来，其中横坐标代表时间，纵坐标是幅值。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200322.jpg"alt="阶跃信号" /><figcaption aria-hidden="true">阶跃信号</figcaption></figure><h2 id="距离与度量空间">2.距离与度量空间</h2><p>上面这图是使用Matlab绘制的，看着是连续的线，但实际上只是先绘制了一些离散的点，然后连接成线的。</p><p>平面上的点<spanclass="math inline">\(p_1\)</span>由两个坐标构成，一个是时间<spanclass="math inline">\(x_1\)</span>，一个是幅值<spanclass="math inline">\(y_1\)</span></p><p>平面集合中的两个元素<spanclass="math inline">\(p_1,p_2\)</span>，在数学上可以引入<strong>距离</strong>的概念，定义为<spanclass="math inline">\(d(p_1,p_2)\)</span>,该距离函数被称为空间集合上的度量，<strong>有距离函数的空间集合就称为度量空间。</strong></p><p>这里为便于理解就不给出严格的数学定义，下同。</p><h2 id="范数与赋范空间">3.范数与赋范空间</h2><p>有了度量函数就可以度量距离了，但是对于单个点的距离或者说是向量还没有办法度量。</p><p>如果你认为和零点的距离不就是向量的距离吗，那非常好，这个空间的范数就已经被定义了，<strong>拥有范数函数的空间集合就称为赋范空间。</strong></p><p>显而易见赋范空间应该包含于度量空间。</p><h2 id="线性空间内积空间与正交性">4.线性空间、内积空间与正交性</h2><p>线性空间的概念就非常熟悉了，满足加法的交换律结合律，乘法的分配律等就是线性空间，线性空间的好处在于任何一个元素都可以使用一组基来线性表示。</p><p>对于一个线性赋范空间，如果赋予它内积的运算，它就被称为内积空间，这个运算的数学上的意义是为了能将矢量转换为标量，显而易见内积空间应该包含于线性赋范空间。</p><p>当两个向量的内积为0时，这两个向量相互正交，如果一组基两两正交，则称这组基是正交基。</p><h2 id="希尔伯特空间">5.希尔伯特空间</h2><p>对于上图信号所处的空间来说，是一个简单的二维线性内积空间，其中维度就是指需要多少个值来描述空间中的一个元素。</p><p>因为它的坐标集合是实数集，所以这个空间又是完备的，有限维度的完备内积空间被数学家称为欧几里德空间。（完备性要求度量空间中的所有柯西序列都收敛于该空间的一点）</p><p>一个有限维度的空间只能表达低于该维度的函数，比如在平面直角坐标系中只能表示一维函数，曲面就需要在三维欧几里德空间中才能画出来。</p><p>维度是一方面的局限，另一个可以简化问题的决策在于基的选择。同样是二维的欧几里德空间，表示一个半径为1的圆，使用<span class="math inline">\(x\)</span>,<spanclass="math inline">\(y\)</span>方向的单位向量作为基底，可以写作<spanclass="math inline">\(x^2+y^2=1\)</span>，而在极坐标下只需要写<spanclass="math inline">\(r=1\)</span></p><p>假如有一个空间是无限维的，同时有很多基底供你选择，这样一个空间是不是很棒呢？实际上这也是科学家一直在努力的方向。一个维度不受限的欧几里德空间被称为希尔伯特空间。</p><h2 id="傅里叶变换与短时傅里叶变换">6.傅里叶变换与短时傅里叶变换</h2><p>希尔伯特空间维度是任意的n维，坐标轴的取值也可以从实数拓展到虚数，人类无法想象这个空间，但数学可以将它抽象出来。为方便理解，我们还是以欧几里德空间来想象它。</p><p>有了希尔伯特空间算是解决的第一个问题，无限维的好处是特征有无限多，任何的低维信号在希尔伯特空间都可以映射成向量。现在需要选取一些合适的基，最好的最容易理解和接受的基仍然是沿着假想中的坐标轴的单位向量。</p><p>其次是傅里叶提出的三角函数正交基，三角函数的正交性证明感兴趣的可以见参考资料<ahref="#refer-anchor-1"><sup>[4]</sup></a></p><p>傅里叶变换的本质就是在希尔伯特空间换了一组基来表示一个信号。为了区分，把以时间方向为基的表示称为时域表示，三角函数基称为频域表示。这一对表示有着非常有意思的性质，他们互为倒空间，在时域上极短的信号体现在频域上就是无限长，反过来也一样。</p><p>傅里叶变换很好用，但同时也有它的局限性，因为过多关注了频域，对于时域的信息反而获取不到。对于特定的情况，傅里叶变换后的信号可能没这么容易获取信息。</p><p>比如对于一个频率随时间变换的信号，出来的图像如图，上图表示时域信号，下图为频域信号</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210195716.jpg"alt="傅里叶变换的局限" /><figcaption aria-hidden="true">傅里叶变换的局限</figcaption></figure><p>可以看出频谱除了有4个比较明显的峰外还有许多振荡，而且没法体现出在时域信号中频率随时间变化这一显著的特点。</p><p>所以为了解决这一问题，短时傅里叶变换被提了出来。既然时间信息丢失了，那就补上，短时傅里叶变换和傅里叶变换唯一的区别在于多了一个窗口函数，用一个窗函数去框选时域信号，然后对这一部分再做傅里叶变换，这体现在空间中就是多了一个维度，用热力图来表示如下。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210195656.jpg"alt="短时傅里叶变换" /><figcaption aria-hidden="true">短时傅里叶变换</figcaption></figure><p>短时傅里叶变换就很明显的表现出了时间上的频率变换，但问题在于要怎么知道这个窗口选多大才是合理的，选大了就会出现和傅里叶变换一样的问题出现时域信息丢失，选小了会让频域上的分辨率降低，这里倒是有点测不准原理的感觉了。</p><h2 id="小波变换">7.小波变换</h2><p>不知道该多大的窗口那不如把窗口也变为可变的，不过这样一来，维度又会多了一维，在三维空间里就显得失去了直观性。再往深了考虑的解决方法是使用自适应短时傅里叶变换，使用算法来让窗口自适应信号。</p><p>不过也可以换个角度思考，现在陷入瓶颈的原因还是在于使用了两个互为倒空间的基，出现了测不准的问题，如果重新在希尔伯特空间选择一个基，是否就能够解决这个问题。</p><p>首先波这个概念很好，有了波才引出了频域，我们希望保留它。其次加窗的想法也很好，它保留了时域的信息，这两者都是有物理意义的。这样我们是否能够使用一个小范围的波来作为基呢？起个名字就叫小波，用<spanclass="math inline">\(\psi(t)\)</span>来表示。，样子大概如下。</p><figure><imgsrc="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200305.png"alt="小波" /><figcaption aria-hidden="true">小波</figcaption></figure><p>当然这只是一个概念图，光有一个波可构不成希尔伯特空间的基。</p><p>好在我们是在线性空间里讨论的，只要一个集合能被一组已知的基完全线性表示，那这个集合也是一组基。这里完全线性表示的意思是用上了所有的元素才能表示全。</p><p>所以只要加上尺度变换<spanclass="math inline">\(\frac{1}{\sqrt{a}}\psi(\frac{t}{a})\)</span>,这样随着a的变换，在时域上看是变胖变瘦，在频域上看是遍历所有频率。前面的系数是为了归一化，同样为了方便处理，我们人为将小波在时域上的积分设置为0，这样就和三角函数相统一了。</p><p>解决了基的问题，好像顺带也把频域的特性提取问题解决了，因为小波基底的选择就是借用的波的概念，下一步是让波在时域上动起来，这个也很好处理，只要用初中学的函数平移就行。以小波为基底的变换就叫小波变换。下面直接给出函数<spanclass="math inline">\(f(t)\)</span>小波变换的完整公式。</p><p><span class="math display">\[W T(a, \tau)=\frac{1}{\sqrt{a}} \int_{-\infty}^{\infty} f(t) *\psi\left(\frac{t-\tau}{a}\right) d t\]</span></p><p>实际上小波不一定长得和上图一样，尺度变换也可以用其他方法表示，记作<spanclass="math inline">\(\phi(t)\)</span></p><p>小波的函数<spanclass="math inline">\(\psi(t)\)</span>被称为母小波，尺度函数<spanclass="math inline">\(\phi(t)\)</span>被称为父小波。确定了两者就可以愉快地进行小波变换了！</p><h2 id="参考资料">参考资料</h2><p>[1] <ahref="https://www.bilibili.com/video/BV1ce4y1p7jF/?spm_id_from=333.880.my_history.page.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">卷积神经网络的底层是傅里叶变换，傅里叶变换的底层是希尔伯特空间坐标</a></p><p>[2] <ahref="https://www.zhihu.com/question/332144499/answer/731866608">希尔伯特空间、内积空间的定义有什么关系和区别？</a></p><p>[3] <ahref="https://blog.csdn.net/weixin_36811328/article/details/81207753">欧几里得空间与希尔伯特空间</a></p><div id="refer-anchor-1"></div><p>[4] <ahref="https://www.bilibili.com/video/BV1Et411R78v/?from=search&amp;seid=7859464741790869886&amp;spm_id_from=333.337.0.0&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">纯干货数学推导_傅里叶级数与傅里叶变换_Part1_三角函数的正交性</a></p><p>[5] <ahref="https://zhuanlan.zhihu.com/p/143510464">Matlab中短时傅里叶变换spectrogram和stft的用法</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;opencv的python图像处理学习笔记&lt;/p&gt;
&lt;p&gt;从空间基的角度介绍小波变换&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机" scheme="https://splendidwave.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="python" scheme="https://splendidwave.github.io/tags/python/"/>
    
    <category term="opencv" scheme="https://splendidwave.github.io/tags/opencv/"/>
    
  </entry>
  
</feed>
