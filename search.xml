<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo Next 自定义背景</title>
    <url>/2021/12/27/2021-12/Hexo-Next-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>周末没啥事干，就搭了个博客玩。前面挺顺利的，node、hexo、next一路顺利安装下来，标签、评论也都挺简单的，但是到了细节美化处理部分，因为版本问题网上好多教程不太行，尤其是在换背景图片，尝试了好几个都不行。本文通过修改next的模板实现了自定义背景，为换背景图提供了一种新的解决方法。</p>
<span id="more"></span>
<h2 id="介绍">1.介绍</h2>
<p>Hexo是一个基于Node.js的静态网页生成器，它与Github
Page搭配使用，可以创建个人博客网站，next是使用较多的博客主题。如果你也想搭建个人博客网站，可以参考知乎上的教程<a
href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细）</a></p>
<h2 id="遇到的问题">2.遇到的问题</h2>
<p>本文使用的是next7.8.0版本，使用的是Gemini主题，next刚搭好时非常简洁，啥都没有。本以为修改背景图片会非常简单，通过一百度发现如下解决方案：
1.
首先主流方案是通过修改<code>source\css\ _custom\custom.styl</code>文件。但由于版本问题，并没有这个文件，首先尝试新建，但没什么用。</p>
<ol start="2" type="1">
<li><p>其次是修改<strong>主题配置文件</strong>中的<code>custom_file_path:</code>下的<code>#style: source/_data/styles.styl</code>但修改+建立文件后会出现格式乱掉的情况。</p></li>
<li><p>按照<a
href="https://blog.csdn.net/qq_52116176/article/details/109406842">MD-11的CSDN文章</a>同样会乱码，虽然该方法没能解决问题，但为并不会前端提供了一种解题思路。</p></li>
</ol>
<h2 id="解决方法">3.解决方法</h2>
<ol type="1">
<li>将自己的背景图片命名为<code>background.png</code>保存在<code>\themes\next\source\images</code>路径下</li>
<li>进入路径<code>\themes\next\source\css\_schemes</code>可见其中有四个文件
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204340.png"
alt="四个文件" /></li>
<li>选择你自己的主题，本文以Gemini为例，使用记事本打开<code>index.styl</code></li>
<li>复制下列代码在<code>Desktop layout styles.</code> 如图。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 整体背景设置</span><br><span class="line">body &#123;</span><br><span class="line">	background:url(/images/background.png);// 设定背景图片,images同处于source文件夹下</span><br><span class="line">	background-repeat: no-repeat;// 设定背景图片非重复填充</span><br><span class="line">	background-attachment:fixed;// 设置背景图片不随页面滚动</span><br><span class="line">	background-position:50% 50%;// 设置背景图片位置</span><br><span class="line">	background-size: cover// 设置保持图像的纵横比并将图像缩放成将完全覆盖背景定位区域的最小大小</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置透明度</span><br><span class="line">.main-inner&#123;</span><br><span class="line">	opacity: 0.9;</span><br><span class="line">&#125;</span><br><span class="line">.header-inner&#123;</span><br><span class="line">	opacity: 0.9;</span><br><span class="line">	z-index: 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204354.png"
alt="插入代码的位置" />
<figcaption aria-hidden="true">插入代码的位置</figcaption>
</figure>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/27/2021-12/hello-world/</url>
    <content><![CDATA[<p><strong><em>此版用于测试！</em></strong></p>
<span id="more"></span>
<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<p>This is baidu link: https://www.baidu.com/</p>
<h2 id="中文字数测试">中文字数测试</h2>
<h3 id="命令备忘录">命令备忘录</h3>
<p>以管理员模式进入git bash</p>
<p>cd 到当前目录</p>
<p>1.更新网站 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p>
<p>2.修改后进行本地查看 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></p>
<p>3.生成新文章 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new post &quot;article title&quot;</span><br></pre></td></tr></table></figure></p>
<p>4.上传新文章 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></p>
<p>5.写blog时使用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure> 来隐藏后文</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>随笔与记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>GitHub</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo+markdown开启博客写作</title>
    <url>/2021/12/28/2021-12/%E4%BD%BF%E7%94%A8hexo-markdown%E5%BC%80%E5%90%AF%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>本篇用来记录hexo的常用命令和markdown的基础语法。</p>
<span id="more"></span>
<h2 id="前置">1.前置</h2>
<p>如果是打算将图片保存在本地的建议在<strong>站点配置文件</strong>中将<code>post_asset_folder</code>改为<code>true</code>，方便管理图片。<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204630.png"
alt="创建同名本地文件" /></p>
<p>开启后会在创建新博客的同时创建同名文件夹，图片往里放在上传时会和博客的md文件放在同个文件夹下。使用图床的可以不开启。</p>
<h2 id="使用hexo命令新建post">2.使用hexo命令新建post</h2>
<p>在站点目录打开Gitbash，输入下列代码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new post &quot;your post name&quot;</span><br></pre></td></tr></table></figure>
会发现在<code>\source\_posts</code>路径下，新建了一个同名md文件和一个同名空文件夹。</p>
<p>在md文件的抬头可以进行日期、标签、分类等管理，同时该文件使用markdown语法编辑。</p>
<h2 id="使用markdown写post">3.使用markdown写post</h2>
<h3 id="markdown编辑器">3.1 markdown编辑器</h3>
<p>你可以选择用记事本打开直接用markdown语法写，也可以其他编辑器打开。本文使用vscode编辑，在拓展中搜索markdown，安装第一个即可。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204929.png"
alt="vscode里的markdown拓展" />
<figcaption aria-hidden="true">vscode里的markdown拓展</figcaption>
</figure>
<p>安装完成后使用vscode打开md文件后点击右上角图标即可实时预览。</p>
<p>如果有移动端使用需求，ios(iPad)推荐使用Blockquote</p>
<h3 id="markdown语法">3.2 markdown语法</h3>
<p>注意语法间的空格</p>
<h4 id="标题">(1) 标题</h4>
<p>使用<code>#</code>的个数来表示标题级别</p>
<h4 id="行内代码">(2) 行内代码</h4>
<p><img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210205029.png" /></p>
<h4 id="代码块">(3) 代码块</h4>
<p><img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210205048.png" /></p>
<h4 id="字体">(4) 字体</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**加粗**</span><br><span class="line">*这是倾斜的文字*</span><br><span class="line">_这也是倾斜_</span><br><span class="line">**_斜体加粗_**</span><br><span class="line">***这也是斜体加粗***</span><br><span class="line">~~加删除线~~</span><br><span class="line">&amp;emsp;&amp;emsp;这是中文空格</span><br></pre></td></tr></table></figure>
<p><strong>加粗</strong> <em>这是倾斜的文字</em> <em>这也是倾斜</em>
<strong><em>斜体加粗</em></strong>
<strong><em>这也是斜体加粗</em></strong> <del>加删除线</del>
  这是中文空格</p>
<h4 id="列表">(5) 列表</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. First</span><br><span class="line">   1. 数字+点+空格变成有序列表</span><br><span class="line">2. Second</span><br><span class="line">   1. Tab键建立多级列表 </span><br><span class="line">3. Third</span><br><span class="line">   1. 无序列表使用`-`</span><br><span class="line">   - 事件1</span><br><span class="line">   - 事件2</span><br><span class="line">   - 事件3</span><br></pre></td></tr></table></figure>
<h4 id="引用">(6) 引用</h4>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;引用</span><br></pre></td></tr></table></figure> &gt;引用</p>
<h4 id="选择框">(7) 选择框</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] 已完成</span><br><span class="line">- [ ] 未完成</span><br></pre></td></tr></table></figure>
<ul class="task-list">
<li><label><input type="checkbox" checked="" />已完成</label></li>
<li><label><input type="checkbox" />未完成</label></li>
</ul>
<h4 id="分割线">(8) 分割线</h4>
<p>超过三个短线 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure></p>
<h4 id="表格">(9) 表格</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">| Key               | Command                       |</span><br><span class="line">| :------:          | :------:                      |</span><br><span class="line">|Ctrl + B           |   粗体                        |</span><br><span class="line">|Ctrl + I           |   斜体                        |</span><br><span class="line">|Alt + S            |   删除线                      |</span><br><span class="line">|Ctrl + Shift + ]   | 标题(uplevel)                 |</span><br><span class="line">|Ctrl + Shift + [   |  标题(downlevel)              |</span><br><span class="line">|Ctrl + M           | Toggle math environment       |</span><br><span class="line">|Alt + C            |Check/Uncheck task list item   |</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Key</th>
<th style="text-align: center;">Command</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Ctrl + B</td>
<td style="text-align: center;">粗体</td>
</tr>
<tr class="even">
<td style="text-align: center;">Ctrl + I</td>
<td style="text-align: center;">斜体</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Alt + S</td>
<td style="text-align: center;">删除线</td>
</tr>
<tr class="even">
<td style="text-align: center;">Ctrl + Shift + ]</td>
<td style="text-align: center;">标题(uplevel)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Ctrl + Shift + [</td>
<td style="text-align: center;">标题(downlevel)</td>
</tr>
<tr class="even">
<td style="text-align: center;">Ctrl + M</td>
<td style="text-align: center;">Toggle math environment</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Alt + C</td>
<td style="text-align: center;">Check/Uncheck task list item</td>
</tr>
</tbody>
</table>
<h4 id="公式">(10) 公式</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编辑latex公式 </span><br><span class="line">行内 $ \sum_&#123;i=1&#125;^n a_i $</span><br><span class="line"></span><br><span class="line">单独一行</span><br><span class="line">$$</span><br><span class="line">i\hbar \frac&#123;\partial &#125;&#123;\partial t&#125; \psi =-\frac&#123;\hbar^2&#125;&#123;2m&#125;\nabla^2\psi  + V\psi</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>编辑latex公式 行内 $ _{i=1}^n a_i $</p>
<p>单独一行 <span class="math display">\[
i\hbar \frac{\partial }{\partial t} \psi
=-\frac{\hbar^2}{2m}\nabla^2\psi  + V\psi
\]</span> 有代码需求建议开启mathjax</p>
<h4 id="网页">(11) 网页</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我的博客[splendidwave&#x27;s blog](https://splendidwave.github.io).</span><br></pre></td></tr></table></figure>
<p>我的博客<a href="https://splendidwave.github.io">splendidwave's
blog</a>.</p>
<h4 id="图片">(12) 图片</h4>
<p>引用需要给出路径，一般写博客放在同名文件夹里就可以直接引用图片名，当然也可以使用图床的方法引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](不学了.png)</span><br></pre></td></tr></table></figure>
<p><img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210205113.png" /></p>
<h2 id="将博客上传">4.将博客上传</h2>
<p>在站点目录打开Gitbash或者vscode控制台</p>
<h3 id="简单粗暴法">4.1 简单粗暴法</h3>
<p>输入三板斧 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p>
<h3 id="深思熟虑法">4.2 深思熟虑法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>清理文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure> 生成静态文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
登陆http://localhost:4000/ 查看修改样式，确认无误后使用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
上传后基本上等一会就能看见更新。</p>
<h3 id="可能出现的问题">4.3 可能出现的问题</h3>
<h4
id="如果出现本地更新完成github上也更新完成可以使用shift-f5强刷博客页面">(1)如果出现本地更新完成，github上也更新完成，可以使用<code>shift + F5</code>强刷博客页面。</h4>
<h4
id="执行hexo-d发生errorspawn-failed错误">(2)执行<code>hexo d</code>发生<code>error：spawn failed</code>错误</h4>
<ol type="1">
<li>删除<code>.deploy_git</code>文件夹</li>
<li>输入<code>git config --global core.autocrlf false</code></li>
<li>重新输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>随笔与记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>光学单位</title>
    <url>/2021/12/31/2021-12/%E5%85%89%E5%AD%A6%E5%8D%95%E4%BD%8D/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>光学单位汇总</p>
<span id="more"></span>
<h2 id="光学单位速查表">1.光学单位速查表</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">名称</th>
<th style="text-align: center;">单位(英文)</th>
<th style="text-align: center;">单位(中文)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">发光强度</td>
<td style="text-align: center;">Candlela(cd)</td>
<td style="text-align: center;">坎德拉(坎)</td>
</tr>
<tr class="even">
<td style="text-align: center;">辐射通量</td>
<td style="text-align: center;">Watt(W)</td>
<td style="text-align: center;">瓦特(瓦)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">光通量</td>
<td style="text-align: center;">lumen(lm)</td>
<td style="text-align: center;">流明</td>
</tr>
<tr class="even">
<td style="text-align: center;">照度</td>
<td style="text-align: center;">illuminance(lx)</td>
<td style="text-align: center;">勒克斯</td>
</tr>
<tr class="odd">
<td style="text-align: center;">亮度</td>
<td style="text-align: center;">nit</td>
<td style="text-align: center;">尼特</td>
</tr>
</tbody>
</table>
<h2 id="单位辨析">2.单位辨析</h2>
<h3 id="发光强度-cd">2.1 发光强度 cd</h3>
<p>  物体本身的亮度被称为发光强度，用于表征物体发光的强弱。
属于国际单位制基本单位之一。可以通过仪器测量或者光通量计算得出，公式如下：
<span class="math display">\[
\mathit{I} = \frac{\mathrm{d} \phi }{\mathrm{d} \Omega }  
\]</span> <span class="math inline">\(\phi\)</span>为光通量，<span
class="math inline">\(\mathrm{d}\Omega\)</span>为单位立体角。</p>
<p>  最开始以蜡烛的发光强度为计量单位，记为英文candle，后来定义经过规范标准化，命名也改为拉丁文candela，中文译名坎德拉。</p>
<h3 id="辐射通量-w">2.2 辐射通量 W</h3>
<p>  辐射通量是单位时间通过某一截面的辐射能，辐射能单位和功率的单位相同。
  注意：辐射能需要计算可见光波段及可见光之外波段的电磁波能量。</p>
<h3 id="光通量-lm">2.3 光通量 lm</h3>
<p>  在可见光范围内，人眼对各个颜色的感光亮度也是不同的，即相同辐射通量的单色可见光在人眼看来亮度是不同的，为了衡量人眼感觉的亮度，引入了视见函数。</p>
<p>  在明亮的条件下，一般人眼对555nm的绿光最敏感。同时为了区别于辐射通量，于是对于乘了视见函数的辐射通量定义为光通量，并给予新单位流明。一般可以通过仪器测量得出。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204420.jpg"
alt="视见函数，黑线为亮视觉，绿线为暗视觉" />
<figcaption
aria-hidden="true">视见函数，黑线为亮视觉，绿线为暗视觉</figcaption>
</figure>
<p>注意：辐射通量越大并不代表人眼看见的光就越亮，人眼看见的越亮只能代表光通量越大。</p>
<h3 id="照度-lx">2.4 照度 lx</h3>
<p>  照度全称是光照强度，指单位面积上所接受光通量，计算公式为： <span
class="math display">\[
E = \frac{\mathrm{d} \phi }{\mathrm{d} S }
\]</span></p>
<h3 id="亮度-nit">2.5 亮度 nit</h3>
<p>  主要为法向方向单位面积的光通量，常用于表示手机屏幕参数。</p>
<h2 id="参考资料">参考资料</h2>
<p><a
href="https://www.bilibili.com/video/BV1ab41157EP?from=search&amp;seid=13236499094428677912&amp;spm_id_from=333.337.0.0">1坎德拉有多亮？人眼为什么能看到五光十色？如何衡量发光强度？</a></p>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>逻辑与科普</category>
      </categories>
      <tags>
        <tag>科普</tag>
        <tag>光学</tag>
      </tags>
  </entry>
  <entry>
    <title>如何选择手机屏幕</title>
    <url>/2021/12/31/2021-12/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%89%8B%E6%9C%BA%E5%B1%8F%E5%B9%95/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<p>  智能手机对大部分人都不可或缺，手机屏幕作为信息内容的展示窗口，与每一个使用者息息相关，一块好的屏幕对于手机而言重要程度不亚于性能。我们需要如何判别屏幕的好坏？
<span id="more"></span></p>
<h2 id="成像原理">1.成像原理</h2>
<p>  人类目前所有的显示技术都是基于控制许多微小的像素点的亮灭，通过对像素点的精确把控显示屏得以显示出千奇百怪的图片。样子有了，颜色呢？在印刷中人们通常使用CMYK（印刷色彩模式）来实现多种颜色的展示，但在屏幕或者摄影中通常使用RGB三原色（光学三原色）来实现，每一颗像素点都是由距离极近的红绿蓝（RGB）三原色像素点组成，通过控制他们不同的亮度来实现展示需要的颜色。</p>
<h2 id="屏幕发展历史">2.屏幕发展历史</h2>
<h3 id="阴极射线管显示器">2.1 阴极射线管显示器</h3>
<p>  阴极射线管显示器（Cathode Ray
Tube，CRT）是最早实现应用的一种显示技术，具有技术成熟、图像色彩丰富、还原性好、全彩色、高清晰度、较低成本和丰富的几何失真调整能力等优点。</p>
<p>  CRT核心部件为阴极射线管、偏转系统、荧光屏三个部分。其原理是使用阴极射线管发出电子束轰击荧光屏使屏幕显示图像，偏转系统通常是通过外加电场或者磁场的方法来实现，用来控制电子束轰击荧光屏的位置。</p>
<p>  CRT常见于20世纪末到21世纪初的电视和电脑上，最早显示屏为球面状，这样做可以弥补偏振系统的灵敏度，但同时会导致边角画面失真。在后期工业界也对CRT进行了优化，出现了纯平显示器。由于采用了栅状设计等多种革新技术，
使得显示器的显示质量更上一层楼，画面更细腻、鲜艳，失真也不明显了。</p>
<p>  CRT的缺点也是非常明显的，那就是体积大，功耗高。因为需要将电子发射到整个屏幕上，电子束的运动空间是不可能优化掉的，所以早期的电脑和现在比起来也显得笨重很多。也同样是这个原因，CRT没能应用于手机市场。这一因素也限制了CRT的屏幕大小和边长比例。出于这方面考虑CRT厂商会更倾向利用边长比为4:3来获得更大显示尺寸的方案。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204445.jpg"
alt="早期的电脑" />
<figcaption aria-hidden="true">早期的电脑</figcaption>
</figure>
<h3 id="液晶显示器">2.2 液晶显示器</h3>
<p>  液晶显示器（Liquid Crystal
Display，LCD）是目前主流的显示技术，广泛应用于目前的电视、电脑和电子产品上。</p>
<p>  LCD的原理非常有趣，但在介绍它的原理前，我需要插入关于一个光的偏振的概念。我们都知道光是一种电磁波同时光是横波（只有横波有偏振现象），变化的电场会产生磁场，变化的磁场会产生电场，这就导致光会传播。对于人眼来说我们接收到的信息基本来自于光中的电场部分，所以我们讨论光时基本只考虑电场的变化。当自然光源发光时，首先电场的振动方向肯定是垂直于传播方向，但别忘了我们生活在一个三维空间，垂直于线的是一个平面，而电场的振动方向可能是这个平面内的任意一条线。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204456.png"
alt="光的偏振" />
<figcaption aria-hidden="true">光的偏振</figcaption>
</figure>
<p>  如图蓝色箭头为传播方向，红色箭头为电场可能的振动方向。如果有一束光，它的电场沿一个方向振动，我们称它为线偏振光，各个方向都有称为自然光。</p>
<p>  问题来了，我们怎么知道光是怎么振的？这就需要引入偏振片这个玩意了。偏振片可以简单理解为一个画了一条线的平面，如果将它垂直于光传播方向放置在有一可以发出线偏振光光源的光路中。只有线偏振光的振动方向和这条线一致才能无损地通过偏振片，如果线偏振光的振动方向和这条线垂直，那在偏振片后面就完全看不见光了。如果入射线偏振光的振动方向和这条线成一定夹角时，会损失一部分能量，关于这点我们可以对将对偏振片平面建立直角坐标系，对线偏振光的偏振态进行分解计算，这里不再进行展开叙述。</p>
<p>  接下来介绍一下液晶这个东西，我们知道固体的分子是具有周期性固定结构的，而气体的分子就是一种很随意的分布状态，液体介于两者之间，通常扁长型分子的液态分布会较为规律。奥地利植物学家莱尼茨尔（Reinitzer）于1888年发现液晶，这种通过加电压就可以改变分子排列的物质，在不同电流电场作用下，液晶分子会做规则旋转90度排列，产生透光度的差别，如此在电源开关下产生明暗的区别，依此原理控制每个像素，便可构成所需图像。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204510.png"
alt="液晶显示原理图" />
<figcaption aria-hidden="true">液晶显示原理图</figcaption>
</figure>
<p>  LCD的显示像素点结构如上图，首先最下部分是光源，通常采用冷阴极荧光灯管（CCFL）或者是发光二极管（LED），目前也有使用有机发光二极管（OLED）的。这里不得不额外提一点，有许多场商在宣传时会称屏幕使用的是OLED，但实际上想表达的意思可能是LCD的显示技术背光层使用的是OLED光源，这与接下来要讲的OLED显示技术还是有区别的。光源上面是一个偏振片，由偏振片的特性我们可知自然光经过偏振片后出来的光都是线偏振光。随后垂直线偏振光会通过由正负电极控制的液晶层，这里以正向控制为例，如过电极不给电，液晶的分子排列不会使光的偏振态发生改变，即光还是垂直线偏振光，当垂直线偏振光遇到水平偏振片，完全无法通过，则显示器不发光。若电极加电，液晶分子排列会扭转90度，使光的偏振态也改变90度，垂直偏振光变为水平偏振光，可以通过水平偏振片，实现图像的显示。</p>
<h3 id="等离子显示器">2.3 等离子显示器</h3>
<p>  等离子显示器（Plasma Display
Panel，PDP）又称为电浆显示屏。当电离过程频繁发生，使电子和阳离子的浓度达到一定的数值时，物质的状态也就起了根本的变化，它的性质也变得与气体完全不同。为区别于固体、液体和气体这三种状态，我们称物质的这种状态为物质的第四态，又起名叫等离子态。</p>
<p>  PDP是通过加电压，使板极间的气体产生等离子效应发光。这里关于PDP不多提及，主要原因在于PDP在市场竞争力上完全比不过LCD，日本许多厂商过去看好PDP为此还放弃了许多LCD的专利，后来这也导致日本显示器行业受到了打击。PDP主要缺点在于技术难度大和成本高，且只适合大型电视，在高中低端都不太能竞争得过LCD。</p>
<h3 id="发光二极管和有机发光二极管显示器">2.4
发光二极管和有机发光二极管显示器</h3>
<p>  发光二极管（LED）是一种常用的发光器件，通过电子与空穴复合释放能量发光。通过掺杂能实现不同颜色的发光，能发光自然能够实现显示，每个像素点都使用一个小的LED即能实现屏幕的功能。OLED中文名是有机发光二极管，从目前的理论来看，原理与LED差不多，LED和OLED是目前手机屏幕主流的显示技术，OLED具有功耗低、相应速度快、高分辨率、质量轻等优点。同时为适应新时代的柔性屏趋势，OLED的作用就越发凸显。</p>
<p>  相较于其他显示技术，OLED是主动发光的，所以显示色彩比较艳丽。特别是当OLED屏幕显示纯黑色时，是所有像素点不发光，颜色为纯黑，而LCD在显示黑色时是使用液晶让光的偏振态与上面的偏振片垂直，这很容易产生一些误差，导致出现漏光现象。同时OLED屏幕每个像素点都是可以独立控制的，许多手机熄屏状态下会显示时间通知等，这对OLED屏来说并不需要费太多电。</p>
<p>  但OLED也有缺点，在于它的使用寿命，不合适的使用或者特殊环境下OLED容易老化，会出现所谓的“烧屏”现象。还有一点就是当OLED屏幕如果使用的是PWM调光，当处于低亮度时可能会有屏幕闪烁的感觉，所以现阶段厂商有使用DC调光的方法来处理这一问题。</p>
<h2 id="显示器件参数">3.显示器件参数</h2>
<h3 id="尺寸">3.1 尺寸</h3>
<p>  通常在挑选手机或其他显示器时，尺寸是我们首先注意的部分。尺寸是比较通用的表示屏幕大小的度量方法，计算方法为测量出屏幕对角的长度，然后将单位转换为英寸。通常手机屏幕在5-8英寸，1英寸=2.5399999961392厘米。</p>
<h3 id="分辨率">3.2 分辨率</h3>
<p>  分辨率指的是屏幕上显示的像素个数，一般以水平像素数×垂直像素数表示，常见的1920×1080意为水平像素数量为1920个，垂直方向像素数为1080个。经常说的1080p屏幕，“P”即是英文“Progressive
scan”的缩写，意为逐行扫描，1080表示垂直方向有1080条扫描线，只要垂直方向的扫描线超过1080条就称为1080p屏幕。2K屏幕，指的是屏幕横向像素数量达到2000以上。</p>
<p>  高分辨率是保证彩色显示器清晰度的重要前提。图像分辨率（Image
Resolution）指图像中存储的信息量。这种分辨率有多种衡量方法，典型的是以每英寸的像素数（PPI，pixel
per
inch）来衡量。计算公式如下图，其中X为长度像素数；Y为宽度像素数；Z为屏幕尺寸即对角线长度。</p>
<p><span class="math display">\[
PPI = \frac{\sqrt[2]{X^2+Y^2} }{Z}
\]</span></p>
<p>  有些厂商还会在分辨率的地方标注FHD等标志，下表给出这些缩写的全称和对应的意思。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">缩写</th>
<th style="text-align: center;">全称</th>
<th style="text-align: center;">中文释义</th>
<th style="text-align: center;">分辨率</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">FHD</td>
<td style="text-align: center;">Full High</td>
<td style="text-align: center;">Definition</td>
<td style="text-align: center;">全高清</td>
</tr>
<tr class="even">
<td style="text-align: center;">HD</td>
<td style="text-align: center;">High Definition</td>
<td style="text-align: center;">高清</td>
<td style="text-align: center;">1024*720</td>
</tr>
<tr class="odd">
<td style="text-align: center;">SD</td>
<td style="text-align: center;">Standard Definition</td>
<td style="text-align: center;">标清</td>
<td style="text-align: center;">480<em>320、640</em>480</td>
</tr>
<tr class="even">
<td style="text-align: center;">qHD</td>
<td style="text-align: center;">Quarter High Definition</td>
<td style="text-align: center;">高清的四分之一</td>
<td style="text-align: center;">960*540</td>
</tr>
<tr class="odd">
<td style="text-align: center;">QHD</td>
<td style="text-align: center;">Quad High Definition</td>
<td style="text-align: center;">四边形高清</td>
<td style="text-align: center;">2560*1440</td>
</tr>
<tr class="even">
<td style="text-align: center;">WQHD</td>
<td style="text-align: center;">Wide Quad High Definition</td>
<td style="text-align: center;">宽四边形高清</td>
<td style="text-align: center;">3440*1440</td>
</tr>
</tbody>
</table>
<h3 id="刷新率和采样率">3.3 刷新率和采样率</h3>
<p>  刷新率是指屏幕上的图像每秒刷新的次数，又称帧率。刷新率越高，所显示的图象稳定性就越好。手机上通常有60Hz、90Hz、120Hz这几档，高刷新率在长期使用屏幕或处于肾上腺素分泌情况下显得比较有优势。但高刷新率同时也会加快屏幕老化和增加功耗。</p>
<p>  采样率是通信领域的名词，通常指采样频率，指一秒内对信号源进行多少次采样。在这里采样率体现了手机屏幕对人操作的相应快慢，采样率越高显得手机越“灵敏”。</p>
<h3 id="色域">3.4 色域</h3>
<p>  色域就是指某种表色模式所能表达的颜色构成的范围区域，通常用来衡量屏幕的色彩显示。我们知道屏幕的色彩显示是通过三原色混合而成的，而三原色的最大亮度决定了能覆盖所有颜色，如图。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204521.png"
alt="色域" />
<figcaption aria-hidden="true">色域</figcaption>
</figure>
<p>  假设该空间为人眼能见的所有可见光色彩，三角形划出的区域即为屏幕的色域。行业为统一标准，为色域规划名词，常用的有sRGB、Adobe
RGB、DCI-P3。通常还会在前面加百分比，如99%sRGB，指的是该屏幕能显示99%的sRGB标准的色彩。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204541.jpg"
alt="sRGB和DCI-P3对比" />
<figcaption aria-hidden="true">sRGB和DCI-P3对比</figcaption>
</figure>
<h3 id="亮度和对比度">3.5 亮度和对比度</h3>
<p>  亮度是光学领域常用的单位，通常表达为光强与光源的面积比，即单位投影面积上的发光强度。亮度的单位是坎德拉/平方米<span
class="math inline">\(（cd/m^2）\)</span>。屏幕的亮度常用尼特（nit）为单位，其中<span
class="math inline">\(1 nit=1 cd/m^2\)</span>。</p>
<p>  对比度指最亮的像素和最暗的像素的亮度之比，对比度对视觉效果的影响非常关键，一般来说对比度越大，图像越清晰醒目，色彩也越鲜明艳丽；而对比度小，则会让整个画面都灰蒙蒙的。高对比度对于图像的清晰度、细节表现、灰度层次表现都有很大帮助。</p>
<h2 id="实例分析">4 实例分析</h2>
<h3 id="iphone-12">4.1 iPhone 12</h3>
<p>如图为iPhone12的官方放出的屏幕参数图：</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204555.png"
alt="iPhone12 屏幕参数" />
<figcaption aria-hidden="true">iPhone12 屏幕参数</figcaption>
</figure>
<p>  首先是超视网膜XDR显示屏，根据官方的解释XDR是比HDR更进一步的技术，高动态范围图像（High-Dynamic
Range，简称HDR），相比普通的图像，可以提供更多的动态范围和图像细节。而XDR能够显示照片和视频中广泛的明暗区域。这使屏幕可以清晰显示深黑和亮白的区域，同时保留各区域之间的微妙差异。照片看起来将更加生动。但本质上该屏幕还是属于OLED显示屏。其余的一些参数在上文都有提及。</p>
<h3 id="小米11">4.2 小米11</h3>
<p>如图为小米11官方公开的屏幕参数：</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204603.png"
alt="小米11屏幕参数" />
<figcaption aria-hidden="true">小米11屏幕参数</figcaption>
</figure>
<p>  2K
AMOLED四曲面柔性屏是指分辨率为2K，主动发光型OLED，4边都是曲面的屏幕。然后是原色屏10bit，这里的10bit是指色深，通常用2的次方表示，1bit即为2的一次方，表示只能显示两种颜色。MEMC，英文全称为
Motion Estimation and Motion
Compensation，中文译为运动估计与运动补偿。简单来说就是通过芯片和算法预估物体运动的轨迹，最终补偿出视频源中本身没有的画面，达到画面更为流畅的目的。</p>
<h2 id="结束语">结束语</h2>
<p>  总结了这么多相信以后在面对繁杂的手机屏幕参数不再是一脸懵逼，而且这些屏幕参数在选择电视、电脑显示器中也能用得到。如果忘记了，也欢迎再回来查询。</p>
<h2 id="参考资料">参考资料</h2>
<p>[1]赵俊楠.显示器的发展[J].科技信息,2011(36):664.</p>
<p>[2]李继军, 聂晓梦, 甄威,等. 显示技术比较及新进展[J]. 液晶与显示,
2018, 33(001):74-84.</p>
<p>[3]硬件杂谈.【硬件科普】显示器的色域和色准是什么东西？他会影响哪些体验[EB/OL].https://www.bilibili.com/video/BV1kk4y167rk?t=339,2020-05-11.</p>
<p>[4]硬件杂谈.【硬件科普】全网最简洁易懂的OLED与LCD屏幕工作原理与优劣科普[EB/OL].https://www.bilibili.com/video/BV1Wz411B7Tf?from=search&amp;seid=10988679909731912318,2020-04-16.</p>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>逻辑与科普</category>
      </categories>
      <tags>
        <tag>科普</tag>
        <tag>光学</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类型的增删改查(1)--vector</title>
    <url>/2022/01/03/2022-1/C-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-1-vector/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>C++入门 vector类的增删改查 <span id="more"></span></p>
<h2 id="写在前面">1.写在前面</h2>
<h3 id="头文件">1.1 头文件</h3>
<p>在C++中继承了C语言的头文件，型如<code>.h</code>的拓展后缀，去掉<code>.h</code>在文件前加<code>c</code>即为引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cctype&gt;</span><br></pre></td></tr></table></figure>
<h3 id="命名空间">1.2 命名空间</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br></pre></td></tr></table></figure>
<p>类似于python的导入库函数，在python中如果使用<code>import turtle</code>,后面调用该库的函数需要使用<code>turtle.xxx</code>,而使用<code>from turtle import *</code>就导入了所有成员。</p>
<p>而在C++中使用<code>#include &lt;iostream&gt;</code>就可以使用<code>cin</code>（输入）和<code>cout</code>（输出）了，但需要写成
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::cin &gt;&gt; a;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
而使用<code>using namespace std;</code>后可以直接使用<code>cin</code>或<code>cout</code>，不需要加<code>std::</code>，比较方便。</p>
<h3 id="变量声明">1.3 变量声明</h3>
<ol type="1">
<li><p>在C++中，变量在使用前声明即可。</p></li>
<li><p>在for循环里可以使用</p></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; N; i++&gt;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的方式定义i。</p>
<ol start="3" type="1">
<li>auto可以让编译器自己推断变量的类型（需要C++11）</li>
</ol>
<p>方便用于迭代器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator it</span><br><span class="line">等效于</span><br><span class="line">auto it</span><br></pre></td></tr></table></figure>
<p>也可以直接使用auto遍历向量，下面展示两种迭代方式。
看不懂可以先跳过后面会再介绍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;int&gt; v(10,2); //生成一个长度为10，每个元素都为2的向量</span><br><span class="line">    for (auto it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl; //换行</span><br><span class="line">    for (auto it : v)&#123;</span><br><span class="line">        cout &lt;&lt; it &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">----输出----</span><br><span class="line">2 2 2 2 2 2 2 2 2 2</span><br><span class="line">2 2 2 2 2 2 2 2 2 2</span><br></pre></td></tr></table></figure>
<h2 id="vector类">2.vector类</h2>
<h3 id="简介">2.1 简介</h3>
<p>C中的数组是定长的，而<code>vector</code>翻译为向量或矢量，是动态数组，可以任意改变长度，使用需要包含头文件<code>#include &lt;vector&gt;</code>使用命名空间<code>std</code></p>
<p>定义方式为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;类型&gt; 名称;</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">vector&lt;int&gt; v2(10); //定义长度为10，默认元素为0</span><br><span class="line">vector&lt;int&gt; v3(10,2);//定义长度为10，定义元素为2</span><br><span class="line">vector&lt;int&gt; v4(v3); //使用向量v3来创建v4</span><br><span class="line">vector&lt;int&gt; v5(v3.begin(),v3.begin() + 3);//使用向量v3中的第1到3个元素(共三个)来创建v5，对非向量（数组）也可以这样赋值。</span><br></pre></td></tr></table></figure></p>
<h3 id="增">2.2 增</h3>
<ol type="1">
<li>使用<code>.push_back()</code>向向量a末尾增加元素，类似于python列表的<code>.append()</code>方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; a;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">    a.push_back(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用下标直接增加,需要提前定好vector的大小，不然会出错</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; a(10);</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">    a[i]=i;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>使用<code>.insert()</code>来插入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; a(10,2);</span><br><span class="line">vector&lt;int&gt; v2(v.begin(),v.begin() + 3);//v2 = 2 2 2</span><br><span class="line">v2.insert(v2.begin(),3);  //在开头插入3，v2 = 3 2 2 2</span><br><span class="line">v2.insert(v2.begin() + 1,3,4);//在1的位置插入3个4，v2 = 3 4 4 4 2 2 2</span><br></pre></td></tr></table></figure>
<h3 id="删">2.3 删</h3>
<ol type="1">
<li>使用<code>.clear()</code>来清空vector</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.clear();</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用<code>.pop_back()</code>来弹出最后一个元素</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.pop_back();</span><br></pre></td></tr></table></figure>
<p>注意这里和python的pop不同，该函数没有返回值</p>
<ol start="3" type="1">
<li>使用<code>.erase()</code>擦除元素</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.erase(a.begin());//擦除第一个元素</span><br><span class="line">a.erase(a.begin(),a.begin()+3);//擦除第1-3个元素</span><br></pre></td></tr></table></figure>
<h3 id="改">2.4 改</h3>
<ol type="1">
<li>直接引用修改</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[0] = 1;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用<code>.swap()</code>交换</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2.swap(v);//将v2和v做交换</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>使用<code>sort()</code>函数进行排序</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">sort(a.begin(),a.end()); //对a中的元素进行从小到大排列</span><br></pre></td></tr></table></figure>
<p>可以增加第三个函数参数实现自定义排序：<em>按学生成绩排序，如成绩相同则按学号先后</em>。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;    </span><br><span class="line">struct stu &#123;</span><br><span class="line">    int number;</span><br><span class="line">    int score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool cmp(stu a, stu b)&#123;</span><br><span class="line">    return a.score != b.score ? a.score &gt; b.score : a.number &lt; b.number;</span><br><span class="line">    //判断学生成绩是否相等，不同按成绩排，相同则按学号排</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    stu arr[10];</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">        arr[i].number = i;</span><br><span class="line">        cin &gt;&gt; arr[i].score;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(arr, arr+10, cmp);</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">        cout &lt;&lt; arr[i].number &lt;&lt; &quot;:&quot; &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="4" type="1">
<li>使用 <code>reverse()</code>函数对vector进行倒转</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">reverse(a.begin(),a.end()); //对a中的元素倒置</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>使用<code>copy()</code>函数对vector进行复制</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">copy(a.begin(),a.end(),b.begin()+1); //把a中的元素复制到b中(从第一个元素开始),覆盖但不能超过b的最大长度</span><br></pre></td></tr></table></figure>
<h3 id="查">2.5 查</h3>
<ol type="1">
<li>使用下标读取,<code>a.size()</code>会返回向量a的长度</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; a.size(); i++)&#123;</span><br><span class="line">    a[i] = 15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用迭代器遍历</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (auto it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (auto it : v2)&#123;</span><br><span class="line">    cout &lt;&lt; it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>使用<code>find()</code>函数查询是否存在该元素</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">find(a.begin(),a.end(),10); //在a中的元素中查找10，若存在返回其在向量中的位置</span><br><span class="line">if (find(a.begin(),a.end(),key) == a.end())&#123;</span><br><span class="line">  //a中不存在元素key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>使用<code>count()</code>函数实现计数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num=count(a.begin(),a.end(),key);//定义num为a中key元素的个数</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>使用<code>count_if()</code>函数计算满足条件的个数</li>
</ol>
<p>例如：计算vector中奇数的个数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool cmp(int num)&#123;</span><br><span class="line">    return num%2;  //偶数返回False 奇数返回True</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    vector &lt;int&gt; v;</span><br><span class="line">    for(int i=1;i&lt;=10;i++)</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    cout&lt;&lt;count_if(v.begin(),v.end(),cmp)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">----输出----</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类型的增删改查(2)--string</title>
    <url>/2022/01/06/2022-1/C-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-2-string/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>C++入门 bool、引用 string类的增删改查 <span id="more"></span></p>
<h2 id="bool和引用">3.bool和引用</h2>
<h3 id="bool类型">3.1 bool类型</h3>
<p>只有<code>true</code>和<code>false</code>两个值，所有非零值为<code>true</code>，零值为<code>false</code>，与python的区别是它的字母是全小写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool flag = true;</span><br></pre></td></tr></table></figure>
<h3 id="引用">3.2 引用</h3>
<p>C++中使用<code>&amp;</code>作为引用符，区别于取址算符 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a;</span><br><span class="line">int &amp;ra = a;//定义引用ra,它是变量a的引用，即别名</span><br><span class="line">//此时 ra = 1; 等效于 a = 1;</span><br></pre></td></tr></table></figure>
在函数中使用引用可以直接对原值进行更改 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void fun(int &amp;a)&#123;</span><br><span class="line">    a = 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int num = 0;</span><br><span class="line">    fun(num);//num变为1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="string类">4.string类</h2>
<h3 id="简介">4.1 简介</h3>
<p>C中处理字符串通常使用<code>char</code>数组，而string类通过<code>cin</code>和<code>cout</code>实现输入输出，并支持许多算法。使用方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">string s = &quot;hello world&quot;;//直接初始化</span><br><span class="line">string s1 = s;          //使用另一个string初始化</span><br><span class="line">string s2 = s1 + s;     //两个string拼接</span><br><span class="line">string s3(4, &#x27;c&#x27;);      //使用n个字符初始化</span><br><span class="line">string s4(&quot;hello&quot;, 2);  //将字符串的前n个字符赋值给s4</span><br><span class="line">string s5(s2, 2, 2);    //将s2从pos位置开始的len长度字符串赋值给s5</span><br><span class="line">string s6(s2, 2);       //将s2从pos位置开始的子串赋值给s6</span><br><span class="line">string s7(s2.begin(), s2.end()); //将s2某个区间的子串赋值给s7</span><br></pre></td></tr></table></figure>
<h3 id="增">4.2 增</h3>
<ol type="1">
<li>使用<code>cin</code>输入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; s;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用<code>.resize()</code>实现<code>scanf</code>输入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">s.resize(100);</span><br><span class="line">scanf(&quot;%s&quot;,&amp;s[0]);</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>使用<code>getline()</code>获得一行字符串（包括空格）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getline(cin, s);</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>使用<code>.insert()</code>插入字符</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1.insert(pos, &quot;hello&quot;); //从pos位置起，插入字符串</span><br><span class="line">s2.insert(pos, n, &#x27;c&#x27;);  //从pos位置开始，增加n个字符</span><br><span class="line">s2.insert(pos, s1, pos2, len);  //从pos位置起，插入s1的从pos2开始的len长度字符串</span><br></pre></td></tr></table></figure>
<p>注意pos和len都是整数类型的，下标从0开始</p>
<ol start="5" type="1">
<li>使用<code>to_string()</code>函数将其他类型转为string</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num = 123;</span><br><span class="line">string s;</span><br><span class="line">s = to_string(num);</span><br></pre></td></tr></table></figure>
<h3 id="删">4.3 删</h3>
<ol type="1">
<li>使用<code>.erase()</code>清除字符</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.erase(pos, len); //删除从pos位置开始的n个字符</span><br><span class="line">s.erase(s.begin(), s.begin()+2);  //删除某个指定区间的元素</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用<code>.clear()</code>清空字符串</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.clear();</span><br></pre></td></tr></table></figure>
<h3 id="改">4.4 改</h3>
<ol type="1">
<li>使用<code>.replace()</code>替换字符</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.replace(s.begin(), s.end(), &quot;hello&quot;); //替换指定区间内的字符</span><br><span class="line">s4.replace(pos, len, &quot;hello&quot;); //替换从pos位置开始的len长度的字符串</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用<code>transform()</code>改变字符串（如大小写）</li>
</ol>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">transform(s3.begin(), s3.end(), s3.begin(), ::tolower);//改为小写</span><br><span class="line">transform(s3.begin(), s3.end(), s3.begin(), ::toupper);//改为大写</span><br></pre></td></tr></table></figure></p>
<h3 id="查">4.5 查</h3>
<ol type="1">
<li>使用<code>cout</code>查看</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; s;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用<code>.c_str()</code>实现<code>printf</code>输出</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;%s\n&quot;,s.c_str());</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>使用<code>.length()</code>/ <code>.size()</code>获取长度</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; s.length();</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>使用<code>.substr()</code>获取子串/实现切片</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s2 = s.substr(pos); //从下标pos开始到末尾</span><br><span class="line">s3 = s.substr(pos,len); //下标pos开始截取len个字符</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>使用<code>.find()</code>获取字符或字符串位置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.find(str or char,pos)</span><br></pre></td></tr></table></figure>
<p>返回int类型</p>
<ol start="6" type="1">
<li>直接使用下标参看字符串对应字符</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; s[0] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ol start="7" type="1">
<li>比较两个字符串</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.compare(s2);</span><br><span class="line">s.compare(pos,n1,s2);   //让s中从pos下标位置开始的n1个字符与s2做比较</span><br><span class="line">s.compare(pos1,n1,s2,pos2,n2);  //让s中从pos1下标位置开始的n1个字符与s2中从pos2开始的n2个字符相比较</span><br></pre></td></tr></table></figure>
<p>按acsii码排序，&gt;时返回1，&lt;时返回-1，==时返回0</p>
<p>区分大小写，小写字母&gt;大写字母&gt;数字</p>
<ol start="7" type="1">
<li>使用<code>.empty()</code>判断是否为空</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.empty();</span><br></pre></td></tr></table></figure>
<p>空字符串返回1，非空返回0。</p>
<p>如字符串<code>.resize()</code>过，即为非空</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类型的增删改查(3)--set和map</title>
    <url>/2022/01/07/2022-1/C-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-3-set%E5%92%8Cmap/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>C++入门 结构体 set类型的增删改查 map类型的增删改查 <span id="more"></span></p>
<h2 id="结构体">5.结构体</h2>
<p>结构体定义 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct stu&#123;</span><br><span class="line">  int num;</span><br><span class="line">  float score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">stu arr[10];</span><br></pre></td></tr></table></figure> 在函数中调用结构体通常使用引用的方式
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void getData(stu &amp;);</span><br></pre></td></tr></table></figure></p>
<h2 id="set类">6.set类</h2>
<h3 id="简介">6.1 简介</h3>
<p><code>set</code>是集合的意思，与python的集合类似，各个元素各不相同，但在添加时会自动排好序，如不需要排序，可以引用<code>#include &lt;unordered_map&gt;</code>来使用<code>unordered_set</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; s; //定义一个空的int类型的集合</span><br><span class="line">set&lt;stu&gt; s; //定义一个空的结构体类型集合</span><br></pre></td></tr></table></figure>
<h3 id="增">6.2 增</h3>
<ol type="1">
<li>使用<code>insert</code>输入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.insert(1);</span><br><span class="line">s.insert(3);</span><br></pre></td></tr></table></figure>
<h3 id="删">6.3 删</h3>
<ol type="1">
<li>使用<code>.erase()</code>清除定元素</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.erase(1);</span><br></pre></td></tr></table></figure>
<p>该函数有返回值，删除成功返回1，未找到元素返回0</p>
<p>也可以用来删除区间，但<code>set</code>不能使用<code>s.begin()+1</code>这种，所以不太方便</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.erase(s.find(2),s.end());//把2开始到结束的都删了</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用<code>.clear()</code>清空集合</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.clear();</span><br></pre></td></tr></table></figure>
<h3 id="改">6.4 改</h3>
<p>无法更改</p>
<h3 id="查">6.5 查</h3>
<ol type="1">
<li>遍历</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (auto i : s)</span><br><span class="line">  cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)&#123;</span><br><span class="line">  cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用<code>.find()</code>查找集合中的值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; (s.find(10) != s.end()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出0为没找到，1为找到了</p>
<ol start="3" type="1">
<li>使用<code>.size()</code>获得元素个数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; s.size() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="map类型">7.map类型</h2>
<h3 id="简介-1">7.1 简介</h3>
<p><code>map</code>是映射，类似有python的字典类型，也会自动排序,<code>map</code>中的键是唯一的，以先出现的为准。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">map&lt;string, int&gt; m;//定义空map，键为string，值为int</span><br><span class="line">map&lt;string, int&gt; m1 = &#123;&#123;&quot;a&quot;,1&#125;,&#123;&quot;b&quot;,2&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="增-1">7.2 增</h3>
<ol type="1">
<li>使用下标输入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m[&quot;hello&quot;] = 1;</span><br></pre></td></tr></table></figure>
<h3 id="删-1">7.3 删</h3>
<ol type="1">
<li>使用<code>.erase()</code>清除特定元素</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m.erase(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>
<p>该函数有返回值，删除成功返回1，未找到元素返回0</p>
<p>也可以用来删除区间，<code>map</code>不能使用<code>m.begin()+1</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m.erase(m.begin(),s.end());//把开始到结束的都删了</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>使用<code>.clear()</code>清空集合</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m.clear();</span><br></pre></td></tr></table></figure>
<h3 id="改-1">7.4 改</h3>
<ol type="1">
<li>直接引用更改</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m[&quot;hello&quot;] += 1;</span><br></pre></td></tr></table></figure>
<h3 id="查-1">7.5 查</h3>
<ol type="1">
<li>遍历</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (auto i : m)</span><br><span class="line">  cout &lt;&lt; i.first &lt;&lt; &quot; &quot; &lt;&lt; i.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (map&lt;string, int&gt;::iterator it = m.begin(); it != m.end(); it++)&#123;</span><br><span class="line">  cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>使用<code>.find()</code>查找集合中的键</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; (m.find(&quot;hello&quot;) != m.end()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出0为没找到，1为找到了</p>
<ol start="3" type="1">
<li>使用<code>.size()</code>获得元素个数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; m.size() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra算法--最短路径规划</title>
    <url>/2022/01/31/2022-1/Dijkstra%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>迪杰斯特拉算法(Dijkstra)，用来计算一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。
<span id="more"></span></p>
<h2 id="算法思想">1.算法思想</h2>
<h3 id="计算方法">1.1 计算方法</h3>
<p>这个视频讲的比较清楚：<a
href="https://www.bilibili.com/video/BV1zz4y1m7Nq?from=search&amp;seid=560990659714243835&amp;spm_id_from=333.337.0.0">【算法】最短路径查找—Dijkstra算法</a></p>
<p>下面是文字版总结：</p>
<p>将带权图的顶点集合V分为两个子集合，已知最短路径集合S和未确定最短路径集合T。</p>
<p>第一步将起点顶点<span
class="math inline">\(v_0\)</span>加入集合S中，并计算该点到集合T中所有点的权（路径距离）。记录表格（或向量），内容为起点到其余各点的距离（不相连则记为无穷）。</p>
<p>第二步将表格中的最小值对应的顶点加入集合S，并计算该点到集合T中所有点的权，更新集合T对应顶点的距离表格（比较留下最短路径）。</p>
<p>第三步重复第二步直到集合T为空集。所得距离表格即为所求起点到各点的最短路径。</p>
<p>一句话概括：按路径长度递增顺序，将集合T中的各点加入到集合S中。</p>
<h3 id="证明">1.2 证明</h3>
<ol type="1">
<li><p>定理1：集合S中的点是按照长度递增顺序加入的。</p></li>
<li><p>定理2：起点<span
class="math inline">\(v_0\)</span>到下一个由T加入S的顶点<span
class="math inline">\(v_k\)</span>必然为弧<span
class="math inline">\((v_0,v_k)\)</span>或者是经过集合S内的点的路径。</p></li>
</ol>
<p><strong>证明内容为</strong>：通过Digkstra算法得到的是起点到各顶点的最短距离。因为第一步将起点加入了集合S且每次更新会留下最短距离，所以证明内容等价于：在定理2条件下，加入S的顶点<span
class="math inline">\(v_k\)</span>对应的距离是<span
class="math inline">\(v_0\)</span>到<span
class="math inline">\(v_k\)</span>的最短距离。</p>
<p><strong>反证法</strong>：假设<span
class="math inline">\(v_0\)</span>到<span
class="math inline">\(v_k\)</span>的最短路径中有一个点或多个点不在集合S中，那么必然存在顶点在T中且路径距离比此路径距离还短的点，与定理1矛盾，假设不成立。</p>
<h2 id="实例代码">2.实例代码</h2>
<h3 id="题目改编自pat甲级1003-emergency">2.1 题目（改编自PAT甲级1003
Emergency）</h3>
<p>你是一个戍守边疆的大将军，管辖许多堡垒，每个堡垒有一定的可以调动的人员，你需要在敌军入侵时尽快从你所在的位置赶过去，并尽可能的多带人马。调动人员需要虎符，所以你必须亲自到场才能调动，但尽快赶到是第一优先级。</p>
<p>input：</p>
<p>第一行输入4个参数：</p>
<p>N -- 管理的堡垒数量N(≤500)(编号0到N-1)</p>
<p>M -- 堡垒由M条路相连</p>
<p><span class="math inline">\(c_1\)</span> -- 你当前所在的堡垒位置</p>
<p><span class="math inline">\(c_2\)</span> -- 敌军入侵的堡垒位置</p>
<p>第二行输入N个整数，分别对应各个堡垒的可调动人员。</p>
<p>接下来的M行每行有3个整数，分别为堡垒1，堡垒2，和它们之间的路的距离。</p>
<p>output：</p>
<p>最短路径的距离和最多能带的队伍数量</p>
<p>Sample Input:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 6 0 2</span><br><span class="line">1 2 1 5 3</span><br><span class="line">0 1 1</span><br><span class="line">0 2 2</span><br><span class="line">0 3 1</span><br><span class="line">1 2 1</span><br><span class="line">2 4 1</span><br><span class="line">3 4 1</span><br></pre></td></tr></table></figure>
<p>Sample Output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 4</span><br></pre></td></tr></table></figure>
<p>代码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># N number of cities</span><br><span class="line"># M number of roads</span><br><span class="line"># C1 strart</span><br><span class="line"># C2 end</span><br><span class="line"># team_num number of rescue teams </span><br><span class="line"># adjacent 连接矩阵</span><br><span class="line"></span><br><span class="line">def Dijkstra(adjacent,C1,C2):</span><br><span class="line">    long = 0</span><br><span class="line">    dist = [Max for i in range(N)]</span><br><span class="line">    dist[C1] = 0</span><br><span class="line">    flag_node = [C1]                                            # 标记已经确定最短路径的列表</span><br><span class="line">    last_node = [0 for i in range(N)]                              # 上一节点</span><br><span class="line">    for i in range(N):                                          # 循环直到所有节点都被标记</span><br><span class="line">        if C2 in flag_node:                                     # 如果C2已经被确定，退出循环</span><br><span class="line">            long = dist[C2]</span><br><span class="line">            break</span><br><span class="line">        # 如果C2未被确定，从当前路径开始寻找下一节点</span><br><span class="line">        for i in range(N):</span><br><span class="line">            temp_dist = adjacent[flag_node[-1]][i]</span><br><span class="line">            if (i not in flag_node) and (temp_dist != Max):  #查询该节点未确定的通路</span><br><span class="line">                if dist[i] &gt; (dist[flag_node[-1]] + temp_dist): #判断是否需要更新</span><br><span class="line">                    dist[i] = dist[flag_node[-1]] + temp_dist</span><br><span class="line">                    last_node[i] = flag_node[-1]</span><br><span class="line">        #寻找最小值进行标记</span><br><span class="line">        mini = Max</span><br><span class="line">        for i in range(N):</span><br><span class="line">            if i not in flag_node:</span><br><span class="line">                if dist[i] &lt; mini:</span><br><span class="line">                    mini = dist[i]</span><br><span class="line">                    mini_index = i</span><br><span class="line">        flag_node.append(mini_index)</span><br><span class="line">    return last_node</span><br><span class="line">    </span><br><span class="line">def GetNL(last_node):</span><br><span class="line">    num = 0</span><br><span class="line">    long = 0</span><br><span class="line">    now_node = C2</span><br><span class="line">    while now_node != C1:</span><br><span class="line">        num += team_num[now_node]</span><br><span class="line">        long += 1</span><br><span class="line">        now_node = last_node[now_node]</span><br><span class="line">    return long,num+team_num[C1]</span><br><span class="line"></span><br><span class="line">Max = 2147483647</span><br><span class="line">height = 10000</span><br><span class="line">#接收数据</span><br><span class="line">N,M,C1,C2 = map(int,input().split())</span><br><span class="line">team_num = list(map(int,input().split()))</span><br><span class="line"># 建立连接矩阵</span><br><span class="line">adjacent = [ [Max for i in range(N)] for i in range(N) ]</span><br><span class="line">for i in range(N):</span><br><span class="line">    adjacent[i][i] = 0</span><br><span class="line">for i in range(M):</span><br><span class="line">    a,b,l = map(int,input().split())</span><br><span class="line">    l = l*height       #分配权重,利用权重将队伍数量问题也归结到距离问题，但归为次要因素。</span><br><span class="line">    adjacent[a][b] = l - team_num[a]</span><br><span class="line">    adjacent[b][a] = l - team_num[b]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使用Dijkstra算法</span><br><span class="line"># num 总共医疗数量</span><br><span class="line"># long 总路程</span><br><span class="line">last_node = Dijkstra(adjacent,C1,C2)</span><br><span class="line">long,num = GetNL(last_node)</span><br><span class="line">if long ==0:</span><br><span class="line">    long = 1</span><br><span class="line">print(long,num)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>PAT甲级</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT甲级</title>
    <url>/2022/01/16/2022-1/PAT%E7%94%B2%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>记录一下自己写的代码，可能有些比较粗糙，部分会参考一下网上的思路。</p>
<p>不定期更新，闲的时候会刷一题。</p>
<p>代码用python或者C++编写，python占大部分。 <span id="more"></span></p>
<h2 id="ab-format-20分">1001 A+B Format (20分)</h2>
<p>大概意思是标准化输出两数之和，每三位加一个逗号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a,b = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">he = <span class="built_in">str</span>(a + b)</span><br><span class="line"><span class="keyword">if</span> he[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    he = he[<span class="number">1</span>:]</span><br><span class="line">y = <span class="built_in">len</span>(he)%<span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> y:</span><br><span class="line">    <span class="built_in">print</span>(he[:y],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(he[:<span class="number">3</span>],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    y=<span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>((<span class="built_in">len</span>(he)-y)/<span class="number">3</span>)):</span><br><span class="line">    l = i*<span class="number">3</span>+y</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(he[l:l+<span class="number">3</span>],end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="ab-for-polynomials-25分">1002 A+B for Polynomials (25分)</h2>
<p>题目大意是输出多项式A+B的和</p>
<p>思路是用一个大数组来存所有系数，对应相加输出非零系数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,t;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">float</span> c[<span class="number">1001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%f&quot;</span>,&amp;t,&amp;f);</span><br><span class="line">        c[t] += f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%f&quot;</span>,&amp;t,&amp;f);</span><br><span class="line">        c[t] += f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1001</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            cot++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1000</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]!=<span class="number">0.0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d %.1f&quot;</span>,i,c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="emergency-25分">1003 Emergency (25分)</h2>
<p>题目大意是你作为医疗队队长需要在任务中选取最短路径方案，并尽可能多的人手。</p>
<p>这题可以使用<a
href="https://splendidwave.github.io/2022/01/31/2022-1/Dijkstra%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">迪杰斯特拉算法(Dijkstra)</a>来解决</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># N number of cities</span></span><br><span class="line"><span class="comment"># M number of roads</span></span><br><span class="line"><span class="comment"># C1 strart</span></span><br><span class="line"><span class="comment"># C2 end</span></span><br><span class="line"><span class="comment"># team_num number of rescue teams </span></span><br><span class="line"><span class="comment"># adjacent 连接矩阵</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Dijkstra</span>(<span class="params">C1,C2</span>):</span><br><span class="line">    dist = [Max <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]                              <span class="comment"># 标记距离长度</span></span><br><span class="line">    dist[C1] = <span class="number">0</span></span><br><span class="line">    flag_node = [-<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]                          <span class="comment"># 标记已经确定最短路径的列表</span></span><br><span class="line">    flag_node[C1] = <span class="number">1</span></span><br><span class="line">    res = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]                                <span class="comment"># 记录需要的答案</span></span><br><span class="line">    res[C1] = [<span class="number">1</span>,team_num[C1]]</span><br><span class="line">    p = C1                                                 <span class="comment"># 指针节点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):                                          <span class="comment"># 循环直到所有节点都被标记</span></span><br><span class="line">        <span class="keyword">if</span> flag_node[C2] == <span class="number">1</span>:                                   <span class="comment"># 如果C2已经被确定，退出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 如果C2未被确定，从当前路径开始寻找下一节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            temp_dist = adjacent[p][i]</span><br><span class="line">            <span class="keyword">if</span> (flag_node[i] == -<span class="number">1</span>) <span class="keyword">and</span> (temp_dist != Max):  <span class="comment"># 查询该节点未确定的通路</span></span><br><span class="line">                <span class="keyword">if</span> dist[i] &gt; (dist[p] + temp_dist): <span class="comment"># 判断是否需要更新</span></span><br><span class="line">                    dist[i] = dist[p] + temp_dist</span><br><span class="line">                    res[i] = [res[p][<span class="number">0</span>],res[p][<span class="number">1</span>]+team_num[i]]</span><br><span class="line">                <span class="keyword">elif</span> dist[i] == (dist[p] + temp_dist):</span><br><span class="line">                    res[i][<span class="number">0</span>] += res[p][<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">if</span> res[i][<span class="number">1</span>] &lt; (res[p][<span class="number">1</span>]+team_num[i]):</span><br><span class="line">                        res[i][<span class="number">1</span>] = res[p][<span class="number">1</span>]+team_num[i]</span><br><span class="line">        <span class="comment">#寻找最小值进行标记</span></span><br><span class="line">        mini = Max</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">if</span> flag_node[i] == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> dist[i] &lt; mini:</span><br><span class="line">                    mini = dist[i]</span><br><span class="line">                    p = i</span><br><span class="line">        flag_node[p] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res[C2]</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">Max = <span class="number">1000000</span></span><br><span class="line"><span class="comment">#接收数据</span></span><br><span class="line">N,M,C1,C2 = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">team_num = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line"><span class="comment"># 建立连接矩阵</span></span><br><span class="line">adjacent = [ [Max <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N) ]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">    a,b,l = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    adjacent[a][b] = l</span><br><span class="line">    adjacent[b][a] = l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Dijkstra算法</span></span><br><span class="line"><span class="comment"># num 总共医疗数量</span></span><br><span class="line"><span class="comment"># long 总路程</span></span><br><span class="line">answer = Dijkstra(C1,C2) <span class="comment"># 如有多个结果res会返回多个列表</span></span><br><span class="line"><span class="built_in">print</span>(answer[<span class="number">0</span>],answer[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="counting-leaves-30分">1004 Counting Leaves (30分)</h2>
<p>题目是根据家族树找每一代的无后代人数。先将家族谱按树状结构存储，然后使用
深度优先搜索遍历。当然广度优先算法也应是可以的。两者的复杂度相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 深度优先遍历搜索</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">ID, depth</span>):</span><br><span class="line">    <span class="keyword">global</span> max_depth</span><br><span class="line">    max_depth = <span class="built_in">max</span>(max_depth,depth)    <span class="comment"># 判断最大深度</span></span><br><span class="line">    visited[ID] = <span class="literal">True</span>                  <span class="comment"># 标记节点</span></span><br><span class="line">    <span class="keyword">if</span> ID <span class="keyword">not</span> <span class="keyword">in</span> tree:</span><br><span class="line">        res[depth] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> tree[ID]:</span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                dfs(child, depth + <span class="number">1</span>)   <span class="comment"># 递归</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N,M = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">tree = &#123;&#125;                   <span class="comment"># 树</span></span><br><span class="line">res = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)] <span class="comment"># 记录答案列表</span></span><br><span class="line">visited = &#123;&#125;                <span class="comment"># 标记访问过的节点</span></span><br><span class="line">max_depth = <span class="number">0</span>               <span class="comment"># 最大树深度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建树结构</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">    node_id , k, *child_id = <span class="built_in">list</span>(<span class="built_in">input</span>().split())</span><br><span class="line">    tree[node_id] = child_id</span><br><span class="line">    </span><br><span class="line">dfs(<span class="string">&#x27;01&#x27;</span>, <span class="number">0</span>) <span class="comment"># 输入初始节点</span></span><br><span class="line"><span class="comment"># 按格式输出</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_depth):</span><br><span class="line">    <span class="built_in">print</span>(res[i],end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res[max_depth])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 广度优先搜索</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">treenode</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义节点类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, depth, child_number=<span class="number">0</span>, child_id=[]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化类</span></span><br><span class="line"><span class="string">            depth 深度</span></span><br><span class="line"><span class="string">            child_number 子节点数量</span></span><br><span class="line"><span class="string">            child_id 字节点id</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.depth = <span class="built_in">int</span>(depth)</span><br><span class="line">        self.child_number = <span class="built_in">int</span>(child_number)</span><br><span class="line">        self.child_id = child_id</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queqe</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义队列类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化队列&quot;&quot;&quot;</span></span><br><span class="line">        self._ls = []</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_item</span>(<span class="params">self,treenode</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加元素&quot;&quot;&quot;</span></span><br><span class="line">        self._ls.append(treenode)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_item</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;弹出第一个值&quot;&quot;&quot;</span></span><br><span class="line">        r, self._ls = self._ls[<span class="number">0</span>],self._ls[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._ls) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">ID</span>):</span><br><span class="line">    <span class="keyword">global</span> max_depth</span><br><span class="line">    visited[ID] = <span class="literal">True</span></span><br><span class="line">    queqe.add_item(treenode(<span class="number">0</span>,tree[ID][<span class="number">0</span>],tree[ID][<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> queqe.empty():</span><br><span class="line">        v = queqe.get_item()</span><br><span class="line">        nowdepth = v.depth</span><br><span class="line">        max_depth = <span class="built_in">max</span>(nowdepth,max_depth)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> v.child_id:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                visited[i] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> tree:</span><br><span class="line">                    res[nowdepth+<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    queqe.add_item(treenode(nowdepth+<span class="number">1</span>,tree[i][<span class="number">0</span>],tree[i][<span class="number">1</span>]))</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">N,M = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    tree = &#123;&#125;       <span class="comment"># 树字典</span></span><br><span class="line">    res = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)] <span class="comment"># 记录答案列表</span></span><br><span class="line">    visited = &#123;&#125; <span class="comment"># 标记访问过的节点</span></span><br><span class="line">    max_depth = <span class="number">0</span> <span class="comment"># 最大树深度</span></span><br><span class="line">    <span class="comment"># 构建树结构</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        node_id , k, *child_id = <span class="built_in">list</span>(<span class="built_in">input</span>().split())</span><br><span class="line">        tree[node_id] = [k,child_id]</span><br><span class="line">        </span><br><span class="line">    queqe = queqe()</span><br><span class="line">    bfs(<span class="string">&#x27;01&#x27;</span>)</span><br><span class="line">    max_depth += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_depth):</span><br><span class="line">        <span class="built_in">print</span>(res[i],end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(res[max_depth])</span><br></pre></td></tr></table></figure>
<h2 id="spell-it-right-20分">1005 Spell It Right (20分)</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="built_in">input</span>()</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line">dic = [<span class="string">&quot;zero&quot;</span>,<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,\</span><br><span class="line">	<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>,<span class="string">&quot;seven&quot;</span>,<span class="string">&quot;eight&quot;</span>,<span class="string">&quot;nine&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> N:</span><br><span class="line">    s += <span class="built_in">int</span>(i)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(s)[:-<span class="number">1</span>]:</span><br><span class="line">    <span class="built_in">print</span>(dic[<span class="built_in">int</span>(i)],end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(dic[<span class="built_in">int</span>(<span class="built_in">str</span>(s)[-<span class="number">1</span>])])</span><br></pre></td></tr></table></figure>
<h2 id="sign-in-and-sign-out-25分">1006 Sign In and Sign Out (25分)</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">ID, intime, outtime = <span class="built_in">input</span>().split()</span><br><span class="line">unl_id = ID</span><br><span class="line">unl_time = intime</span><br><span class="line">l_id = ID</span><br><span class="line">l_time = outtime</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M-<span class="number">1</span>):</span><br><span class="line">    ID, intime, outtime = <span class="built_in">input</span>().split()</span><br><span class="line">    <span class="keyword">if</span> intime &lt; unl_time:</span><br><span class="line">        unl_id = ID</span><br><span class="line">        unl_time = intime</span><br><span class="line">    <span class="keyword">if</span> outtime &gt; l_time:</span><br><span class="line">        l_id = ID</span><br><span class="line">        l_time = outtime</span><br><span class="line"><span class="built_in">print</span>(unl_id, l_id)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>C++</tag>
        <tag>PAT甲级</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python进行科研绘图入门</title>
    <url>/2022/01/30/2022-1/%E4%BD%BF%E7%94%A8python%E8%BF%9B%E8%A1%8C%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>python绘图技巧备忘录</p>
<p>使用Matplotlib，以代码呈现为主</p>
<p>入门，配色，坐标轴修改 <span id="more"></span></p>
<h2 id="安装">1.安装</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install Matplotlib </span><br></pre></td></tr></table></figure>
<h2 id="基本绘图">2.基本绘图</h2>
<p>以线图为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">plt.plot(x,y,format_string,**kwargs)</span><br></pre></td></tr></table></figure>
<h3 id="format_string参数">2.1 format_string参数</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">风格 linestyle</span><br><span class="line">&#x27;-&#x27; 实线</span><br><span class="line">&#x27;--&#x27; 破折线</span><br><span class="line">&#x27;-.&#x27; 点划线</span><br><span class="line">&#x27;:&#x27; 虚线</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">标记 marker</span><br><span class="line">&#x27;.&#x27;       point marker</span><br><span class="line">&#x27;,&#x27;       pixel marker</span><br><span class="line">&#x27;o&#x27;       circle marker</span><br><span class="line">&#x27;v&#x27;       triangle_down marker</span><br><span class="line">&#x27;^&#x27;       triangle_up marker</span><br><span class="line">&#x27;&lt;&#x27;       triangle_left marker</span><br><span class="line">&#x27;&gt;&#x27;       triangle_right marker</span><br><span class="line">&#x27;1&#x27;       tri_down marker</span><br><span class="line">&#x27;2&#x27;       tri_up marker</span><br><span class="line">&#x27;3&#x27;       tri_left marker</span><br><span class="line">&#x27;4&#x27;       tri_right marker</span><br><span class="line">&#x27;s&#x27;       square marker</span><br><span class="line">&#x27;p&#x27;       pentagon marker</span><br><span class="line">&#x27;*&#x27;       star marker</span><br><span class="line">&#x27;h&#x27;       hexagon1 marker</span><br><span class="line">&#x27;H&#x27;       hexagon2 marker</span><br><span class="line">&#x27;+&#x27;       plus marker</span><br><span class="line">&#x27;x&#x27;       x marker</span><br><span class="line">&#x27;D&#x27;       diamond marker</span><br><span class="line">&#x27;d&#x27;       thin_diamond marker</span><br><span class="line">&#x27;|&#x27;       vline marker</span><br><span class="line">&#x27;_&#x27;       hline marker</span><br></pre></td></tr></table></figure>
<h3 id="颜色参照表">2.2 颜色参照表</h3>
<p>修改plt中的color属性</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204244.png"
alt="颜色参照表" />
<figcaption aria-hidden="true">颜色参照表</figcaption>
</figure>
<p><a
href="https://blog.csdn.net/slandarer/article/details/114157177">科研级配色参考</a></p>
<ol type="1">
<li>蓝红4色 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#2878b5</span><br><span class="line">#9ac9db</span><br><span class="line">#f8ac8c</span><br><span class="line">#c82423</span><br><span class="line">#ff8884</span><br></pre></td></tr></table></figure></li>
<li>浅粉紫 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#A1A9D0</span><br><span class="line">#F0988C</span><br><span class="line">#B883D4</span><br><span class="line">#9E9E9E</span><br><span class="line">#CFEAF1</span><br><span class="line">#C4A5DE</span><br><span class="line">#F6CAE5</span><br><span class="line">#96CCCB</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="调用方法">2.3 调用方法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># 创建一个点数为 8 x 6 的窗口, 并设置分辨率为 80像素/每英寸</span><br><span class="line">plt.figure(figsize=(8, 6), dpi=80)</span><br><span class="line"></span><br><span class="line">x = np.linspace(-np.pi, np.pi, 100)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.plot(x,y,color=&quot;#2878b5&quot;, linewidth=1.0, linestyle=&quot;-&quot;, marker = &#x27;o&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204259.png"
alt="测试" />
<figcaption aria-hidden="true">测试</figcaption>
</figure>
<h2 id="坐标修改">3.坐标修改</h2>
<h3 id="修改横纵坐标标签">3.1 修改横纵坐标标签</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plt.xlabel(&#x27;wavenumber$(\mathit&#123; cm^&#123;-1&#125;&#125;)$&#x27;,fontdict=&#123;&#x27;family&#x27; : &#x27;Times New Roman&#x27;, &#x27;size&#x27;   : 29&#125;)</span><br><span class="line">plt.ylabel(&#x27;intensity(arb.units)&#x27;,fontdict=&#123;&#x27;family&#x27; : &#x27;Times New Roman&#x27;, &#x27;size&#x27;   : 29&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="修改横纵坐标刻度">3.2 修改横纵坐标刻度</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plt.yticks(fontproperties = &#x27;Times New Roman&#x27;, size = 23)</span><br><span class="line">plt.xticks(fontproperties = &#x27;Times New Roman&#x27;, size = 23)</span><br></pre></td></tr></table></figure>
<h3 id="网格与标签">3.3 网格与标签</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ax=plt.gca()</span><br><span class="line">ax.xaxis.set_major_locator(x_major_locator)         #画刻度</span><br><span class="line">plt.xlim(0,120)                                     #设置上下限</span><br><span class="line">plt.grid(axis=&#x27;x&#x27;,linestyle=&#x27;-.&#x27;)                   #画竖线</span><br><span class="line">#plt.text(100,80,&#x27;atm&#x27;,ha = &#x27;center&#x27;,va = &#x27;bottom&#x27;,fontsize=7)#加标签</span><br><span class="line">#ax.set_yticks([])                                  #隐藏y轴刻度</span><br></pre></td></tr></table></figure>
<h3 id="图例">3.4 图例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plt.plot(x,y,label=&quot;y1&quot;)</span><br><span class="line">plt.legend(loc=&quot;upper left&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upper left 左上</span><br><span class="line">upper right 右上</span><br><span class="line">upper left左上</span><br><span class="line">lower right右下</span><br><span class="line">lower left左下</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<p>[1] https://www.cnblogs.com/darkknightzh/p/6117528.html</p>
<p>[2] https://zhuanlan.zhihu.com/p/47588077</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>推算老师的生日</title>
    <url>/2022/01/03/2022-1/%E6%8E%A8%E7%AE%97%E8%80%81%E5%B8%88%E7%9A%84%E7%94%9F%E6%97%A5/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>张老师的生日是M月N日，张老师把M值告诉了小明，把N值告诉了小红。张老师给出生日可能的范围为
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3月4日 3月5日 3月8日</span><br><span class="line">6月4日 6月7日</span><br><span class="line">9月1日 9月5日</span><br><span class="line">12月1日 12月2日 12月8日</span><br></pre></td></tr></table></figure> 随后问他们能不能猜到自己的生日？</p>
<p>小明说：我现在不知道，但小红肯定也不知道。</p>
<p>小红说：本来我也不知道，但是现在我知道了。</p>
<p>小明说：哦，那我也知道了。</p>
<p>请根据以上对话推断出张老师的生日是哪一天</p>
<span id="more"></span>
<h2 id="分析题目">分析题目</h2>
<p><del>小明、小红都是谜语人，谜语人给爷爬</del></p>
<p>这题可以通过两人说的话提供的信息来用排除法判断。</p>
<p>先将生日列表如下</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">N</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">12</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">9.1</td>
<td style="text-align: center;">12.1</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">12.2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;">3.4</td>
<td style="text-align: center;">6.4</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA</td>
</tr>
<tr class="even">
<td style="text-align: center;">5</td>
<td style="text-align: center;">3.5</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">9.5</td>
<td style="text-align: center;">NA</td>
</tr>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">6.7</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA</td>
</tr>
<tr class="even">
<td style="text-align: center;">8</td>
<td style="text-align: center;">3.8</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">12.8</td>
</tr>
</tbody>
</table>
<p>使用表格可以辅助快速代入角色，文章中提到<em>小红就横看表格，小明就竖看表格</em></p>
<ol type="1">
<li>小明说：我现在不知道，但小红肯定也不知道。</li>
</ol>
<p>小明知道月份M，但他断定小红光知道日期是没法推出生日的，所以对于老师的生日应该排除<strong>知道N就可以得到生日的几项</strong>，即排除<code>6.7和12.2</code>（横看表格数值唯一的项）</p>
<ol start="2" type="1">
<li>小红说：本来我也不知道，但是现在我知道了。</li>
</ol>
<p>小红原来不知道，但听了小明的话得到了部分信息，就知道了。所以得到的信息是关键。小明是知道月份M的，但他笃定小红日期N不是<code>7和2</code>，才敢说上面这句话。</p>
<p>由此小红可以反推出小明知道的月份<code>M</code>不是日期<code>7和2</code>所在的月份，即老师的生日排除<code>6.4、12.1、12.8</code></p>
<p>此时我们可以得出信息表格如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">N</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">6 ×</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">12 ×</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA×</td>
<td style="text-align: center;">9.1</td>
<td style="text-align: center;">12.1 ×</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA×</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">12.2 ×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;">3.4</td>
<td style="text-align: center;">6.4×</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA ×</td>
</tr>
<tr class="even">
<td style="text-align: center;">5</td>
<td style="text-align: center;">3.5</td>
<td style="text-align: center;">NA×</td>
<td style="text-align: center;">9.5</td>
<td style="text-align: center;">NA ×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">6.7×</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA ×</td>
</tr>
<tr class="even">
<td style="text-align: center;">8</td>
<td style="text-align: center;">3.8</td>
<td style="text-align: center;">NA×</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">12.8×</td>
</tr>
</tbody>
</table>
<ol start="3" type="1">
<li>小明说：哦，那我也知道了。</li>
</ol>
<p>小明得知小红知道后，表示也知道了。说明根据小红手中的日期N，在排除掉6月和12月后就能唯一知道答案。小红根据N就推出了老师的生日，则N不可能等于<code>5</code></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">N</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">6 ×</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">12 ×</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA×</td>
<td style="text-align: center;">9.1</td>
<td style="text-align: center;">12.1 ×</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA×</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">12.2 ×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;">3.4</td>
<td style="text-align: center;">6.4×</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA ×</td>
</tr>
<tr class="even">
<td style="text-align: center;">5 ×</td>
<td style="text-align: center;">3.5 ×</td>
<td style="text-align: center;">NA×</td>
<td style="text-align: center;">9.5 ×</td>
<td style="text-align: center;">NA ×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">6.7×</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA ×</td>
</tr>
<tr class="even">
<td style="text-align: center;">8</td>
<td style="text-align: center;">3.8</td>
<td style="text-align: center;">NA×</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">12.8×</td>
</tr>
</tbody>
</table>
<p>最后小明根据M也知道了,说明M不可能等于<code>3</code>，此时答案唯一</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">N</th>
<th style="text-align: center;">3 ×</th>
<th style="text-align: center;">6 ×</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">12 ×</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">NA×</td>
<td style="text-align: center;">NA×</td>
<td style="text-align: center;">9.1</td>
<td style="text-align: center;">12.1 ×</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">NA ×</td>
<td style="text-align: center;">NA×</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">12.2 ×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;">3.4 ×</td>
<td style="text-align: center;">6.4×</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA ×</td>
</tr>
<tr class="even">
<td style="text-align: center;">5 ×</td>
<td style="text-align: center;">3.5 ×</td>
<td style="text-align: center;">NA×</td>
<td style="text-align: center;">9.5 ×</td>
<td style="text-align: center;">NA ×</td>
</tr>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: center;">NA ×</td>
<td style="text-align: center;">6.7×</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA ×</td>
</tr>
<tr class="even">
<td style="text-align: center;">8</td>
<td style="text-align: center;">3.8 ×</td>
<td style="text-align: center;">NA×</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">12.8×</td>
</tr>
</tbody>
</table>
<p>觉得有意思的可以看看<a
href="https://splendidwave.github.io/2022/01/05/2022-1/%E9%AC%BC%E8%B0%B7%E5%AD%90%E9%97%AE%E9%A2%98/">鬼谷子问题</a>,也是类似的思路。</p>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>逻辑与科普</category>
      </categories>
      <tags>
        <tag>逻辑思维</tag>
      </tags>
  </entry>
  <entry>
    <title>谱线展宽和线型函数</title>
    <url>/2022/01/26/2022-1/%E8%B0%B1%E7%BA%BF%E5%B1%95%E5%AE%BD%E5%92%8C%E7%BA%BF%E5%9E%8B%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<ul class="task-list">
<li><label><input type="checkbox"
checked="" />介绍了谱线展宽的分类和产生原因</label></li>
<li><label><input type="checkbox" checked="" />展示三种线型</label></li>
<li><label><input type="checkbox" checked="" />使用python分析拟合
<span id="more"></span></label></li>
</ul>
<h2 id="谱线展宽">1.谱线展宽</h2>
<p>理想情况下，无论是激光的出射光还是光谱的峰，在谱线上都应该是一条直线，由于各种因素的影响，其现实效果并非如此，而是会呈现出分布在中心频率附近的一个很小的频率范围内的线型。这就是谱线展宽，常见的谱线又可以分为均匀加宽和非均匀加宽（判别依据是能否分辨加宽源自哪一个原子）。</p>
<h3 id="均匀加宽">1.1 均匀加宽</h3>
<ol type="1">
<li><p>自然加宽</p>
<p>受激原子在激发态上具有有限的寿命。会自发向低能级跃迁，导致谱线加宽，线型为洛伦兹线型。</p></li>
<li><p>碰撞加宽</p>
<p>大量原子（分子、离子）之间无规则“碰撞”引起的谱线加宽，线型为洛伦兹线型。</p></li>
<li><p>晶格振动加宽</p>
<p>激光器工作物质因晶格场的影响导致的谱线加宽。温度越高，振动越剧烈，谱线越宽。</p></li>
</ol>
<h3 id="非均匀加宽">1.2 非均匀加宽</h3>
<ol type="1">
<li><p>多普勒加宽</p>
<p>多普勒加宽是由于作热运动的发光原子（分子）所发出的辐射的多普勒频移引起的。属于高斯线型。</p></li>
<li><p>晶格缺陷加宽</p>
<p>激光器如果使用的是固体工作物质，其不存在多普勒加宽，但因为晶格错位或空位等不均匀性也会产生非均匀加宽。</p></li>
</ol>
<h2 id="高斯线型">2.高斯线型</h2>
<p>激光发射谱通常可以使用高斯线型拟合</p>
<p>一维高斯函数的公式如下： <span class="math display">\[
G(x) = \frac{A}{\sigma \sqrt{2\pi}} \exp(-\frac{(x-x_c)^2 }{2\sigma ^2})
\]</span></p>
<p>和概率论中的正态分布一致，但是在origin的拟合中，origin是科研常用的画图软件，使用的是如下公式
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># y=y0 + (A/(w*sqrt(pi/2)))*exp(-2*((x-xc)/w)^2)</span><br><span class="line"></span><br><span class="line">def Gauss_origin(x,y0,A,xc,w):</span><br><span class="line">    y = y0 + A * np.exp(-2*((x-xc)/w)**2)</span><br><span class="line">    return y</span><br></pre></td></tr></table></figure>
推测可能是为了计算速度优化了。为方便直观看幅值，我将A直接定义为幅值大小。</p>
<p>使用python画个图 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">def Gauss(x,A,xc,sigma):</span><br><span class="line">    y = A/(sigma*np.sqrt(2*np.pi))*np.exp(-(x-xc)**2/(2*sigma**2))</span><br><span class="line">    return y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mean1, sigma1 = 0, 1</span><br><span class="line">x1 = np.linspace(-10, 10, 500)</span><br><span class="line"></span><br><span class="line">mean2, sigma2 = 0, 2</span><br><span class="line">x2 = np.linspace(-10, 10, 500)</span><br><span class="line"></span><br><span class="line">mean3, sigma3 = 5, 1</span><br><span class="line">x3 = np.linspace(-10, 10, 500)</span><br><span class="line"> </span><br><span class="line">y1 = Gauss(x1,1, mean1, sigma1)</span><br><span class="line">y2 = Gauss(x2,1, mean2, sigma2)</span><br><span class="line">y3 = Gauss(x3,1, mean3, sigma3)</span><br><span class="line"> </span><br><span class="line">plt.plot(x1, y1, &#x27;r&#x27;, label=&#x27;m=0,sig=1&#x27;)</span><br><span class="line">plt.plot(x2, y2, &#x27;g&#x27;, label=&#x27;m=0,sig=2&#x27;)</span><br><span class="line">plt.plot(x3, y3, &#x27;b&#x27;, label=&#x27;m=5,sig=1&#x27;)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204047.png"
alt="高斯线型" />
<figcaption aria-hidden="true">高斯线型</figcaption>
</figure>
<h2 id="洛伦兹线型">3.洛伦兹线型</h2>
<p>与高斯线型比起来，洛伦兹线型显得更“瘦”</p>
<p>物质的光谱可以使用洛伦兹线型拟合</p>
<p>公式： <span class="math display">\[
L(x) = \frac{A}{\pi} \frac{\sigma}{(x-x_c)^2 + \sigma^2}
\]</span></p>
<p>在origin中使用公式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># y = y0 + (2*A/pi)*(w/(4*(x-xc)^2 + w^2))</span><br><span class="line"></span><br><span class="line">def Lorentz_origin(x,y0,A,xc,w):</span><br><span class="line">    y = y0 + w*A*(w/(4*(x-xc)**2 + w**2))</span><br><span class="line">    return y</span><br></pre></td></tr></table></figure>
<p>代码同上，修改两处即可 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def Lorentz(x,A,xc,sigma):</span><br><span class="line">    y = (A/np.pi)*(sigma/((x-xc)**2 + sigma**2))</span><br><span class="line">    return y</span><br><span class="line"></span><br><span class="line">y1 = Lorentz(x1,1, mean1, sigma1)</span><br><span class="line">y2 = Lorentz(x2,1, mean2, sigma2)</span><br><span class="line">y3 = Lorentz(x3,1, mean3, sigma3)</span><br><span class="line"> </span><br></pre></td></tr></table></figure></p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204057.png"
alt="洛伦兹线型" />
<figcaption aria-hidden="true">洛伦兹线型</figcaption>
</figure>
<h2 id="voigt线型">4.voigt线型</h2>
<p>其实上述线型还是有些理想化了，因为现实中往往是多个因素共同导致的谱线展宽，所以voigt线型才是最常用的，它是高斯线型和洛伦兹线型的卷积。</p>
<p>可以在Origin中查到voigt线型的公式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Mathematical expression is:</span><br><span class="line">// y = y0 + (A*2*ln(2)*wL)/(pi^1.5*wG^2) * integ( exp(-t^2) / ((sqrt(ln(2))*wL/wG)^2+(sqrt(4*ln(2))*(x-xc)/wG-t)^2) )</span><br><span class="line">// Please note that the expression is not Origin C code, and Origin C code is:</span><br><span class="line">y = nlf_voigt(x,y0,xc,A,wG,wL);</span><br></pre></td></tr></table></figure>
<p>python中numpy也有计算卷积的函数，但通常使用下面这个公式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from scipy.special import wofz</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def Voigt(x, y0, amp, pos, fwhm, shape = 1):</span><br><span class="line">    tmp = 1/wofz(np.zeros((len(x))) + 1j*np.sqrt(np.log(2.0))*shape).real</span><br><span class="line">    return y0+tmp*amp*wofz(2*np.sqrt(np.log(2.0))*(x-pos)/fwhm+1j*np.sqrt(np.log(2.0))*shape).real</span><br></pre></td></tr></table></figure>
<h2 id="使用python进行拟合">5.使用python进行拟合</h2>
<p>对python绘图不太了解的可以参考<a
href="https://splendidwave.github.io/2022/01/30/2022-1/%E4%BD%BF%E7%94%A8python%E8%BF%9B%E8%A1%8C%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE/#more">使用python进行科研绘图</a></p>
<p>以我的实验数据为例，使用两个高斯峰和两个voigt拟合2层黑磷的超低频拉曼光谱。</p>
<p>其中一个高斯峰拟合瑞利散射的峰，一个高斯峰用来拟合基线。两个voigt峰分别拟合少层黑磷的CCM模和CH1模。</p>
<p>先看看实验数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    df = pd.read_csv(&#x27;筛选后的数据.csv&#x27;)</span><br><span class="line">    x = df[&#x27;w&#x27;]</span><br><span class="line">    name = &#x27;2L&#x27;</span><br><span class="line">    layer = df[name]</span><br><span class="line">    x = x.values</span><br><span class="line">    layer = layer.values</span><br><span class="line">    plt.scatter(x, layer, alpha=0.8,s=13,color=&#x27;midnightblue&#x27;)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204156.png"
alt="2L BP的超低频拉曼光谱" />
<figcaption aria-hidden="true">2L BP的超低频拉曼光谱</figcaption>
</figure>
<p>丑了点，加下面函数修饰一下，然后把上面最后一行改成<code>ready_to_show()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from matplotlib.pyplot import MultipleLocator</span><br><span class="line"></span><br><span class="line">def ready_to_show():</span><br><span class="line">    x_major_locator=MultipleLocator(10)#准备刻度</span><br><span class="line">    #标签</span><br><span class="line">    plt.xlabel(&#x27;wavenumber$(\mathit&#123; cm^&#123;-1&#125;&#125;)$&#x27;,fontdict=&#123;&#x27;family&#x27; : &#x27;Times New Roman&#x27;, &#x27;size&#x27;   : 29&#125;)</span><br><span class="line">    plt.ylabel(&#x27;intensity(arb.units)&#x27;,fontdict=&#123;&#x27;family&#x27; : &#x27;Times New Roman&#x27;, &#x27;size&#x27;   : 29&#125;)</span><br><span class="line">    ax=plt.gca()</span><br><span class="line">    ax.xaxis.set_major_locator(x_major_locator)         #画刻度</span><br><span class="line">    plt.xlim(0,120)</span><br><span class="line">    plt.grid(axis=&#x27;x&#x27;,linestyle=&#x27;-.&#x27;)                   #画竖线</span><br><span class="line">    #plt.text(100,80,&#x27;atm&#x27;,ha = &#x27;center&#x27;,va = &#x27;bottom&#x27;,fontsize=7)#加标签</span><br><span class="line">    #ax.set_yticks([])#隐藏y轴刻度</span><br><span class="line">    plt.yticks(fontproperties = &#x27;Times New Roman&#x27;, size = 23)</span><br><span class="line">    plt.xticks(fontproperties = &#x27;Times New Roman&#x27;, size = 23)</span><br><span class="line">    plt.show()                          #展示</span><br></pre></td></tr></table></figure>
<p>放入拟合线型函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from scipy.special import wofz</span><br><span class="line"></span><br><span class="line">def Gauss(x,y0,A,xc,w):</span><br><span class="line">    y = y0 + A * np.exp(-2*((x-xc)/w)**2)</span><br><span class="line">    return y</span><br><span class="line"></span><br><span class="line">def Voigt(x, y0, amp, pos, fwhm, shape = 1):</span><br><span class="line">    tmp = 1/wofz(np.zeros((len(x))) + 1j*np.sqrt(np.log(2.0))*shape).real</span><br><span class="line">    return y0+tmp*amp*wofz(2*np.sqrt(np.log(2.0))*(x-pos)/fwhm+1j*np.sqrt(np.log(2.0))*shape).real</span><br><span class="line"></span><br><span class="line">def my_fit_cure(x,y01,a1,p1,f1,y02,a2,p2,f2,y03,a3,xc3,w3,y04,a4,xc4,w4):</span><br><span class="line">    return Voigt(x,y01,a1,p1,f1)+Voigt(x,y02,a2,p2,f2)+Gauss(x,y03,a3,xc3,w3)+Gauss(x,y04,a4,xc4,w4)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后使用<code>scipy.optimize</code>中的<code>curve_fit</code>进行拟合</p>
<p><code>curve_fit</code>
调用方式<code>curve_fit(拟合曲线,x数据,y数据,p0 = 初始值,bounds = ([min1,min2...],[max1,max2...]))</code></p>
<p>然后拟合程序和显示都封装成函数，为了方便展示，我都放在同一个文件里，展示如下：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from scipy.optimize import curve_fit</span><br><span class="line">from scipy.special import wofz</span><br><span class="line">from matplotlib.pyplot import MultipleLocator</span><br><span class="line"></span><br><span class="line">def Gauss(x,y0,A,xc,w):</span><br><span class="line">    y = y0 + A * np.exp(-2*((x-xc)/w)**2)</span><br><span class="line">    return y</span><br><span class="line"></span><br><span class="line">def Voigt(x, y0, amp, pos, fwhm, shape = 1):</span><br><span class="line">    tmp = 1/wofz(np.zeros((len(x))) + 1j*np.sqrt(np.log(2.0))*shape).real</span><br><span class="line">    return y0+tmp*amp*wofz(2*np.sqrt(np.log(2.0))*(x-pos)/fwhm+1j*np.sqrt(np.log(2.0))*shape).real</span><br><span class="line"></span><br><span class="line">def my_fit_cure(x,y01,a1,p1,f1,y02,a2,p2,f2,y03,a3,xc3,w3,y04,a4,xc4,w4):</span><br><span class="line">    return Voigt(x,y01,a1,p1,f1)+Voigt(x,y02,a2,p2,f2)+Gauss(x,y03,a3,xc3,w3)+Gauss(x,y04,a4,xc4,w4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def plot_scatter(x,st):</span><br><span class="line">    plt.scatter(x, st, alpha=0.8,s=13,color=&#x27;midnightblue&#x27;)</span><br><span class="line">    </span><br><span class="line">def show_the_fen(popt):</span><br><span class="line">    y01,a1,p1,f1,y02,a2,p2,f2,y03,a3,xc3,w3,y04,a4,xc4,w4 = popt</span><br><span class="line">    form = &quot;&#123;:10&#125;\t&#123;:10&#125;\t&#123;:10&#125;\t&#123;:10&#125;\t&#123;:10&#125;&quot;</span><br><span class="line">    print(form.format(&quot;峰类型&quot;,&quot;偏置&quot;,&quot;幅值&quot;,&quot;中心位置&quot;,&quot;宽度&quot;))</span><br><span class="line">    print(form.format(&quot;voigt&quot;,&quot;%.2f&quot;%y01,&quot;%.2f&quot;%a1,&quot;%.2f&quot;%p1,&quot;%.2f&quot;%f1))</span><br><span class="line">    print(form.format(&quot;voigt&quot;,&quot;%.2f&quot;%y02,&quot;%.2f&quot;%a2,&quot;%.2f&quot;%p2,&quot;%.2f&quot;%f2))</span><br><span class="line">    print(form.format(&quot;gauss&quot;,&quot;%.2f&quot;%y03,&quot;%.2f&quot;%a3,&quot;%.2f&quot;%xc3,&quot;%.2f&quot;%w3))</span><br><span class="line">    print(form.format(&quot;gauss&quot;,&quot;%.2f&quot;%y04,&quot;%.2f&quot;%a4,&quot;%.2f&quot;%xc4,&quot;%.2f&quot;%w4))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show_the_cure(xfit,popt,offset=0,cr=&#x27;b&#x27;):</span><br><span class="line">    y01,a1,p1,f1,y02,a2,p2,f2,y03,a3,xc3,w3,y04,a4,xc4,w4 = popt</span><br><span class="line">    # 主线</span><br><span class="line">    yfit = my_fit_cure(xfit,y01,a1,p1,f1,y02,a2,p2,f2,y03,a3,xc3,w3,y04,a4,xc4,w4)</span><br><span class="line">    plt.plot(xfit,yfit+offset,linewidth=5.0,color = cr)</span><br><span class="line">    # 分峰</span><br><span class="line">    y00 = y01 + y02 + y03 + y04 + offset</span><br><span class="line">    # voigt</span><br><span class="line">    yfit1 = Voigt(xfit,y00,a1,p1,f1)</span><br><span class="line">    plt.plot(xfit,yfit1,linewidth=3.0,linestyle=&#x27;:&#x27;, color=&#x27;slateblue&#x27;)</span><br><span class="line">    yfit2 = Voigt(xfit,y00,a2,p2,f2)</span><br><span class="line">    plt.plot(xfit,yfit2,linewidth=3.0,linestyle=&#x27;:&#x27;, color=&#x27;darkslateblue&#x27;)</span><br><span class="line">    # gauss</span><br><span class="line">    yfit3 = Gauss(xfit,y00,a3,xc3,w3)</span><br><span class="line">    plt.plot(xfit,yfit3,linewidth=3.0,linestyle=&#x27;:&#x27;, color=&#x27;g&#x27;)</span><br><span class="line">    yfit4 = Gauss(xfit,y00,a4,xc4,w4)</span><br><span class="line">    plt.plot(xfit,yfit4,linewidth=2.5,linestyle=&#x27;:&#x27;, color=&#x27;mediumpurple&#x27;)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">def plot_nihe(xx,popt,func):</span><br><span class="line">    xfit = np.linspace(xx.min(),xx.max(),5000)</span><br><span class="line">    if func == &#x27;Lorentz&#x27;:</span><br><span class="line">        yfit = Lorentz(xfit,popt[0],popt[1],popt[2],popt[3])</span><br><span class="line">        plt.plot(xfit,yfit,linewidth=5.0,color = &#x27;r&#x27;)</span><br><span class="line">    elif func == &#x27;Gauss&#x27;:</span><br><span class="line">        yfit = Gauss(xfit,popt[0],popt[1],popt[2],popt[3])</span><br><span class="line">        plt.plot(xfit,yfit,linewidth=5.0,color = &#x27;r&#x27;)</span><br><span class="line">    elif func == &#x27;Vogit&#x27;:</span><br><span class="line">        y0,amp, pos, fwhm = popt</span><br><span class="line">        yfit = Voigt(xfit, y0, amp, pos, fwhm)</span><br><span class="line">        plt.plot(xfit,yfit,linewidth=5.0,color = &#x27;r&#x27;)</span><br><span class="line">    elif func == &#x27;my_fit_cure&#x27;:</span><br><span class="line">        show_the_cure(xfit,popt)#展示拟合参数</span><br><span class="line">        show_the_fen(popt)#展示峰值曲线</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def ready_to_show():</span><br><span class="line">    x_major_locator=MultipleLocator(10)#准备刻度</span><br><span class="line">    #标签</span><br><span class="line">    plt.xlabel(&#x27;wavenumber$(\mathit&#123; cm^&#123;-1&#125;&#125;)$&#x27;,fontdict=&#123;&#x27;family&#x27; : &#x27;Times New Roman&#x27;, &#x27;size&#x27;   : 29&#125;)</span><br><span class="line">    plt.ylabel(&#x27;intensity(arb.units)&#x27;,fontdict=&#123;&#x27;family&#x27; : &#x27;Times New Roman&#x27;, &#x27;size&#x27;   : 29&#125;)</span><br><span class="line">    ax=plt.gca()</span><br><span class="line">    ax.xaxis.set_major_locator(x_major_locator)         #画刻度</span><br><span class="line">    plt.xlim(0,120)</span><br><span class="line">    plt.grid(axis=&#x27;x&#x27;,linestyle=&#x27;-.&#x27;)                   #画竖线</span><br><span class="line">    #plt.text(100,80,&#x27;atm&#x27;,ha = &#x27;center&#x27;,va = &#x27;bottom&#x27;,fontsize=7)#加标签</span><br><span class="line">    #ax.set_yticks([])#隐藏y轴刻度</span><br><span class="line">    plt.yticks(fontproperties = &#x27;Times New Roman&#x27;, size = 23)</span><br><span class="line">    plt.xticks(fontproperties = &#x27;Times New Roman&#x27;, size = 23)</span><br><span class="line">    plt.show()                          #展示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def fitc(name):</span><br><span class="line">    #提取数据</span><br><span class="line">    x = df[&#x27;w&#x27;]</span><br><span class="line">    layer = df[name]</span><br><span class="line">    x = x.values</span><br><span class="line">    layer = layer.values</span><br><span class="line">    print()</span><br><span class="line">    print(&quot;正在拟合&quot;+name+&quot;曲线&quot;)</span><br><span class="line">    print(&quot;共使用4个拟合峰，参数如下：&quot;)</span><br><span class="line">    #打开画布</span><br><span class="line">    plt.figure(1)</span><br><span class="line">    plot_scatter(x,layer)</span><br><span class="line"></span><br><span class="line">    # 设置范围</span><br><span class="line">    # v = [y0, amp, pos, fwhm]</span><br><span class="line">    # g = [y0,A,xc,w]</span><br><span class="line">    # &quot;偏置&quot;,&quot;幅值&quot;,&quot;中心位置&quot;,&quot;宽度&quot;</span><br><span class="line">    v1 = [500, 100, 10, 0]</span><br><span class="line">    v3 = [7000, 2000, 60, 100]</span><br><span class="line"></span><br><span class="line">    v2 =[500, 100, 50, 0]</span><br><span class="line">    v4 = [7000, 2000, 90, 100]</span><br><span class="line"></span><br><span class="line">    g1 = [200,5000,0,0]</span><br><span class="line">    g3 = [7000,9999000,1,100]</span><br><span class="line"></span><br><span class="line">    g2 = [100,0,-50,0]</span><br><span class="line">    g4 = [7000,2000,200,500]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    popt,pcov = curve_fit(my_fit_cure,x,layer,\</span><br><span class="line">    bounds =([v1[0],v1[1],v1[2],v1[3],v2[0],v2[1],v2[2],v2[3],g1[0],g1[1],g1[2],g1[3],g2[0],g2[1],g2[2],g2[3]],\</span><br><span class="line">             [v3[0],v3[1],v3[2],v3[3],v4[0],v4[1],v4[2],v4[3],g3[0],g3[1],g3[2],g3[3],g4[0],g4[1],g4[2],g4[3]]))</span><br><span class="line"></span><br><span class="line">    plot_nihe(x,popt,&#x27;my_fit_cure&#x27;)</span><br><span class="line">    #保存数据</span><br><span class="line">    #save_name = name + &#x27;.npy&#x27;</span><br><span class="line">    #np.save(save_name,popt)</span><br><span class="line">    #data = np.load(&#x27;a.npy&#x27;)</span><br><span class="line">    ready_to_show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    df = pd.read_csv(&#x27;筛选后的数据.csv&#x27;)</span><br><span class="line">    name = &#x27;2L&#x27;</span><br><span class="line">    fitc(name)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output:</span><br><span class="line">正在拟合2L曲线</span><br><span class="line">共使用4个拟合峰，参数如下：</span><br><span class="line">峰类型       	偏置        	幅值        	中心位置      	宽度        </span><br><span class="line">voigt     	1729.29   	142.40    	39.23     	6.54      </span><br><span class="line">voigt     	1728.95   	104.67    	75.54     	9.38      </span><br><span class="line">gauss     	1485.94   	36595.01  	0.00      	2.88      </span><br><span class="line">gauss     	1410.33   	383.62    	4.32      	184.22  </span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210204121.png"
alt="拟合图" />
<figcaption aria-hidden="true">拟合图</figcaption>
</figure>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>逻辑与科普</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>科普</tag>
        <tag>光谱</tag>
      </tags>
  </entry>
  <entry>
    <title>鬼谷子问题</title>
    <url>/2022/01/05/2022-1/%E9%AC%BC%E8%B0%B7%E5%AD%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>孙膑，庞涓都是鬼谷子的徒弟。</p>
<p>一天鬼谷子出了这道题目：他从2到99中选出两个不同的整数，把积告诉孙膑，把和告诉庞涓。经过一天后，鬼谷子叫来两人问他们能不能猜出这两个数。</p>
<p>庞说：我虽然不能确定这两个数是什么，但是我肯定你也不知道这两个数是什么。</p>
<p>孙说：我本来的确不知道，但是听你这么一说，我现在能够确定这两个数字了。</p>
<p>庞说：既然你这么说，我现在也知道这两个数字是什么了。</p>
<p>请问这两个数字是什么？ <span id="more"></span></p>
<h2 id="使用python求解">使用python求解</h2>
<p>采用思维方式与之前的<a
href="https://splendidwave.github.io/2022/01/03/2022-1/%E6%8E%A8%E7%AE%97%E8%80%81%E5%B8%88%E7%9A%84%E7%94%9F%E6%97%A5/">推算老师生日</a>类似，计算量变大了些，所以写个python来求解，代码和解释如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#定义最大最小值</span><br><span class="line">N = 2</span><br><span class="line">M = 99</span><br><span class="line"></span><br><span class="line">#定义和、积函数</span><br><span class="line">def he(n,m):</span><br><span class="line">    return n+m</span><br><span class="line"></span><br><span class="line">def ji(n,m):</span><br><span class="line">    return n*m</span><br><span class="line"></span><br><span class="line">probably_space_begin = [] #开始的可能空间</span><br><span class="line">probably_ji = []          #可能的积空间</span><br><span class="line">probably_he = []          #可能的和空间</span><br><span class="line"></span><br><span class="line">#给可能空间赋值</span><br><span class="line">for i in range(N,M):</span><br><span class="line">    for j in range(i+1,M+1):</span><br><span class="line">        probably_space_begin.append([(i,j),he(i,j),ji(i,j)])</span><br><span class="line">        probably_he.append(he(i,j))</span><br><span class="line"></span><br><span class="line">#第一句话</span><br><span class="line">#庞不能确定 ——&gt; 和有两种以上分解方式</span><br><span class="line">probably_space_1 = [i for i in probably_space_begin if probably_he.count(i[1]) &gt;= 2]</span><br><span class="line">#庞说孙也不知道 ——&gt; 和对应的分解的积的结果有两种以上</span><br><span class="line">#先排除积空间中的独立值</span><br><span class="line">probably_ji = [i[2] for i in probably_space_1]</span><br><span class="line">probably_space_alone = [i for i in probably_space_1 if probably_ji.count(i[2]) == 1 ]</span><br><span class="line">probably_space_2 = [i for i in probably_space_1 if i not in probably_space_alone]</span><br><span class="line">#排除积在probably_space_alone中的因子之和的情况</span><br><span class="line">impossible_he = &#123;i[1] for i in probably_space_alone&#125;</span><br><span class="line">probably_space_3 = [i for i in probably_space_2 if i[1] not in impossible_he]</span><br><span class="line"></span><br><span class="line">#第二句</span><br><span class="line">#孙知道了——&gt;在probably_space_3中确定积即可得到唯一答案</span><br><span class="line">probably_ji = [i[2] for i in probably_space_3]</span><br><span class="line">probably_space_4 = [i for i in probably_space_3 if probably_ji.count(i[2]) == 1]</span><br><span class="line"></span><br><span class="line">#第三句</span><br><span class="line">#庞也知道了——&gt;在probably_space_4中确定和即可得到唯一答案</span><br><span class="line">probably_he = [i[1] for i in probably_space_4]</span><br><span class="line">probably_space_5 = [i for i in probably_space_4 if probably_he.count(i[1]) == 1]</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">if len(probably_space_5) == 1:</span><br><span class="line">    print(&quot;两数分别为：&quot;,probably_space_5[0][0])</span><br></pre></td></tr></table></figure>
<h2 id="疑问与分析">疑问与分析</h2>
<p>写完后运行在2到99范围内答案为4和13，上网查验应该是这个答案，随后发现<a
href="https://blog.csdn.net/weixin_39671140/article/details/119953941">CSDN</a>和<a
href="https://zhuanlan.zhihu.com/p/295066976">知乎</a>上也有使用了python的解法，并指出范围改为3到99结果就会变成13和16.</p>
<p>但我尝试发现本文的程序改为3到99后会无解。比对分析后发现应该是在对第一句话解法上有些偏差。但我觉得两种解法应该是等价的，太菜了找不出bug，有大佬看出问题的可以提示一下。</p>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>逻辑与科普</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>逻辑思维</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux环境下配置Anaconda3管理下的python(备忘录)</title>
    <url>/2022/10/06/2022-10/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AEAnaconda3%E7%AE%A1%E7%90%86%E4%B8%8B%E7%9A%84python(%E5%A4%87%E5%BF%98%E5%BD%95)/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>在centos7下安装anaconda3并管理python</p>
<span id="more"></span>
<h2 id="安装anaconda3">1.安装Anaconda3</h2>
<p>在<a
href="https://www.anaconda.com/products/distribution#linux">官网</a>下载最新版或者使用
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.2.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure> 在镜像源上下载。</p>
<p>下载完成后使用<code>sh Anaconda3-5.2.0-Linux-x86_64.sh</code>进行安装</p>
<p>一路回车然后yes，然后会让你选择安装路径，默认为<code>当前用户/anaconda3</code></p>
<p>随后会问是否添加环境变量（yes），是否安装vscode（no）</p>
<p>最后使用<code>conda info</code>来查看是否安装成功，如果出现<code>bash: conda: command not found</code>是没加入环境变量，或者添加了没重新生效，需要到用户目录下输入<code>source .bashrc</code></p>
<h2 id="创建环境">2.创建环境</h2>
<p><code>conda create -n envname python=3.9</code></p>
<p>其中envname是环境名，3.9是版本号，都可以替换</p>
<p>如果出现创建新环境有出现<code>CondaHTTPError: HTTP 000 CONNECTION FAILED for url</code>可能是防火墙等因素的问题，建议使用<code>conda config --remove-key channels</code>命令去除换源。</p>
<p>使用<code>source activate</code>进入base环境，这是基础环境，不建议在这里安装库，一些conda的命令见下文。</p>
<p>第一次需要使用<code>source activate</code>先激活一次，然后才能使用<code>conda activate envname</code>来直接激活对应环境。</p>
<h2 id="编写运行python">3.编写运行python</h2>
<p>使用<code>touch</code>或<code>vi</code>命令创建<code>.py</code>文件</p>
<p>在终端使用<code>python xxx.py</code>运行</p>
<h2 id="换源">4.换源</h2>
<p>如果有换源需要可以使用下面的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge </span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line"></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
<h2 id="conda的命令">5.conda的命令</h2>
<h3 id="创建环境-1">5.1 创建环境</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n envname python=3.9</span><br></pre></td></tr></table></figure>
<p>其中envname代表环境名</p>
<h3 id="进入虚拟环境">5.2 进入虚拟环境</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda activate envname</span><br></pre></td></tr></table></figure>
<h3 id="退出环境">5.3 退出环境</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure>
<h3 id="删除环境">5.4 删除环境</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda remove -n envname --all</span><br></pre></td></tr></table></figure>
<h3 id="查看所有环境">5.5 查看所有环境</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure>
<h3 id="查看conda版本">5.6 查看conda版本</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure>
<h3 id="更新conda">5.7 更新conda</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda update conda </span><br></pre></td></tr></table></figure>
<h3 id="备份旧环境">5.8 备份旧环境</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create --name new_env_name --clone old_env_name</span><br></pre></td></tr></table></figure>
<h3 id="查看当前环境安装的包">5.9 查看当前环境安装的包</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<p>[1] https://blog.csdn.net/u013898698/article/details/117958663</p>
<p>[2] https://blog.csdn.net/Arno_An/article/details/105229780</p>
<p>[3] https://www.cnblogs.com/tianlang25/p/12433025.html</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy库使用多个元素的数组的真值不明确问题</title>
    <url>/2022/10/19/2022-10/numpy%E5%BA%93%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E7%9C%9F%E5%80%BC%E4%B8%8D%E6%98%8E%E7%A1%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>ValueError: The truth value of an array with more than one element is
ambiguous. Use a.any() or a.all()</p>
<span id="more"></span>
<h2 id="问题">问题</h2>
<p>总所周知，numpy库可以使用布尔值索引，这对加快python的矩阵处理速度起到了很大的作用。比如在图像处理中使用矩阵掩膜的方法<code>out_img[input == i] = xxx</code>可以快速对满足条件的值赋值（比如应用在直方图均衡）。</p>
<p>同时使用<code>np.where(condition, x, y)</code>的方法可以更快得同时处理满足条件和不满足条件的情况,满足修改为x，不满足修改为y。</p>
<p>但使用二维矩阵的俩个条件时就会报错，如要让大于等于era1和小于era2的值赋255，不满足服0
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">layer = np.where((layer&gt;=era1) and (layer&lt;era2),255,0)</span><br><span class="line">ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()</span><br></pre></td></tr></table></figure></p>
<p>当然用<code>a&lt;x&lt;b</code>的条件也是不行的。</p>
<h2 id="解决方法">解决方法</h2>
<ol type="1">
<li><p>使用运算符号代替逻辑运算，把“or”改为“+”或“|”，“and”改为“*”或“&amp;”
在python中True是1，False是0，条件判断都是返回一个布尔值矩阵，在使用运算符号就可以实现矩阵的逻辑运算。</p></li>
<li><p>使用位运算<code>np.bitwise_and()</code>numpy库自带了一个计算位运算的函数，使用这个也可以实现矩阵逻辑运算</p></li>
</ol>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>opencv-python学习(1)--读写与缩放</title>
    <url>/2022/10/11/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(1)--%E8%AF%BB%E5%86%99%E4%B8%8E%E7%BC%A9%E6%94%BE/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>opencv的python图像处理学习笔记</p>
<span id="more"></span>
<h2 id="安装和导入">1.安装和导入</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cv2</span><br></pre></td></tr></table></figure>
<h2 id="读取与显示">2.读取与显示</h2>
<p>读取图片 img = cv2.imread (filename,flags=None)</p>
<p>路径要全英文，图像路径错误不会报错会返回None</p>
<p>读取到了返回的是numpy.ndarray对象 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -1表示保持原有的格式不变</span><br><span class="line"># 0表示将图像调整为单通道的灰度图像</span><br><span class="line"># 1表示将图像调整为3通道的BGR通道。为默认值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img=cv2.imread(&quot;test.jpg&quot;)</span><br><span class="line">img=cv2.imread(&quot;test.jpg&quot;,0)</span><br></pre></td></tr></table></figure></p>
<p>展示图片 cv.imshow(“窗口名字”,被读取的图片)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示一个可以调大小的窗口</span><br><span class="line">cv2.namedWindow(&quot;image&quot;,cv2.WINDOW_FREERATIO)</span><br><span class="line"></span><br><span class="line"># cv2.WINDOW_NORMAL	# 用户可以改变这个窗口大小</span><br><span class="line"># cv2.WINDOW_AUTOSIZE	# 窗口大小自动适应图片大小，并且不可手动更改。   </span><br><span class="line"># cv2.WINDOW_FREERATIO	# 自适应比例</span><br><span class="line"># cv2.WINDOW_KEEPRATIO	# 保持比例</span><br><span class="line"># cv2.WINDOW_OPENGL	# 窗口创建的时候会支持OpenGL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 打开一个名为“image”的窗口并展示图片</span><br><span class="line">cv2.imshow(&quot;image&quot;,img)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 等待结束</span><br><span class="line">cv2.waitKey(0) </span><br><span class="line"># 不加窗口会闪退，值为时间单位ms，0代表永久</span><br><span class="line">cv2.destroyAllWindows() </span><br><span class="line"># 关掉所有窗口</span><br></pre></td></tr></table></figure>
<p>汇总 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img=cv2.imread(&quot;hmbb.jpg&quot;)</span><br><span class="line">print(&#x27;Original Dimensions : &#x27;,img.shape) # 显示图片大小等参数</span><br><span class="line"># cv2.namedWindow(&quot;image&quot;,cv2.WINDOW_FREERATIO)</span><br><span class="line">cv2.imshow(&quot;image&quot;,img)</span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p>
<h3 id="缩放">3.缩放</h3>
<p>cv2.resize()</p>
<p>快速使用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img = cv.resize(img,(width,height))</span><br><span class="line"># 默认双线性插值</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resize(InputArray src, OutputArray dst, Size dsize, </span><br><span class="line">        double fx=0, double fy=0, int interpolation=INTER_LINEAR )</span><br><span class="line"></span><br><span class="line">InputArray src ：输入，原图像</span><br><span class="line">OutputArray dst： 输出，缩放后的图像</span><br><span class="line"></span><br><span class="line">dsize：输出图像的大小，要元组类型，两个元素xy。</span><br><span class="line"></span><br><span class="line">fx：width方向的缩放比例</span><br><span class="line">fy：height方向的缩放比例</span><br><span class="line"></span><br><span class="line">interpolation：指定插值方法</span><br><span class="line"></span><br><span class="line">INTER_NEAREST - 最邻近插值</span><br><span class="line">INTER_LINEAR - 双线性插值(默认)</span><br><span class="line">INTER_CUBIC - 4x4像素邻域内的双立方插值</span><br><span class="line">INTER_LANCZOS4 - 8x8像素邻域内的Lanczos插值</span><br></pre></td></tr></table></figure>
<p>图片缩放函数</p>
<p>来自<a
href="https://blog.csdn.net/tzj1844400/article/details/105648680">计算机视觉图像处理-CV2与图像插值算法</a>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def inter(img):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    图像缩放</span><br><span class="line">    param: img</span><br><span class="line">    return: None</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    scale_percent = 30       # percent of original size</span><br><span class="line">    width = int(img.shape[1] * scale_percent / 100)</span><br><span class="line">    height = int(img.shape[0] * scale_percent / 100)</span><br><span class="line">    dim = (width, height)</span><br><span class="line">    # 双线性插值缩小</span><br><span class="line">    resized = cv2.resize(img, dim, interpolation = cv2.INTER_LINEAR)  # 缩小到0.3 </span><br><span class="line"></span><br><span class="line">    # 缩放大小</span><br><span class="line">    fx = 1.5</span><br><span class="line">    fy = 1.5</span><br><span class="line">    # 方法1：最近邻插值放大</span><br><span class="line">    nearest_resized = cv2.resize(img, dsize=None, fx=fx, fy=fy, interpolation = cv2.INTER_NEAREST)</span><br><span class="line">    # 方法2：双线性插值放大</span><br><span class="line">    linear_resized = cv2.resize(img, dsize=None, fx=fx, fy=fy, interpolation = cv2.INTER_LINEAR)</span><br><span class="line"></span><br><span class="line">    # 展示结果</span><br><span class="line">    cv2.imshow(&quot;Resized image&quot;, resized)</span><br><span class="line">    cv2.imshow(&quot;INTER_NEAREST image&quot;, nearest_resized)</span><br><span class="line">    cv2.imshow(&quot;INTER_LINEAR image&quot;, linear_resized)</span><br><span class="line">    cv2.waitKey(0)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p>
<p>4.保存</p>
<p>借用官方文档的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import cv2 as cv</span><br><span class="line">img = cv.imread(&#x27;messi5.jpg&#x27;,0)</span><br><span class="line">cv.imshow(&#x27;image&#x27;,img)</span><br><span class="line">k = cv.waitKey(0)</span><br><span class="line">if k == 27: # 等待ESC退出</span><br><span class="line">    cv.destroyAllWindows()</span><br><span class="line">elif k == ord(&#x27;s&#x27;): # 等待关键字，保存和退出</span><br><span class="line">    cv.imwrite(&#x27;messigray.png&#x27;,img)</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>手册说如果是64位，需使用<code>k = cv.waitKey(0)  &amp; 0xFF</code>但实测不需要也是对的。</p>
<h2 id="参考资料">参考资料</h2>
<p>[1] https://www.cnblogs.com/luozx207/p/8611459.html</p>
<p>[2] https://blog.csdn.net/qq_51491920/article/details/124408811</p>
<p>[3] <a
href="https://blog.csdn.net/weixin_41466575/article/details/113058802">cv2.resize()原理详解</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>opencv-python学习(2)--灰度变换与直方图</title>
    <url>/2022/10/17/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(2)--%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%9B%B4%E6%96%B9%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>opencv的python图像处理学习笔记</p>
<span id="more"></span>
<h2 id="灰度变换">1.灰度变换</h2>
<h3 id="灰度化">1.1 灰度化</h3>
<p>灰度化是将图片由RGB三通道转为只有灰度的单通道图片。</p>
<p>改变颜色空间使用<code>cvtColor(input_image, flag)</code>
BGR↔︎灰色和BGR↔︎HSV的转换比较常用，这里主要看灰度图</p>
<p>cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def trun_gray(img):</span><br><span class="line">    try:</span><br><span class="line">        depth = img.shape[2]</span><br><span class="line">        if depth == 3:</span><br><span class="line">            return cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    except IndexError:</span><br><span class="line">        return img</span><br></pre></td></tr></table></figure>
<h3 id="二值化">1.2 二值化</h3>
<p>二值化是将图片矩阵转为只有0和255的图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv2.threshold(src, thresh, maxval, type)</span><br><span class="line"></span><br><span class="line">ret,binary = cv2.threshold(img,0,255,cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br></pre></td></tr></table></figure>
<p>传入源图片src，阈值thresh，最大值maxval，参数type，cv2.THRESH_OTSU指使用OTSU算法自动获取阈值，THRESH_BINARY等参数见下</p>
<p>返回ret是OTSU算法得到的阈值，binary是二值化后的图片</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">名称</th>
<th style="text-align: center;">含意</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">cv2.THRESH_BINARY</td>
<td
style="text-align: center;">像素灰度值小于阈值全为0,大于阈值全为255</td>
</tr>
<tr class="even">
<td style="text-align: center;">cv2.THRESH_BINARY_INV</td>
<td
style="text-align: center;">像素灰度值小于阈值全为255,大于阈值全为0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">cv2.THRESH_TRUNC</td>
<td
style="text-align: center;">像素灰度值小于阈值不变,大于阈值变为阈值</td>
</tr>
<tr class="even">
<td style="text-align: center;">cv2.THRESH_TOZERO</td>
<td
style="text-align: center;">像素灰度值小于阈值不做任何改变,大于阈值全为0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">cv2.THRESH_TOZERO_INV</td>
<td
style="text-align: center;">像素灰度值小于阈值全为0,大于阈值不做任何改变</td>
</tr>
</tbody>
</table>
<h3 id="图像反转">1.3 图像反转</h3>
<p>图像反转又称反色变换，记原图像矩阵为r，灰度范围为[0，L-1]</p>
<p>反转后图像公式如下 <span class="math display">\[
s =  L-1-r
\]</span></p>
<p>如果是二值图就相当于黑白反转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def image_inverse(x):</span><br><span class="line">    value_max = np.max(x)</span><br><span class="line">    y = value_max - x</span><br><span class="line">    return y</span><br></pre></td></tr></table></figure>
<h3 id="对数变换">1.4 对数变换</h3>
<p>通用变换规律 <span class="math display">\[
s = c \cdot \ln(1+r)
\]</span></p>
<p>其中加1是为了确保输出的值都大于0 对数通常以e为底。</p>
<p>变换是为了让图片的动态显示范围更直观，在实际展示时还要注意归一化。一个典型的用处就是展示傅里叶频谱图，频谱的低频值比较重要。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 归一化映射函数</span><br><span class="line">def normImg(self,x):</span><br><span class="line">    return  cv2.normalize(x,None,0,255,cv2.NORM_MINMAX)</span><br><span class="line"></span><br><span class="line">def log_image(self):</span><br><span class="line">  img = self.image</span><br><span class="line">  log = np.uint8(self.normImg(self,np.log(1.0 + img)))</span><br></pre></td></tr></table></figure></p>
<h3 id="伽马变换">1.5 伽马变换</h3>
<p>伽马变换又称幂律变换，可以提升暗部细节，对过白或过暗的图片进行矫正。</p>
<p>基本形式为</p>
<p><span class="math display">\[
s = c (r + \epsilon)^\gamma
\]</span></p>
<p>其中补偿系数<span class="math inline">\(\epsilon\)</span>一般为0</p>
<p>同样伽马变换也要注意映射到指定范围</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def gamma_image(self):</span><br><span class="line">  img = self.image</span><br><span class="line">  gamma = np.power(img, eps)</span><br><span class="line">  gamma = np.uint8(normImg(self,gamma))</span><br></pre></td></tr></table></figure>
<p><strong><span
class="math inline">\(\gamma\)</span>大于1是增强暗度，小于1是增强亮度。</strong></p>
<h3 id="分段线性变换">1.6 分段线性变换</h3>
<h4 id="对比度拉伸">1.6.1 对比度拉伸</h4>
<p>没啥好说的，就是再映射</p>
<h4 id="灰度级分层">1.6.2 灰度级分层</h4>
<p>当只对某一范围的灰度感兴趣时，我们可以将该区域设置为白色或黑色，其他保持不变或变为另一种颜色。这样可以提取出想要的信息。</p>
<h4 id="比特屏幕分层">1.6.3 比特屏幕分层</h4>
<p>对于256级的8位灰度图，将每一位的灰度拆分出来，生成对应的二值图像，并将不同层次的灰度二值图像组合可以在不损失图像精度的前提下降低图像存储空间。</p>
<p>第1位，二值图像灰度值为1的灰度级区间为[2^0, 2^1) , 即 [0, 2);</p>
<p>第2位，二值图像灰度值为1的灰度级区间为[2^1, 2^2), 即 [2, 4);</p>
<p>...</p>
<p>第8位，二值图像灰度值为1的灰度级区间为[2^7, 2^8), 即 [128, 256)
。</p>
<h2 id="直方图">2.直方图</h2>
<h3 id="opencv中的直方图">2.1 opencv中的直方图</h3>
<p>直方图是指把像素值（通常为[0,255]）的像素点个数统计出来画成直方图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 展示直方图</span><br><span class="line">def show_image_hist(self):</span><br><span class="line">    if len(self.image.shape) == 2:</span><br><span class="line">        # hist = cv2.calcHist([self.image],[0],None,[256],[0,256])</span><br><span class="line">        plt.hist(self.image.ravel(),256); </span><br><span class="line">    else:</span><br><span class="line">        color = (&#x27;b&#x27;,&#x27;g&#x27;,&#x27;r&#x27;)</span><br><span class="line">        for i,col in enumerate(color): </span><br><span class="line">            histr = cv2.calcHist([self.image],[i],None,[256],[0,256]) </span><br><span class="line">            plt.plot(histr,color = col) </span><br><span class="line">            plt.xlim([0,256])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p>其中<code>.ravel()</code>是将矩阵拍成一维数组</p>
<p><code>cv2.calcHist(images,channels,mask,histSize,ranges)</code>是opencv的直方图接口，api参数如下</p>
<ul>
<li>images：原图像 当传入函数时应用中括号[]括起来，如[img]</li>
<li>channels：如果输入图像是灰度图，它的值就是[0]；如果是彩色图，传入的参数可以是[0],[1],[2]，分别对应通道B、G、R</li>
<li>mask：掩膜图像。统计整张图像的直方图就把它设置为None。当统计图像某一部分的直方图时，需要自己制作一个掩膜图像</li>
<li>histsize：BIN的数目。用中括号[]括起来，如[256]</li>
<li>ranges：像素值范围，通常为[0, 256]</li>
</ul>
<p>直方图均衡化也可以作为提高图像对比度的一个手段。下面给出一个opencv自带的均衡函数<code>dst = cv2.equalizeHist(img)</code>但通常这样操作效果不是很好，还需要考虑全局的信息，为解决该问题，需要使用<strong>自适应的直方图均衡化</strong>。该方法会将图片切成小块，进行均衡。但直接这样会让噪声也扩撒，所以在切成小块前要先把超过对比度上限的像素点均匀分散到其他bins上。</p>
<p>自适应直方图均衡化的opencv
API是<code>cv2.createCLAHE(clipLimit, tileGridSize)</code></p>
<ul>
<li>clipLimit：对比度限制，默认是40</li>
<li>tileGridSize：分块的大小，默认为8*8</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个自适应均衡化的对象，并应用于图像</span><br><span class="line">clahe = cv.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))</span><br><span class="line">cl1 = clahe.apply(img)</span><br></pre></td></tr></table></figure>
<h3 id="直方图均衡原理">2.2 直方图均衡原理</h3>
<p>以灰度图像为例，它的直方图（不同灰度的像素点个数统计）的积分和为总像素点的个数，图像的灰度变量记为r。然后在其经过一个灰度变换<span
class="math inline">\(T(r)\)</span>后，我们记为s，可知s的总像素个数应该与r相同，也就是说s的直方图积分等于r的直方图积分。同时将s和r归一化（横坐标由[0,L-1]映射到[0,1]，直方图的面积设置为1），这条定理也应该成立，公式如下：</p>
<p><span class="math display">\[
\int_{0}^{b} p_{s}(s) d s=\int_{0}^{a} p_{r}(r) d r
\]</span></p>
<p>其中<span class="math inline">\(a=b=1\)</span>,<span
class="math inline">\(p_s\)</span>和<span
class="math inline">\(p_r\)</span>分别为s和r的直方图函数，因为已经进行了归一化，它们的积分(面积)为1，这样也可以将<span
class="math inline">\(p\)</span>看做是图像的概率密度分布函数。反正在计算机眼里，图片只是一些随机分布的噪点罢了。</p>
<p>另一方面，如果灰度变化函数是单调递增的函数，那么当<span
class="math inline">\(b=T(a)\)</span>时，该公式也应当成立。给一个直观的参考图。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210194032.png"
alt="灰度变化后直方图的关系" />
<figcaption aria-hidden="true">灰度变化后直方图的关系</figcaption>
</figure>
<p>将上式改为微分形式(两边对s求导)有：</p>
<p><span class="math display">\[
p_{s}(s)=\frac{p_{r}(r) d r}{d s}
\]</span></p>
<p>想要让变化后的图片实现直方图均衡，即让<span
class="math inline">\(p_s\)</span>恒等于1，代入可得</p>
<p><span class="math display">\[
p_{r}(r)=\frac{d s}{d r}
\]</span></p>
<p>两边再对r积分得到</p>
<p><span class="math display">\[
s=\int_{0}^{x} p_{r}(r) d r
\]</span></p>
<p>再将积分转换为离散的像素点的求和，最后别忘记了反归一化</p>
<p><span class="math display">\[
s_{k}=(L-1)*\sum_{i=0}^{k} p_{r}(i)
\]</span></p>
<p>这样我们就得到了输出图像灰度变量s，利用直方图巧妙地得到了灰度变化函数。再通过灰度变化函数对原图的像素点进行操作即可得到输出图像。</p>
<h3 id="直方图规定化">2.3 直方图规定化</h3>
<p>有时候均衡不是我们想要达到的目的，比如一个哥特风的cos照，均衡化后反而变亮了，失去了原有的风格。但原图拍摄的又比较暗，无法看清细节。所以我现在希望能将目标图像的直方图转变为我想要的直方图以实现图像变换的效果。</p>
<p>下面简单介绍原理，我们知道对于归一化的图像灰度变量a有</p>
<p><span class="math display">\[
s=T(a) = \int_{0}^{x} p_{a}(a) d a
\]</span></p>
<p>其中s是归一化平衡化直方图的灰度变量，它的概率密度函数恒为1 <span
class="math inline">\(T\)</span>是a到s的灰度变换函数。</p>
<p>那同样对于我们需要的目标图像的灰度变量b，它所对应的平衡直方图也应该是s</p>
<p><span class="math display">\[
s=G(b) = \int_{0}^{x} p_{b}(b) d b
\]</span></p>
<p>其中<span class="math inline">\(G\)</span>是b到s的灰度变换函数。</p>
<p>这里理一下思路：</p>
<p>我们现在可以从目标图像B的灰度直方图中得出灰度变换函数<span
class="math inline">\(G\)</span>、还可以从原图像A中得到均衡后的图像<span
class="math inline">\(A^{&#39;}\)</span>，并且已知目标图像B的均衡后的图像<span
class="math inline">\(B^{&#39;}\)</span>有<span
class="math inline">\(B^{&#39;}=A^{&#39;}\)</span></p>
<p>现在的问题明确了，只要知道了<span
class="math inline">\(G^{-1}\)</span>就可以由<span
class="math inline">\(B^{&#39;}\)</span>获得目标图像B。但问题在于这个反函数没有这么容易求。不过在工程上倒是有一个近似方法，利用<span
class="math inline">\(G\)</span>可以将[0,L-1]范围的像素先做一个映射表。然后通过遍历均衡后图像的像素点通过查表法映射回去。虽然不知道函数，但对于离散值，这样的计算也是足够了。</p>
<h2 id="参考资料">参考资料</h2>
<p>[1] https://blog.csdn.net/XWMRHZZ/article/details/124393745</p>
<p>[2] https://blog.csdn.net/my_cat__/article/details/125477831</p>
<p>[3] opencv官方手册</p>
<p>[4] https://blog.csdn.net/m0_47472749/article/details/114223563</p>
<p>[5] https://blog.csdn.net/gg13213/article/details/123671416</p>
<p>[6] <a
href="https://www.bilibili.com/video/BV1RF41177xo?share_source=copy_web&amp;vd_source=4ed37bc2c316b34de1f0a37e789af272">【手写图像处理库4】别再说数学理论鼓噪无味了，概率论的典型应用，直方图均衡化，一键完成对比度增强，懒人神器，数字图像处理，冈萨雷斯</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>opencv-python学习(3)--加噪与空间滤波</title>
    <url>/2022/10/19/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(3)--%E5%8A%A0%E5%99%AA%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>opencv的python图像处理学习笔记</p>
<span id="more"></span>
<h2 id="图像噪声">1.图像噪声</h2>
<p>图像噪声是指存在于图像数据中的不必要的或多余的干扰信息。有些噪声严重影响了图片的质量，因此在图片预处理的过程中需要先将图片的噪声去除。</p>
<p>噪声通常是随机过程，需要具备一定的概率论相关知识才能更好的理解。</p>
<p>常见的噪声有如下几种：椒盐/高斯/泊松/散斑，下面给出使用python对图片加噪的方法。部分代码参考<a
href="https://blog.csdn.net/sinat_29957455/article/details/123977298">csdn文章
python使用opencv对图像添加(高斯/椒盐/泊松/斑点)噪声</a></p>
<h3 id="椒盐噪声">1.1 椒盐噪声</h3>
<p>这个名字起的色香味俱全，椒盐噪声实际上指的是两种颜色的噪声，黑点为椒，白点为盐。在图片上的分布通常是随机的，就像是撒了胡椒和盐在图片上，由此得名。</p>
<p><strong>产生的原因</strong>通常是<strong>脉冲干扰</strong>或者<strong>传感器内部错误</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 加椒盐噪声</span><br><span class="line">def add_pepper_and_salt(self):</span><br><span class="line">    # 获取数量和椒盐比</span><br><span class="line">    amount = float(self.config.get(&quot;Noisy&quot;,&quot;noise_ratio&quot;))</span><br><span class="line">    p_vs_s = float(self.config.get(&quot;Noisy&quot;,&quot;pepper_vs_salt&quot;))</span><br><span class="line">    noisy_img = np.copy(self.image)</span><br><span class="line">    num_pepper = np.ceil(amount * noisy_img.size * p_vs_s)</span><br><span class="line">    num_salt = np.ceil(amount * noisy_img.size * (1. - p_vs_s))</span><br><span class="line">    #设置添加pepper噪声</span><br><span class="line">    coords = [np.random.randint(0, i - 1, int(num_pepper)) for i in self.image.shape]</span><br><span class="line">    noisy_img[tuple(coords)] = 0</span><br><span class="line">    #设置添加salt噪声</span><br><span class="line">    coords = [np.random.randint(0, i - 1, int(num_salt)) for i in self.image.shape]</span><br><span class="line">    noisy_img[tuple(coords)] = 255</span><br><span class="line">    # 展示</span><br><span class="line">    win_name = &quot;pepper&amp;salt&quot;</span><br><span class="line">    UIFunctions.wait_key(self,noisy_img,win_name)</span><br></pre></td></tr></table></figure>
<h3 id="高斯噪声">1.2 高斯噪声</h3>
<p>高斯噪声是一种非常常见的噪声，很多噪声都是服从正态分布的，他们被统一称为高斯噪声。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 加高斯噪声</span><br><span class="line">def add_gauss_noisy(self):</span><br><span class="line">    img = self.image</span><br><span class="line">    #获取均值和标准差</span><br><span class="line">    mean = float(self.config.get(&quot;Noisy&quot;,&quot;guass_mean&quot;))</span><br><span class="line">    sigma = float(self.config.get(&quot;Noisy&quot;,&quot;guass_sigma&quot;))</span><br><span class="line">    #生成高斯分布的噪声</span><br><span class="line">    gauss = np.random.normal(mean,sigma,img.shape)</span><br><span class="line">    #给图片添加高斯噪声</span><br><span class="line">    noisy_img = img + gauss</span><br><span class="line">    #设置图片添加高斯噪声之后的像素值的范围</span><br><span class="line">    noisy_img = np.uint8(np.clip(noisy_img,a_min=0,a_max=255))</span><br><span class="line">    # 展示</span><br><span class="line">    win_name = &quot;gauss_noisy&quot;</span><br><span class="line">    UIFunctions.wait_key(self,noisy_img,win_name)</span><br></pre></td></tr></table></figure>
<h3 id="泊松噪声">1.3 泊松噪声</h3>
<p>泊松噪声又称散粒噪声，适合于描述单位时间内随机事件发生的次数的概率分布。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 加泊松噪声</span><br><span class="line">def add_poisson_noisy(self):</span><br><span class="line">    img = self.image</span><br><span class="line">    lam = float(self.config.get(&quot;Noisy&quot;,&quot;poisson_lambda&quot;))</span><br><span class="line">    # 生成泊松分布的噪声</span><br><span class="line">    poisson = np.random.poisson(lam=lam,size=img.shape).astype(dtype=&#x27;uint8&#x27;)</span><br><span class="line">    noisy_img = img + poisson</span><br><span class="line">    noisy_img = np.uint8(np.clip(noisy_img,a_min=0,a_max=255))</span><br><span class="line">    # 展示</span><br><span class="line">    win_name = &quot;poisson_noisy&quot;</span><br><span class="line">    UIFunctions.wait_key(self,noisy_img,win_name)</span><br></pre></td></tr></table></figure>
<h3 id="散斑噪声">1.4 散斑噪声</h3>
<p>散斑的英文是Speckle，产生的原因通常是干涉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 加散斑噪声</span><br><span class="line">def add_speckle_noisy(self):</span><br><span class="line">    img = self.image</span><br><span class="line">    speckle = np.random.randn(*img.shape)</span><br><span class="line">    #给图片添加speckle噪声</span><br><span class="line">    noisy_img = img + img * speckle</span><br><span class="line">    #归一化图像的像素值</span><br><span class="line">    noisy_img = np.uint8(np.clip(noisy_img,a_min=0,a_max=255))</span><br><span class="line">    # 展示</span><br><span class="line">    win_name = &quot;speckle_noisy&quot;</span><br><span class="line">    UIFunctions.wait_key(self,noisy_img,win_name)</span><br></pre></td></tr></table></figure>
<h2 id="平滑空间滤波器">2.平滑空间滤波器</h2>
<h3 id="原理">2.1 原理</h3>
<p>滤波一词源于频域，指筛选掉一部分频率的波。但因为空域和频域是可以通过傅里叶变换相互转换的，所以在空间中对图像进行一些操作在频域上看起来就是滤波(如平滑操作对应于频域的低通滤波)。而且二者各有优劣，所以在空域上对图片进行处理统一称为空间滤波。</p>
<p>平滑滤波器的主要原理是针对每一个像素点对一个核内的数据进行对应处理实现平滑效果。有点类似与卷积但不完全是。</p>
<h3 id="均值滤波">2.2 均值滤波</h3>
<p>对核取平均值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv2.GaussianBlur(img,size)</span><br></pre></td></tr></table></figure>
<p>img 原图像</p>
<p>size 核大小，通常为奇数，如(3，3)</p>
<h3 id="高斯滤波">2.3 高斯滤波</h3>
<p>对核高斯加权</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv2.GaussianBlur(src,ksize,sigmaX,sigmaY)</span><br><span class="line">cv2.GaussianBlur(img,(5,5),0,0)</span><br></pre></td></tr></table></figure>
<p>sigmaX,sigmaY分别表示X,Y方向的标准偏差。
如果两者都为零，则根据内核大小计算它们。</p>
<h3 id="中值滤波">2.4 中值滤波</h3>
<p>取核内的中位数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv2.medianBlur(img, k)</span><br><span class="line">cv2.medianBlur(img,3)</span><br></pre></td></tr></table></figure>
<p>k 为方框的尺寸</p>
<h2 id="锐化空间滤波器">3.锐化空间滤波器</h2>
<h3 id="原理-1">3.1 原理</h3>
<p>通过找到灰度变换明显的区域，强化该范围像素。</p>
<p>这里涉及到寻找一个跳变（边缘）的过程，所以可以采用求导的方法。一阶导或者二阶导（拉普拉斯算子）</p>
<p>因为是寻找边缘，所以还可以用来进行腐蚀，膨胀，边缘检测等操作。</p>
<h3 id="sobel">3.2 sobel</h3>
<p>索贝尔算子方法简单、处理速度快，被广泛应用于边缘提取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=5)</span><br></pre></td></tr></table></figure>
<p>其中第二个参数是数据类型，第3、4个参数是dx,dy
表示水平方向/竖直方向，要求两者只能有一个为1，另一个为0,第5个值表示核的大小</p>
<h3 id="scharr">3.3 scharr</h3>
<p>当索贝尔算子的第五个参数为-1时，就变成了夏尔算子,scharr是sobel的一个增强，如下图</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210195546.png"
alt="scharr 和 sobel" />
<figcaption aria-hidden="true">scharr 和 sobel</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img = cv2.Scharr(img, cv2.CV_64F, 0, 1)</span><br></pre></td></tr></table></figure>
<h3 id="laplace">3.4 laplace</h3>
<p>拉普拉斯算子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img = cv2.Laplacian(self.image, cv2.CV_64F)</span><br></pre></td></tr></table></figure>
<h3 id="canny">3.5 canny</h3>
<p>Canny算法年代久远，但可以说它是边缘检测的一种标准算法，而且仍在广泛使用。</p>
<p>Canny边缘检测算法可以分为以下5个步骤： 1. 高斯滤波来平滑图像去除噪声
2. 找寻图像的强度梯度 3. 应用非最大抑制（non-maximum
suppression）技术来消除边误检 4.
应用双阈值的方法来决定可能的（潜在的）边界 5. 利用滞后技术来跟踪边界</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img = cv2.Canny(img, lowThreshold, highThreshold)</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<p>[1]
https://blog.csdn.net/weixin_40922285/article/details/102801633</p>
<p>[2] https://baike.baidu.com/item/canny%E7%AE%97%E6%B3%95/8439208</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>opencv-python学习(4)--形态学与图像分割</title>
    <url>/2022/10/23/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(4)--%E5%BD%A2%E6%80%81%E5%AD%A6%E4%B8%8E%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>opencv的python图像处理学习笔记</p>
<span id="more"></span>
<h2 id="形态学处理">1.形态学处理</h2>
<h3 id="腐蚀">1.1 腐蚀</h3>
<p>原理：遍历原图像的每一个像素，然后用核的中心点对准当前正在遍历的这个像素，然后取当前结构元素所覆盖下的原图对应区域内的所有像素的最小值，用这个最小值替换当前像素值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k = np.ones((3, 3), np.uint8)</span><br><span class="line">dst = cv2.erode(src, k, iterations=3)</span><br></pre></td></tr></table></figure>
<p>iterations是迭代次数，越多腐蚀力度越大</p>
<h3 id="膨胀">1.2 膨胀</h3>
<p>原理与腐蚀相同，改为使用最大值替换当前像素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k = np.ones((3, 3), np.uint8)</span><br><span class="line">dst = cv2.dilate(src, k, iterations=3)</span><br></pre></td></tr></table></figure>
<h3 id="开运算与闭运算">1.3 开运算与闭运算</h3>
<p>先进行腐蚀再进行膨胀就叫做开运算</p>
<p>先膨胀在腐蚀就是闭运算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k = np.ones((3, 3), np.uint8)</span><br><span class="line">dst = cv2.morphologyEx(src,cv2.MORPH_OPEN,k)</span><br></pre></td></tr></table></figure>
<p>cv2.MORPH_OPEN：指定为开运算</p>
<p>cv2.MORPH_CLOSE：指定为闭运算</p>
<p>cv2.MORPH_GRADIENT 梯度运算（膨胀减去腐蚀）</p>
<p>cv2.MORPH_TOPHAT 礼帽 = 原始-开运算</p>
<p>cv2.MORPH_BLACKHAT 黑帽 = 闭运算-原始</p>
<h2 id="图像分割">2.图像分割</h2>
<h3 id="基于阈值的分割方法">2.1 基于阈值的分割方法</h3>
<ol type="1">
<li>固定阈值分割
&gt;这是最简单的分割方法，大于某一阈值就提取出来，但该方法使用范围也非常的窄。</li>
<li>直方图双峰法
&gt;灰度直方图通常由双峰属性，两个峰值之间的最小值通常可以认为是最优的二值化分界点。</li>
<li>迭代阈值图像分割 &gt;1. 选取终止步长dt &gt;2. 选取初始阈值T0 &gt;3.
使用T分割图像分为G1、G2两组 &gt;4. 统计G1、G2的平均灰度m1、m2 &gt;5.
新阈值为<span class="math inline">\(T=(m1+m2)/2\)</span> &gt;6.
重复iii-v直到新阈值变动值小于dt</li>
<li>OTSU法（最大类间方差法/大津法）
&gt;通过计算分割阈值的最大类间方差得到最合适的分割阈值，公式参考<a
href="https://blog.csdn.net/weixin_44842748/article/details/115827607">【图像分割】自适应阈值图像分割方法（最大类间差法与最大熵法）</a></li>
<li>最大熵法 &gt;同上，基于最大熵选取阈值</li>
</ol>
<h3 id="基于边缘检测的分割方法">2.2 基于边缘检测的分割方法</h3>
<p>锐化空间滤波器内容见上一篇博客，使用锐化算子可以检测出边缘并进行分割。</p>
<h3 id="基于区域的分割方法">2.3 基于区域的分割方法</h3>
<ol type="1">
<li>区域生长法
&gt;根据统一物体区域的像素相似性来聚集像素点达到区域生长的方法。</li>
<li>区域分裂合并法
&gt;将图像任意分成若干互不相交的区域，按准则对这些区域进行分裂合并。差不多是生长法的逆过程。</li>
<li>分水岭法
&gt;分水岭是用三维方法具象化二维图片，将灰度看着是海拔。模拟水淹没地形的过程，通过修建水坝的方式分割区域。</li>
</ol>
<h3 id="基于深度学习的分割方法">2.4 基于深度学习的分割方法</h3>
<p>K-Means
Clustering（k聚类）是一种非监督学习算法，对于给定样本集，按照距离大小划分为k个簇。</p>
<p>opencv提供的api</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compactness, labels, (centers) = cv2.kmeans(data, K, bestLabels, criteria, attempts, centers)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>data：输入的样本数据，必须是按行组织样本，每一行为一个样本数据，列表示样本的维度。</li>
<li>K：最终的簇的数目。</li>
<li>bestLabels：预设的分类标签或者None。</li>
<li>criteria：迭代停止的模式选择，这是一个含有三个元素的元组型数。格式为（type,
max_iter, epsilon）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其中type有如下模式：</span><br><span class="line">cv2.TERM_CRITERIA_EPS ：精确度（误差）满足epsilon，则停止。</span><br><span class="line">cv2.TERM_CRITERIA_MAX_ITER：迭代次数超过max_iter，则停止。</span><br><span class="line">cv2.TERM_CRITERIA_EPS+cv2.TERM_CRITERIA_MAX_ITER：两者结合，满足任意一个结束。</span><br></pre></td></tr></table></figure>
<ul>
<li>attempts：重复试验kmeans算法次数，将会返回最好的一次结果。</li>
<li>centers：初始中心选择： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv2.KMEANS_RANDOM_CENTERS：每次随机选择初始中心</span><br></pre></td></tr></table></figure></li>
</ul>
<p>返回值：</p>
<ul>
<li>compactness：密度，返回每个点到相应重心的距离的平方和。</li>
<li>labels：结果标记，每个成员被标记为分组的序号，如 0,1,2,3,4…等。</li>
<li>centers：由聚类的中心的描述信息(可能是坐标，也可能是色彩值)组成的数组。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#K-means均值聚类</span><br><span class="line">Z = img.reshape((-1, 3))</span><br><span class="line">Z = np.float32(Z)      #转化数据类型</span><br><span class="line">c = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)</span><br><span class="line">k = 4  # 聚类个数</span><br><span class="line">ret, label, center = cv2.kmeans(Z, k, None, c, 10, cv2.KMEANS_RANDOM_CENTERS)</span><br><span class="line">center = np.uint8(center)</span><br><span class="line">res = center[label.flatten()]</span><br><span class="line">output_img = res.reshape((img.shape))</span><br></pre></td></tr></table></figure>
<h3 id="opencv的人脸检测">3. opencv的人脸检测</h3>
<p>既然都提到图像分割和机器学习，这就不得不试一试人脸检测了。opencv有自带的训练好的数据，调一下库还是很快就能实现出来。</p>
<p>主要是使用分类器和检测多脸 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 加载人脸特征，该文件在 python安装目录\Lib\site-packages\cv2\data 下</span><br><span class="line">face_cascade = cv2.CascadeClassifier(&#x27;haarcascade_frontalface_default.xml&#x27;)</span><br><span class="line">faces = face_cascade.detectMultiScale(img, scaleFactor, minNeighbors, minSize,maxSize)</span><br><span class="line"></span><br><span class="line"># image表示的是要检测的输入图像</span><br><span class="line"># scaleFactor表示每次图像尺寸减小的比例</span><br><span class="line"># minNeighbors表示检测到多少次才算是目标</span><br><span class="line"># minSize为目标的最小尺寸 元组</span><br><span class="line"># maxSize为目标最大尺寸 元组</span><br><span class="line"># 除了image其他都可以不输入</span><br></pre></td></tr></table></figure></p>
<p>工程实例 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 人脸检测</span><br><span class="line">def facefind(self):</span><br><span class="line">   # 读入图片并转换为灰度</span><br><span class="line">   img = self.image</span><br><span class="line">   gray = UIFunctions.trun_gray(self,img)</span><br><span class="line">   # 加载人脸特征，该文件在 python安装目录\Lib\site-packages\cv2\data 下</span><br><span class="line">   face_cascade = cv2.CascadeClassifier(r&#x27;modules\haarcascade_frontalface_default.xml&#x27;)</span><br><span class="line">   faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=4, minSize=(20, 20))</span><br><span class="line">   # 绘制矩形框</span><br><span class="line">   for (x, y, w, h) in faces:</span><br><span class="line">      cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2)</span><br><span class="line">   win_name = &quot;face&quot;</span><br><span class="line">   UIFunctions.wait_key(self,img,win_name)</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料">参考资料</h2>
<p>[1] <a
href="https://blog.csdn.net/weixin_45848575/article/details/125420149">python-opencv图像处理-腐蚀和膨胀</a></p>
<p>[2] <a
href="https://blog.csdn.net/fengdu78/article/details/124011203">【深度学习】基于区域生长的图像分割算法！</a></p>
<p>[3]
https://blog.csdn.net/weixin_53598445/article/details/123730985</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>opencv-python学习(5)--傅里叶变换与小波变换</title>
    <url>/2022/10/25/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(5)--%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>opencv的python图像处理学习笔记</p>
<p>从空间基的角度介绍小波变换</p>
<span id="more"></span>
<h2 id="信号的数学表示">1. 信号的数学表示</h2>
<p>人类探索自然的工具是数学，为此探索的第一步就是将现实中的事物映射到数学上。</p>
<p>函数就是很好的工具，甚至可以将抽象的数学用图像的方法在坐标系中表示出来。比如一个阶跃信号，被表示为了一个幅值随时间变化的函数。它可以在平面直角坐标系中表示出来，其中横坐标代表时间，纵坐标是幅值。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200322.jpg"
alt="阶跃信号" />
<figcaption aria-hidden="true">阶跃信号</figcaption>
</figure>
<h2 id="距离与度量空间">2.距离与度量空间</h2>
<p>上面这图是使用Matlab绘制的，看着是连续的线，但实际上只是先绘制了一些离散的点，然后连接成线的。</p>
<p>平面上的点<span
class="math inline">\(p_1\)</span>由两个坐标构成，一个是时间<span
class="math inline">\(x_1\)</span>，一个是幅值<span
class="math inline">\(y_1\)</span></p>
<p>平面集合中的两个元素<span
class="math inline">\(p_1,p_2\)</span>，在数学上可以引入<strong>距离</strong>的概念，定义为<span
class="math inline">\(d(p_1,p_2)\)</span>,该距离函数被称为空间集合上的度量，<strong>有距离函数的空间集合就称为度量空间。</strong></p>
<p>这里为便于理解就不给出严格的数学定义，下同。</p>
<h2 id="范数与赋范空间">3.范数与赋范空间</h2>
<p>有了度量函数就可以度量距离了，但是对于单个点的距离或者说是向量还没有办法度量。</p>
<p>如果你认为和零点的距离不就是向量的距离吗，那非常好，这个空间的范数就已经被定义了，<strong>拥有范数函数的空间集合就称为赋范空间。</strong></p>
<p>显而易见赋范空间应该包含于度量空间。</p>
<h2 id="线性空间内积空间与正交性">4.线性空间、内积空间与正交性</h2>
<p>线性空间的概念就非常熟悉了，满足加法的交换律结合律，乘法的分配律等就是线性空间，线性空间的好处在于任何一个元素都可以使用一组基来线性表示。</p>
<p>对于一个线性赋范空间，如果赋予它内积的运算，它就被称为内积空间，这个运算的数学上的意义是为了能将矢量转换为标量，显而易见内积空间应该包含于线性赋范空间。</p>
<p>当两个向量的内积为0时，这两个向量相互正交，如果一组基两两正交，则称这组基是正交基。</p>
<h2 id="希尔伯特空间">5.希尔伯特空间</h2>
<p>对于上图信号所处的空间来说，是一个简单的二维线性内积空间，其中维度就是指需要多少个值来描述空间中的一个元素。</p>
<p>因为它的坐标集合是实数集，所以这个空间又是完备的，有限维度的完备内积空间被数学家称为欧几里德空间。（完备性要求度量空间中的所有柯西序列都收敛于该空间的一点）</p>
<p>一个有限维度的空间只能表达低于该维度的函数，比如在平面直角坐标系中只能表示一维函数，曲面就需要在三维欧几里德空间中才能画出来。</p>
<p>维度是一方面的局限，另一个可以简化问题的决策在于基的选择。同样是二维的欧几里德空间，表示一个半径为1的圆，使用
<span class="math inline">\(x\)</span>,<span
class="math inline">\(y\)</span>方向的单位向量作为基底，可以写作<span
class="math inline">\(x^2+y^2=1\)</span>，而在极坐标下只需要写<span
class="math inline">\(r=1\)</span></p>
<p>假如有一个空间是无限维的，同时有很多基底供你选择，这样一个空间是不是很棒呢？实际上这也是科学家一直在努力的方向。一个维度不受限的欧几里德空间被称为希尔伯特空间。</p>
<h2 id="傅里叶变换与短时傅里叶变换">6.傅里叶变换与短时傅里叶变换</h2>
<p>希尔伯特空间维度是任意的n维，坐标轴的取值也可以从实数拓展到虚数，人类无法想象这个空间，但数学可以将它抽象出来。为方便理解，我们还是以欧几里德空间来想象它。</p>
<p>有了希尔伯特空间算是解决的第一个问题，无限维的好处是特征有无限多，任何的低维信号在希尔伯特空间都可以映射成向量。现在需要选取一些合适的基，最好的最容易理解和接受的基仍然是沿着假想中的坐标轴的单位向量。</p>
<p>其次是傅里叶提出的三角函数正交基，三角函数的正交性证明感兴趣的可以见参考资料<a
href="#refer-anchor-1"><sup>[4]</sup></a></p>
<p>傅里叶变换的本质就是在希尔伯特空间换了一组基来表示一个信号。为了区分，把以时间方向为基的表示称为时域表示，三角函数基称为频域表示。这一对表示有着非常有意思的性质，他们互为倒空间，在时域上极短的信号体现在频域上就是无限长，反过来也一样。</p>
<p>傅里叶变换很好用，但同时也有它的局限性，因为过多关注了频域，对于时域的信息反而获取不到。对于特定的情况，傅里叶变换后的信号可能没这么容易获取信息。</p>
<p>比如对于一个频率随时间变换的信号，出来的图像如图，上图表示时域信号，下图为频域信号</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210195716.jpg"
alt="傅里叶变换的局限" />
<figcaption aria-hidden="true">傅里叶变换的局限</figcaption>
</figure>
<p>可以看出频谱除了有4个比较明显的峰外还有许多振荡，而且没法体现出在时域信号中频率随时间变化这一显著的特点。</p>
<p>所以为了解决这一问题，短时傅里叶变换被提了出来。既然时间信息丢失了，那就补上，短时傅里叶变换和傅里叶变换唯一的区别在于多了一个窗口函数，用一个窗函数去框选时域信号，然后对这一部分再做傅里叶变换，这体现在空间中就是多了一个维度，用热力图来表示如下。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210195656.jpg"
alt="短时傅里叶变换" />
<figcaption aria-hidden="true">短时傅里叶变换</figcaption>
</figure>
<p>短时傅里叶变换就很明显的表现出了时间上的频率变换，但问题在于要怎么知道这个窗口选多大才是合理的，选大了就会出现和傅里叶变换一样的问题出现时域信息丢失，选小了会让频域上的分辨率降低，这里倒是有点测不准原理的感觉了。</p>
<h2 id="小波变换">7.小波变换</h2>
<p>不知道该多大的窗口那不如把窗口也变为可变的，不过这样一来，维度又会多了一维，在三维空间里就显得失去了直观性。再往深了考虑的解决方法是使用自适应短时傅里叶变换，使用算法来让窗口自适应信号。</p>
<p>不过也可以换个角度思考，现在陷入瓶颈的原因还是在于使用了两个互为倒空间的基，出现了测不准的问题，如果重新在希尔伯特空间选择一个基，是否就能够解决这个问题。</p>
<p>首先波这个概念很好，有了波才引出了频域，我们希望保留它。其次加窗的想法也很好，它保留了时域的信息，这两者都是有物理意义的。这样我们是否能够使用一个小范围的波来作为基呢？起个名字就叫小波，用<span
class="math inline">\(\psi(t)\)</span>来表示。，样子大概如下。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200305.png"
alt="小波" />
<figcaption aria-hidden="true">小波</figcaption>
</figure>
<p>当然这只是一个概念图，光有一个波可构不成希尔伯特空间的基。</p>
<p>好在我们是在线性空间里讨论的，只要一个集合能被一组已知的基完全线性表示，那这个集合也是一组基。这里完全线性表示的意思是用上了所有的元素才能表示全。</p>
<p>所以只要加上尺度变换<span
class="math inline">\(\frac{1}{\sqrt{a}}\psi(\frac{t}{a})\)</span>,这样随着a的变换，在时域上看是变胖变瘦，在频域上看是遍历所有频率。前面的系数是为了归一化，同样为了方便处理，我们人为将小波在时域上的积分设置为0，这样就和三角函数相统一了。</p>
<p>解决了基的问题，好像顺带也把频域的特性提取问题解决了，因为小波基底的选择就是借用的波的概念，下一步是让波在时域上动起来，这个也很好处理，只要用初中学的函数平移就行。以小波为基底的变换就叫小波变换。下面直接给出函数<span
class="math inline">\(f(t)\)</span>小波变换的完整公式。</p>
<p><span class="math display">\[
W T(a, \tau)=\frac{1}{\sqrt{a}} \int_{-\infty}^{\infty} f(t) *
\psi\left(\frac{t-\tau}{a}\right) d t
\]</span></p>
<p>实际上小波不一定长得和上图一样，尺度变换也可以用其他方法表示，记作<span
class="math inline">\(\phi(t)\)</span></p>
<p>小波的函数<span
class="math inline">\(\psi(t)\)</span>被称为母小波，尺度函数<span
class="math inline">\(\phi(t)\)</span>被称为父小波。确定了两者就可以愉快地进行小波变换了！</p>
<h2 id="参考资料">参考资料</h2>
<p>[1] <a
href="https://www.bilibili.com/video/BV1ce4y1p7jF/?spm_id_from=333.880.my_history.page.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">卷积神经网络的底层是傅里叶变换，傅里叶变换的底层是希尔伯特空间坐标</a></p>
<p>[2] <a
href="https://www.zhihu.com/question/332144499/answer/731866608">希尔伯特空间、内积空间的定义有什么关系和区别？</a></p>
<p>[3] <a
href="https://blog.csdn.net/weixin_36811328/article/details/81207753">欧几里得空间与希尔伯特空间</a></p>
<div id="refer-anchor-1">

</div>
<p>[4] <a
href="https://www.bilibili.com/video/BV1Et411R78v/?from=search&amp;seid=7859464741790869886&amp;spm_id_from=333.337.0.0&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">纯干货数学推导_傅里叶级数与傅里叶变换_Part1_三角函数的正交性</a></p>
<p>[5] <a
href="https://zhuanlan.zhihu.com/p/143510464">Matlab中短时傅里叶变换
spectrogram和stft的用法</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>opencv-python学习(6)--六个图像处理小项目</title>
    <url>/2022/10/29/2022-10/opencv-python%E5%AD%A6%E4%B9%A0(6)--%E5%85%AD%E4%B8%AA%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%B0%8F%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>opencv的python图像处理学习笔记</p>
<p>转像素画、转字符画、图片九宫格、图片蒙太奇、幻影坦克、证件照裁剪。</p>
<p>部分代码参考互联网。 <span id="more"></span></p>
<h2 id="图像转像素画">1.图像转像素画</h2>
<p>效果如下</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200353.png"
alt="可莉像素" />
<figcaption aria-hidden="true">可莉像素</figcaption>
</figure>
<p>实现原理是通过将图片缩小10倍，然后用最邻近插值放大回原来的尺寸。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 图片像素化</span><br><span class="line">def pixel_image(self):</span><br><span class="line">    img = self.image.copy()</span><br><span class="line">    rows, cols = img.shape[:2]</span><br><span class="line">    img = cv2.resize(img,(cols//10,rows//10))</span><br><span class="line">    img = cv2.resize(img,(cols,rows),interpolation=cv2.INTER_NEAREST)</span><br><span class="line">    win_name = &quot;pixel&quot;</span><br><span class="line">    UIFunctions.wait_key(self,img,win_name)</span><br></pre></td></tr></table></figure>
<p>其中<code>wait_key</code>函数内容是用opencv打开图片，然后接受一些保存等指令的函数。</p>
<h2 id="图片转字符画">2.图片转字符画</h2>
<p>效果图</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200413.jpg"
alt="字符画" />
<figcaption aria-hidden="true">字符画</figcaption>
</figure>
<p>原理是把图片转为灰度，然后根据灰度值将像素替换为对应字重的字符最后保存为txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 转为字符画</span><br><span class="line">def character_image(self):</span><br><span class="line">    img = UIFunctions.trun_gray(self,self.image)</span><br><span class="line">    rows, cols = img.shape[:2]</span><br><span class="line">    rows = rows//2</span><br><span class="line">    img = cv2.resize(img,(cols,rows))</span><br><span class="line">    lstChars = self.config.get(&#x27;General&#x27;,&#x27;file_character_list&#x27;)</span><br><span class="line">    output = self.config.get(&#x27;General&#x27;,&#x27;file_save_path&#x27;) + &quot;\\character.txt&quot;</span><br><span class="line">    g2c = 256/len(lstChars)</span><br><span class="line">    </span><br><span class="line">    txt = &quot;&quot;</span><br><span class="line">    for i in range(rows):</span><br><span class="line">        for j in range(cols):</span><br><span class="line">            txt += lstChars[int(img[i,j]/g2c)]</span><br><span class="line">        txt += &#x27;\n&#x27;</span><br><span class="line"></span><br><span class="line">    with open(output, &#x27;w&#x27;) as f:</span><br><span class="line">        f.write(txt)</span><br><span class="line">    QMessageBox.information(None, &#x27;提示&#x27;, &#x27;character.txt输出成功&#x27;,QMessageBox.Ok)</span><br></pre></td></tr></table></figure>
<p>为了表现效果，这里将高缩了一半。output是文件路径，lstChars是自定义的字符。上图使用的字符串是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$B8&amp;WM*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|1?-_+~&lt;&gt;i!lI,^`.</span><br></pre></td></tr></table></figure>
<p>注意把字重大的放前面。</p>
<h2 id="图片九宫格">3.图片九宫格</h2>
<p>图片九宫格是发朋友圈常用的一种格式，该项目可以辅助将一张图片切割成9张。</p>
<p>效果</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200430.png"
alt="图片九宫格" />
<figcaption aria-hidden="true">图片九宫格</figcaption>
</figure>
<p>这个没啥说的就是切一下图片,因为懒得pip没用PIL库就直接对数组操作了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 九宫格</span><br><span class="line">def ninegrid_image(self):</span><br><span class="line">    # 切片函数</span><br><span class="line">    def cut_image(img,width):</span><br><span class="line">        box_list = []</span><br><span class="line">        if len(img.shape) == 2:</span><br><span class="line">            for i in range(0, 3):</span><br><span class="line">                for j in range(0, 3):</span><br><span class="line">                    box = img[i * width:(i+1) * width, j * width : (j + 1) * width]</span><br><span class="line">                    box_list.append(box)</span><br><span class="line">        elif len(img.shape) == 3:</span><br><span class="line">            for i in range(0, 3):</span><br><span class="line">                for j in range(0, 3):</span><br><span class="line">                    box = img[i * width:(i+1) * width, j * width : (j + 1) * width,:]</span><br><span class="line">                    box_list.append(box)</span><br><span class="line">        return box_list</span><br><span class="line"></span><br><span class="line">    img = self.image.copy()</span><br><span class="line">    value, ok = QInputDialog.getInt(self, &quot;输入窗口&quot;, &quot;请输入裁剪后的边值像素(正方形):&quot;, 300, 0, 2000, 100)</span><br><span class="line">    if ok:</span><br><span class="line">        value = int(value)*3</span><br><span class="line">        img = cv2.resize(img,(value,value))</span><br><span class="line">        box_list = cut_image(img,value//3)</span><br><span class="line">        for i,box in enumerate(box_list):</span><br><span class="line">            save_name = self.config.get(&#x27;General&#x27;,&#x27;file_save_path&#x27;) + &#x27;\\ninegrid_image\\&#x27; + str(i+1)+&#x27;.png&#x27;</span><br><span class="line">            cv2.imwrite(save_name,box)</span><br><span class="line">        QMessageBox.information(None, &#x27;提示&#x27;, &#x27;ninegrid_image输出成功&#x27;,QMessageBox.Ok)</span><br></pre></td></tr></table></figure>
<h2 id="图片蒙太奇">4.图片蒙太奇</h2>
<p>图片蒙太奇是指用一组图片去组合成一张大图的艺术效果。</p>
<p>图片有点大，放本地打开后再截图的图。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200548.jpg"
alt="蒙太奇" />
<figcaption aria-hidden="true">蒙太奇</figcaption>
</figure>
<p>代码主要参考CSDN<a
href="https://blog.csdn.net/Galen_xia/article/details/107955374">蒙太奇照片制作(Opencv+Python)</a></p>
<p>原理是缩放待处理图片，然后匹配区块和图片的直方图找到最合适的，最后做一个融合让效果变好些。</p>
<p>理论上图库内容丰富越好。</p>
<h2 id="幻影坦克">5.幻影坦克</h2>
<p>幻影坦克是现代互联网图片表示的艺术，缩略图上看是一张图，但实际点开就变成了另一张，常见于贴吧。</p>
<p>效果图</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200449.jpg"
alt="幻影坦克" />
<figcaption aria-hidden="true">幻影坦克</figcaption>
</figure>
<p>原理参考b站小迷糊老师的视频《<a
href="https://www.bilibili.com/video/BV1kV411v7fR/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">幻影坦克基础版</a>》</p>
<p>简单讲就是利用背景白色和黑色来叠加出不一样的图片。</p>
<p>灰度处理方面借用了《<a
href="https://blog.csdn.net/WinkySpeed/article/details/127079909">基于OpenCV实现的灰度图幻影坦克</a>》一文的思路</p>
<p>代码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 幻影坦克</span><br><span class="line">def mirage_tank_image(self):</span><br><span class="line">    inside_pic = np.uint8(self.image.copy() * 0.35)</span><br><span class="line">    h,w = inside_pic.shape[:2]</span><br><span class="line">    get_filename_path, ok = QFileDialog.getOpenFileName(self,&quot;选取表图&quot;,self.config.get(&#x27;General&#x27;,&#x27;file_open_path&#x27;))</span><br><span class="line">    if ok:</span><br><span class="line">        out_pic = cv2.imread(get_filename_path)</span><br><span class="line">        # 调整表图大小 与里图一致</span><br><span class="line">        out_pic = cv2.resize(out_pic,(w,h))</span><br><span class="line">        # 如果强度小于100 拉到100</span><br><span class="line">        out_pic[out_pic&lt;100] = 100</span><br><span class="line">        # 转变为灰度图</span><br><span class="line">        inside_pic = UIFunctions.trun_gray(self,inside_pic)</span><br><span class="line">        out_pic = UIFunctions.trun_gray(self,out_pic)</span><br><span class="line">        # 建立新的画布 </span><br><span class="line">        new_pic = np.zeros((h,w,4), np.uint8)</span><br><span class="line">        # print(new_pic.shape)</span><br><span class="line">        # 遍历图片 套用公式</span><br><span class="line">        for i in range(h):</span><br><span class="line">            for j in range(w):</span><br><span class="line">                alpha = 255 - (out_pic[i,j]-inside_pic[i,j])</span><br><span class="line">                if alpha == 0:</span><br><span class="line">                    alpha = 1</span><br><span class="line">                p_new = np.uint8(255*inside_pic[i,j]/alpha)</span><br><span class="line">                new_pic[i,j,0] = p_new</span><br><span class="line">                new_pic[i,j,1] = p_new</span><br><span class="line">                new_pic[i,j,2] = p_new</span><br><span class="line">                new_pic[i,j,3] = alpha</span><br><span class="line">        win_name = &quot;tank&quot;</span><br><span class="line">        UIFunctions.wait_key(self,new_pic,win_name)</span><br></pre></td></tr></table></figure></p>
<h2 id="证件照处理">6.证件照处理</h2>
<p>如果你对证件照态度比较随便的话，可以直接用手机背靠墙拍一张，然后用这个方法处理，直接用打印机打印出来。</p>
<p>效果图</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200512.jpg"
alt="证件照" />
<figcaption aria-hidden="true">证件照</figcaption>
</figure>
<p>原理是建立对应大小的画布，然后把图片处理成1或2寸的，贴到对应位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 证件照处理</span><br><span class="line">def certificate_image(self):</span><br><span class="line">    # 1寸大小</span><br><span class="line">    WIDTH_1IN = 295</span><br><span class="line">    HEIGHT_1IN = 413</span><br><span class="line">    # 2寸大小</span><br><span class="line">    WIDTH_2IN = 413</span><br><span class="line">    HEIGHT_2IN = 626</span><br><span class="line">    # 5寸大小</span><br><span class="line">    WIDTH_5IN = 1500</span><br><span class="line">    HEIGHT_5IN = 1050</span><br><span class="line">    # 非全景6寸照片</span><br><span class="line">    WIDTH_6IN = 1950</span><br><span class="line">    HEIGHT_6IN = 1300</span><br><span class="line">    def cut_photo(photo,choice):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        将照片按照比例进行裁剪并缩放成1寸、2寸</span><br><span class="line">        :param photo: 待处理的照片</span><br><span class="line">        :param choice: &lt;int&gt; 1代表1寸，2代表2寸</span><br><span class="line">        :return: 处理后的照片</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        h,w = photo.shape[:2]</span><br><span class="line">        rate = h / w</span><br><span class="line">        if choice == 1:</span><br><span class="line">            if rate &lt; (HEIGHT_1IN/WIDTH_1IN):</span><br><span class="line">                cut = int((w - int(h / HEIGHT_1IN * WIDTH_1IN)) / 2)</span><br><span class="line">                cut_p = photo[:,cut:w-cut,:]</span><br><span class="line">            else:</span><br><span class="line">                cut = int((h - int(w / WIDTH_1IN * HEIGHT_1IN)) / 2)</span><br><span class="line">                cut_p = photo[cut:w-cut,:,:]</span><br><span class="line">            return cv2.resize(cut_p, (WIDTH_1IN, HEIGHT_1IN))</span><br><span class="line">        if choice == 2:</span><br><span class="line">            if rate &lt; (HEIGHT_2IN/WIDTH_2IN):</span><br><span class="line">                cut = int((w - int(h / HEIGHT_2IN * WIDTH_2IN)) / 2)</span><br><span class="line">                cut_p = photo[:,cut:w-cut,:]</span><br><span class="line">            else:</span><br><span class="line">                cut = int((h - int(w / WIDTH_2IN * HEIGHT_2IN)) / 2)</span><br><span class="line">                cut_p = photo[cut:w-cut,:,:]</span><br><span class="line">            return cv2.resize(cut_p, (WIDTH_2IN, HEIGHT_2IN))</span><br><span class="line"></span><br><span class="line">    # 5寸照排版1</span><br><span class="line">    def layout_photo_5_1(photo):</span><br><span class="line">        photo = cut_photo(photo,1)</span><br><span class="line">        img = np.ones((HEIGHT_5IN,WIDTH_5IN, 3), np.uint8)*255</span><br><span class="line">        img[HEIGHT_5IN//2,:,:] = 128            # 横线</span><br><span class="line">        img[:,int(WIDTH_5IN*0.25),:] = 128      # 竖线1</span><br><span class="line">        img[:,int(WIDTH_5IN*0.5),:] = 128      # 竖线2</span><br><span class="line">        img[:,int(WIDTH_5IN*0.75),:] = 128      # 竖线3</span><br><span class="line">        # 确定位置放上图片</span><br><span class="line">        focus_point = [0.125 * WIDTH_5IN,0.25 * HEIGHT_5IN]</span><br><span class="line">        start_point = [focus_point[0] - 0.5 * WIDTH_1IN, focus_point[1] - 0.5 * HEIGHT_1IN]</span><br><span class="line">        end_point = [focus_point[0] + 0.5 * WIDTH_1IN, focus_point[1] + 0.5 * HEIGHT_1IN]</span><br><span class="line">        for i in range(0,2):</span><br><span class="line">            for j in range(0,4):</span><br><span class="line">                img[int(start_point[1]+0.5*i*HEIGHT_5IN):int(end_point[1]+0.5*i*HEIGHT_5IN),int(start_point[0]+j*WIDTH_5IN/4):int(end_point[0]+j*WIDTH_5IN/4),:] = photo</span><br><span class="line">        return img</span><br><span class="line">    # 5寸混合排版2</span><br><span class="line">    def layout_photo_5_mix(photo):</span><br><span class="line">        photo1 = cut_photo(photo,1)</span><br><span class="line">        photo2 = cut_photo(photo,2)</span><br><span class="line">        photo2 = np.rot90(photo2)</span><br><span class="line">        img = np.ones((HEIGHT_5IN,WIDTH_5IN, 3), np.uint8)*255</span><br><span class="line">        img[HEIGHT_5IN//2,:,:] = 128            # 横线</span><br><span class="line">        img[:,int(WIDTH_5IN*0.25),:] = 128      # 竖线1</span><br><span class="line">        img[:,int(WIDTH_5IN*0.5),:] = 128      # 竖线2</span><br><span class="line">        # 确定位置放上1寸图片</span><br><span class="line">        focus_point = [0.125 * WIDTH_5IN,0.25 * HEIGHT_5IN]</span><br><span class="line">        start_point = [focus_point[0] - 0.5 * WIDTH_1IN, focus_point[1] - 0.5 * HEIGHT_1IN]</span><br><span class="line">        end_point = [focus_point[0] + 0.5 * WIDTH_1IN, focus_point[1] + 0.5 * HEIGHT_1IN]</span><br><span class="line">        for i in range(0,2):</span><br><span class="line">            for j in range(0,2):</span><br><span class="line">                img[int(start_point[1]+0.5*i*HEIGHT_5IN):int(end_point[1]+0.5*i*HEIGHT_5IN),int(start_point[0]+j*WIDTH_5IN/4):int(end_point[0]+j*WIDTH_5IN/4),:] = photo1</span><br><span class="line">        # 确定位置放上2寸图片</span><br><span class="line">        focus_point2 = [0.75 * WIDTH_5IN, 0.25 * HEIGHT_5IN]</span><br><span class="line">        start_point2 = [focus_point2[0] - 0.5 * HEIGHT_2IN, focus_point2[1] - 0.5 * WIDTH_2IN]</span><br><span class="line">        end_point2 = [focus_point2[0] + 0.5 * HEIGHT_2IN, focus_point2[1] + 0.5 * WIDTH_2IN]</span><br><span class="line">        img[int(start_point2[1]):int(end_point2[1]),int(start_point2[0]):int(end_point2[0]),:] = photo2</span><br><span class="line">        img[int(start_point2[1]+ 0.5 * HEIGHT_5IN):int(end_point2[1]+ 0.5 * HEIGHT_5IN),int(start_point2[0]):int(end_point2[0]),:] = photo2</span><br><span class="line">        return img</span><br><span class="line">    # 6寸混合排版1</span><br><span class="line">    def layout_photo_6_mix(photo):</span><br><span class="line">        photo1 = cut_photo(photo,1)</span><br><span class="line">        photo2 = cut_photo(photo,2)</span><br><span class="line">        photo1 = np.rot90(photo1)</span><br><span class="line">        img = np.ones((HEIGHT_6IN,WIDTH_6IN, 3), np.uint8)*255</span><br><span class="line">        img[HEIGHT_6IN//2,:,:] = 128            # 横线1</span><br><span class="line">        img[HEIGHT_6IN//4,:WIDTH_6IN//2,:] = 128 # 横线2</span><br><span class="line">        img[int(HEIGHT_6IN*0.75),:WIDTH_6IN//2,:] = 128 # 横线2</span><br><span class="line">        img[:,int(WIDTH_6IN*0.25),:] = 128      # 竖线1</span><br><span class="line">        img[:,int(WIDTH_6IN*0.5),:] = 128      # 竖线2</span><br><span class="line">        img[:,int(WIDTH_6IN*0.75),:] = 128      # 竖线3</span><br><span class="line">        # 确定位置放上1寸图片</span><br><span class="line">        focus_point = [0.125 * WIDTH_6IN, 0.125 * HEIGHT_6IN]</span><br><span class="line">        start_point = [focus_point[0] - 0.5 * HEIGHT_1IN, focus_point[1] - 0.5 * WIDTH_1IN]</span><br><span class="line">        end_point = [focus_point[0] + 0.5 * HEIGHT_1IN, focus_point[1] + 0.5 * WIDTH_1IN]</span><br><span class="line">        for i in range(0,4):</span><br><span class="line">            for j in range(0,2):</span><br><span class="line">                img[int(start_point[1]+0.25*i*HEIGHT_6IN):int(end_point[1]+0.25*i*HEIGHT_6IN),int(start_point[0]+j*WIDTH_6IN/4):int(end_point[0]+j*WIDTH_6IN/4),:] = photo1</span><br><span class="line">        # 确定位置放上2寸图片</span><br><span class="line">        focus_point2 = [0.625 * WIDTH_6IN, 0.25 * HEIGHT_6IN]</span><br><span class="line">        start_point2 = [focus_point2[0] - 0.5 * WIDTH_2IN, focus_point2[1] - 0.5 * HEIGHT_2IN]</span><br><span class="line">        end_point2 = [focus_point2[0] + 0.5 * WIDTH_2IN, focus_point2[1] + 0.5 * HEIGHT_2IN]</span><br><span class="line">        for i in range(0,2):</span><br><span class="line">            for j in range(0,2):</span><br><span class="line">                img[int(start_point2[1]+0.5*i*HEIGHT_6IN):int(end_point2[1]+0.5*i*HEIGHT_6IN),int(start_point2[0]+j*WIDTH_6IN/4):int(end_point2[0]+j*WIDTH_6IN/4),:] = photo2</span><br><span class="line"></span><br><span class="line">        return img</span><br><span class="line"></span><br><span class="line">    img = self.image.copy()</span><br><span class="line">    items = (&#x27;1寸&#x27;, &#x27;2寸&#x27;, &#x27;5寸(8*1寸)&#x27;, &#x27;5寸(4*1寸+2*2寸)&#x27;, &#x27;6寸(8*1寸+4*2寸)&#x27;)</span><br><span class="line">    item,ok = QInputDialog.getItem(self,&quot;区域分割&quot;,&quot;选择需要分成几块&quot;,items,3,False)</span><br><span class="line">    if ok:</span><br><span class="line">        if item == &#x27;1寸&#x27;:</span><br><span class="line">            img = cut_photo(img,1)</span><br><span class="line">        elif item == &#x27;2寸&#x27;:</span><br><span class="line">            img = cut_photo(img,2)</span><br><span class="line">        elif item == &#x27;5寸(8*1寸)&#x27;:</span><br><span class="line">            img = layout_photo_5_1(img)</span><br><span class="line">        elif item == &#x27;5寸(4*1寸+2*2寸)&#x27;:</span><br><span class="line">            img = layout_photo_5_mix(img)</span><br><span class="line">        elif item == &#x27;6寸(8*1寸+4*2寸)&#x27;:</span><br><span class="line">            img = layout_photo_6_mix(img)</span><br><span class="line"></span><br><span class="line">        win_name = &quot;ID photo&quot;</span><br><span class="line">        UIFunctions.wait_key(self,img,win_name)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>基于python的拉曼光谱多峰拟合程序开发笔记1</title>
    <url>/2022/03/30/2022-3/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E6%8B%89%E6%9B%BC%E5%85%89%E8%B0%B1%E5%A4%9A%E5%B3%B0%E6%8B%9F%E5%90%88%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>因为感觉origin在拟合拉曼光谱方面不太好用，而且更喜欢python的绘图风格。</p>
<p>于是自己写的一个python程序，本文是随着程序开发一同写的，记录一下编程框架和难点，不代表最终版本。</p>
<p><strong>注意：本文是类似于草稿和日记的笔记，不用作解释代码和介绍程序功能。使用说明会另开文章。</strong>
<span id="more"></span></p>
<p><em>编辑器使用的是 python 3.9.0 Shell 本来是用的 vscode 用的
python3.9</em></p>
<p><em>后来为了玩原神自动钓鱼又装了 anaconda，它自动装了 python3.10
然后又把 vscode重新装了。刚好那是我准备学
c++于是在vscode配了c++的环境，python的懒得弄了，直接在shell上敲。</em></p>
<p><em>jupyter我只在编写小段程序，或者玩机器学习的适合用。</em></p>
<h2 id="使用库">使用库</h2>
<p>numpy pandas matplotlib.pyplot scipy.optimize中的curve_fit
scipy.special中的wofz tkinter</p>
<p>自建 fitcures plotpic setting subfunction ## 1.输入格式</p>
<p>utf-8格式保存的csv文件。部分展示如下</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203636.png"
alt="输入文件样式" />
<figcaption aria-hidden="true">输入文件样式</figcaption>
</figure>
<h2 id="代码架构">2.代码架构</h2>
<h3 id="界面">2.1 界面</h3>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203647.png"
alt="界面" />
<figcaption aria-hidden="true">界面</figcaption>
</figure>
<p>界面使用的是tkinter库，用类方法调用，初始化函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 调用时初始化</span><br><span class="line">    def __init__(self):</span><br><span class="line">        global root</span><br><span class="line">        root = tk.Tk()</span><br><span class="line">        root.resizable(width=False, height=False)</span><br><span class="line">        root.title(&quot;拉曼拟合&quot;)</span><br><span class="line">        root.geometry(&#x27;580x850&#x27;)</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.filename = tk.StringVar()  # 文件名</span><br><span class="line">        self.df = pd.DataFrame()        # 数据块</span><br><span class="line">        self.pack()</span><br><span class="line">        self.init_data()</span><br><span class="line">        self.main_window()</span><br><span class="line">        root.mainloop()</span><br></pre></td></tr></table></figure>
<p>其中self.main_window()是主界面布局，内容如上图。</p>
<p>拟定按钮上四个为参数相关，下四个为画图相关。截止2022年3月30号，“绘图参数”按钮功能和“绘制总览图”按钮功能还未开发，其余的开发完毕。</p>
<p>点击上四个按钮都会出现一个弹窗，可以选择文件或者修改参数，详见使用说明。</p>
<p>点击下四个按钮会在命令窗口出现交互或者出一张图。</p>
<h3 id="绘图和拟合">2.2 绘图和拟合</h3>
<p>绘制散点图没啥好说的</p>
<p>使用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plt.scatter(x, y, alpha=0.8,s=13,color=scatter_color)</span><br></pre></td></tr></table></figure> 就可以解决. alpha 是透明度</p>
<p>拟合需要先有函数,下面给出多峰拟合函数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def Lorentz(x,y0,A,xc,w):</span><br><span class="line">    y = y0 + w*A*(w/(4*(x-xc)**2 + w**2))</span><br><span class="line">    return y</span><br><span class="line"></span><br><span class="line">def Gauss(x,y0,A,xc,w):</span><br><span class="line">    y = y0 + A * np.exp(-2*((x-xc)/w)**2)</span><br><span class="line">    return y</span><br><span class="line"></span><br><span class="line">def Voigt(x, y0, amp, pos, fwhm, shape = 1):</span><br><span class="line">    tmp = 1/wofz(np.zeros((len(x))) + 1j*np.sqrt(np.log(2.0))*shape).real</span><br><span class="line">    return y0+tmp*amp*wofz(2*np.sqrt(np.log(2.0))*(x-pos)/fwhm+1j*np.sqrt(np.log(2.0))*shape).real</span><br><span class="line"></span><br><span class="line"># 多峰拟合函数</span><br><span class="line"># g,l,v分别为高斯、洛伦兹和Voigt峰的数量</span><br><span class="line"># temp和p是参数，每个峰有4个参数</span><br><span class="line">def fit_function(x,g,l,v,temp,*p):</span><br><span class="line">    y = 0</span><br><span class="line">    if isinstance(temp,str):</span><br><span class="line">        p = list(p[0])</span><br><span class="line">    else:</span><br><span class="line">        p = list(p)</span><br><span class="line">        p.insert(0,temp)</span><br><span class="line">    for i in range(g):</span><br><span class="line">        y += Gauss(x,p[i*4+0],p[i*4+1],p[i*4+2],p[i*4+3])</span><br><span class="line">    for i in range(g,g+l):</span><br><span class="line">        y += Lorentz(x,p[i*4+0],p[i*4+1],p[i*4+2],p[i*4+3])</span><br><span class="line">    for i in range(g+l,g+l+v):</span><br><span class="line">        y += Voigt(x,p[i*4+0],p[i*4+1],p[i*4+2],p[i*4+3])</span><br><span class="line">    return y</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>拟合使用curve_fit</p>
<p>因为是不定长度参数，所以我先使用lambda函数包装了一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">popt,pcov = curve_fit(lambda x,temp,*p: fit_function(x,g,l,v,temp,*p),x,y,\</span><br><span class="line">    bounds =(fit_lower_bound,fit_upper_bound))</span><br></pre></td></tr></table></figure>
<h3 id="文件存储和读取">2.3 文件存储和读取</h3>
<p>保存使用的是np.savez</p>
<p>调用窗口使用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file_path = tk.filedialog.askopenfilename(title=u&#x27;选择要读取的文件&#x27;)</span><br><span class="line"></span><br><span class="line">save_name = tk.filedialog.asksaveasfilename(title=u&#x27;保存参数&#x27;)</span><br></pre></td></tr></table></figure></p>
<h2 id="结束语">结束语</h2>
<p>拉曼拟合1.0开发先到这里，目前先去完善使用手册，等当前部分调试bug无误后再结合使用意见更新该程序。</p>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>随笔与记录</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>基于python的拉曼光谱多峰拟合程序开发笔记2</title>
    <url>/2022/03/31/2022-3/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E6%8B%89%E6%9B%BC%E5%85%89%E8%B0%B1%E5%A4%9A%E5%B3%B0%E6%8B%9F%E5%90%88%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>吐槽</p>
<p><strong>注意：本文是类似于草稿和日记的笔记，不用作解释代码和介绍程序功能。使用说明会另开文章。</strong>
<span id="more"></span></p>
<h2 id="正文">正文</h2>
<p>昨天把这个程序的使用文档写完后，让同门的老郭用用，因为他正好在使用
origin
拟合拉曼。因为他是分段拟合的，所以多峰拟合出来的图像出现了阶跃，我表示使用我的程序不会出现这种问题。</p>
<p>虽然他也有python环境，但考虑到有些第三方库他可能没有安装，我把程序打包成了exe发过去，一同发过去的还有我写的使用文档。</p>
<p>结果他根本不看使用文档，偏执地认为载入参数文件那个按钮是导入数据文件用的，一边点一边破口大骂说我写的垃圾程序，点了没有反应。</p>
<p>我深刻地认识到了我程序的交互能力不足，为此修改了按钮文字和部分功能，推出了2.0版本。
1. 再用这个按键点不正确的文件都会给予提示。 2. 简洁了多个按键的名称 3.
加入了绘制总览图的按键 4. 加入了帮助按键功能 5.
修正了部分画图时的显示错误</p>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>随笔与记录</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>拉曼光谱多峰拟合程序1.0使用说明</title>
    <url>/2022/03/30/2022-3/%E6%8B%89%E6%9B%BC%E5%85%89%E8%B0%B1%E5%A4%9A%E5%B3%B0%E6%8B%9F%E5%90%88%E7%A8%8B%E5%BA%8F1.0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="摘要">摘要</h1>
<p>基于python的拉曼光谱多峰拟合程序1.0版本使用说明</p>
<span id="more"></span>
<h2 id="主界面介绍">0.主界面介绍</h2>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203715.png"
alt="界面" />
<figcaption aria-hidden="true">界面</figcaption>
</figure>
<p>主界面一共有6个可调节参数： 1. 文件名 2. gauss峰数量 3. lorentz峰数量
4. voigt峰数量 5. 波数所在列 6. 待处理数据列</p>
<p>8个功能按钮： 1. 读取参数文件 2. 拟合峰参数 3. 绘图参数 4.
保存当前参数 5. 载入文件数据 6. 绘制散点图 7. 拟合当前 8. 绘制总览图</p>
<p>2个其他按钮 1. 帮助 2. 退出</p>
<h2 id="六个可调节参数">1.六个可调节参数</h2>
<h3 id="文件名">1.1 文件名</h3>
<p>文件要求utf-8格式保存的csv文件，内容样式可以参加下图。</p>
<p>使用excel另存为一下就可以满足条件。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203728.png"
alt="输入文件样式" />
<figcaption aria-hidden="true">输入文件样式</figcaption>
</figure>
<p>输入的名称不需要加后缀，同路径下文件只需输入名称，非同路径下文件需要输入绝对路径。</p>
<h3 id="三个峰数量">1.2 三个峰数量</h3>
<p>多峰拟合程序可以拟合多个峰，光谱的峰一般为这三种更多内容可见<a
href="https://splendidwave.github.io/2022/01/26/2022-1/%E8%B0%B1%E7%BA%BF%E5%B1%95%E5%AE%BD%E5%92%8C%E7%BA%BF%E5%9E%8B%E5%87%BD%E6%95%B0/">谱线展宽和线型函数</a></p>
<p>通过滑块可以分别选择这三个峰的数量，最终拟合函数为这些峰的和。</p>
<h3 id="波数所在列">1.3 波数所在列</h3>
<p>即横坐标所在列，拉曼光谱图像横坐标为拉曼频移，单位为波数</p>
<h3 id="待处理数据列">1.4 待处理数据列</h3>
<p>即纵坐标所在列，拉曼光谱图像纵坐标为强度，通常无单位，绘制散点图和单幅拟合时，需要选中待处理数据。</p>
<p>点击绘制所有会绘制除选中列外的所有数据，如不想忽略该列，可以将滑块拨到和波数所在列相同的位置。</p>
<h2 id="八个按钮">2.八个按钮</h2>
<p>上四个为参数调节及其保存读取</p>
<p>下四个为数据处理及图像输出</p>
<h3 id="读取参数文件按钮">2.1 “读取参数文件”按钮</h3>
<p>点击该按钮会弹出当前路径的窗口。</p>
<p>所有参数保存为.npz格式</p>
<p>在该窗口中可以选择.npz后缀的文件进行参数读取。</p>
<h3 id="拟合峰参数按钮">2.2 “拟合峰参数”按钮</h3>
<p>点击该按钮会弹出一个子窗口，如下</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203740.png"
alt="拟合参数设置窗口" />
<figcaption aria-hidden="true">拟合参数设置窗口</figcaption>
</figure>
<p>该窗口左侧显示3个峰的数量。注意参数不要超出该数目。</p>
<p>每个峰会有4个参数（偏置，幅值，中心位置，半高宽）
在该窗口可以设置每个峰的拟合范围（最大值和最小值）</p>
<p>可以先通过点击“绘制散点图”按钮大致观察峰存在的范围然后依次输入。</p>
<p>如果拟合曲线有多个相同峰，如4个高斯峰，则在Gauss输入框中按顺序写下4个峰的参数，中间用英文逗号分割。</p>
<h3 id="绘图参数按钮">2.3 “绘图参数”按钮</h3>
<p>尚未完成开发，可以进入setting.py手动修改</p>
<h3 id="保存当前参数按钮">2.4 “保存当前参数”按钮</h3>
<p>点击该按钮会弹出当前路径的窗口。您可以保存您当前设定的参数包括主界面参数和拟合峰参数，自定义名字，可以是中文，不需要加后缀。</p>
<h3 id="载入文件数据按钮">2.5 “载入文件数据”按钮</h3>
<p>点击该按钮会尝试读取文件。并输出前5行，可以用于检测是否读取到了正确的数据文件</p>
<h3 id="绘制散点图按钮">2.6 “绘制散点图”按钮</h3>
<p>点击该按钮会根据参数5、6绘制散点图</p>
<h3 id="拟合当前按钮">2.7 “拟合当前”按钮</h3>
<p>点击该按钮会根据参数5、6拟合数据</p>
<h3 id="绘制总览图按钮">2.8 “绘制总览图”按钮</h3>
<p>尚未完成开发</p>
<h2 id="两个其他按钮">3.两个其他按钮</h2>
<h3 id="帮助">3.1 帮助</h3>
<p>点击该按钮会给出一些帮助，可能也没啥用</p>
<h3 id="退出">3.2 退出</h3>
<p>点击该按钮会退出程序，在这之前会先询问一下你是否需要保存参数。</p>
<h2 id="附件">4.附件</h2>
<p>程序下载地址：https://github.com/splendidwave/Raman_fit</p>
]]></content>
      <categories>
        <category>科研项目</category>
        <category>工具项目</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>科研</tag>
        <tag>光谱</tag>
      </tags>
  </entry>
  <entry>
    <title>拉曼光谱多峰拟合程序2.0使用说明</title>
    <url>/2022/03/31/2022-3/%E6%8B%89%E6%9B%BC%E5%85%89%E8%B0%B1%E5%A4%9A%E5%B3%B0%E6%8B%9F%E5%90%88%E7%A8%8B%E5%BA%8F2.0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="摘要">摘要</h1>
<p>基于python的拉曼光谱多峰拟合程序2.0版本使用说明</p>
<span id="more"></span>
<h2 id="主界面介绍">0.主界面介绍</h2>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203801.png"
alt="界面" />
<figcaption aria-hidden="true">界面</figcaption>
</figure>
<p>主界面一共有6个可调节参数： 1. 文件名 2. gauss峰数量 3. lorentz峰数量
4. voigt峰数量 5. 波数所在列 6. 待处理数据列</p>
<p>8个功能按钮： 1. 载入参数 2. 拟合峰参数 3. 绘图参数 4. 保存参数 5.
查看数据 6. 拟合 7. 记录 8. 绘制总览</p>
<p>2个其他按钮 1. 帮助 2. 退出</p>
<h2 id="六个可调节参数">1.六个可调节参数</h2>
<h3 id="文件名">1.1 文件名</h3>
<p>文件要求utf-8格式保存的csv文件，内容样式可以参加下图。</p>
<p>使用excel另存为一下就可以满足条件。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203812.png"
alt="输入文件样式" />
<figcaption aria-hidden="true">输入文件样式</figcaption>
</figure>
<p>输入的名称不需要加后缀，同路径下文件只需输入名称，非同路径下文件需要输入绝对路径。</p>
<h3 id="三个峰数量">1.2 三个峰数量</h3>
<p>多峰拟合程序可以拟合多个峰，光谱的峰一般为这三种更多内容可见<a
href="https://splendidwave.github.io/2022/01/26/2022-1/%E8%B0%B1%E7%BA%BF%E5%B1%95%E5%AE%BD%E5%92%8C%E7%BA%BF%E5%9E%8B%E5%87%BD%E6%95%B0/">谱线展宽和线型函数</a></p>
<p>通过滑块可以分别选择这三个峰的数量，最终拟合函数为这些峰的和。</p>
<h3 id="波数所在列">1.3 波数所在列</h3>
<p>即横坐标所在列，拉曼光谱图像横坐标为拉曼频移，单位为波数</p>
<h3 id="待处理数据列">1.4 待处理数据列</h3>
<p>即纵坐标所在列，拉曼光谱图像纵坐标为强度，通常无单位，绘制散点图和单幅拟合时，需要选中待处理数据。</p>
<h2 id="八个按钮">2.八个按钮</h2>
<h3 id="载入参数按钮">2.1 “载入参数”按钮</h3>
<p>点击该按钮会弹出当前路径的窗口。</p>
<p>所有参数保存为.npz格式。</p>
<p>在该窗口中可以选择.npz后缀的文件进行参数读取。</p>
<h3 id="拟合峰参数按钮">2.2 “拟合峰参数”按钮</h3>
<p>点击该按钮会弹出一个子窗口，如下</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203824.png"
alt="拟合参数设置窗口" />
<figcaption aria-hidden="true">拟合参数设置窗口</figcaption>
</figure>
<p>该窗口左侧显示3个峰的数量。注意参数不要超出该数目。</p>
<p>每个峰会有4个参数（偏置，幅值，中心位置，半高宽）
在该窗口可以设置每个峰的拟合范围（最大值和最小值）</p>
<p>可以先通过点击“绘制散点图”按钮大致观察峰存在的范围然后依次输入。</p>
<p>如果拟合曲线有多个相同峰，如4个高斯峰，则在Gauss输入框中按顺序写下4个峰的参数，中间用英文逗号分割。</p>
<p>点击帮助会在控制台输出上述文字。</p>
<p>点击确认会记录输入的参数。</p>
<h3 id="绘图参数按钮">2.3 “绘图参数”按钮</h3>
<p>尚未完成开发</p>
<h3 id="保存参数按钮">2.4 “保存参数”按钮</h3>
<p>点击该按钮会弹出当前路径的窗口。您可以保存您当前设定的参数包括主界面参数和拟合峰参数，自定义名字，可以是中文，不需要加后缀。</p>
<h3 id="查看数据按钮">2.5 “查看数据”按钮</h3>
<p>点击该按钮会尝试读取文件。输出共有多少列，并输出前5行，可以用于检测是否读取到了正确的数据文件。</p>
<p>最后会根据参数5、6绘制散点图。</p>
<h3 id="拟合按钮">2.6 “拟合”按钮</h3>
<p>点击该按钮会根据所有参数进行数据拟合并显示图片。</p>
<h3 id="记录按钮">2.7 “记录”按钮</h3>
<p>点击该按钮会临时记录本次拟合的结果参数，并有相关提示。</p>
<p>关闭程序数据会清空。</p>
<h3 id="绘制总览按钮">2.8 “绘制总览”按钮</h3>
<p>点击该按钮会将临时记录的数据绘制在一张图中。</p>
<h2 id="两个其他按钮">3.两个其他按钮</h2>
<h3 id="帮助">3.1 帮助</h3>
<p>点击该按钮会给出一些帮助，可能也没啥用。</p>
<h3 id="退出">3.2 退出</h3>
<p>点击该按钮会退出程序，在这之前会先询问一下你是否需要保存参数。选择是在你下次打开该程序后还是会显示当前设置过的参数。</p>
<h2 id="附件">4.附件</h2>
<p>程序下载地址：https://github.com/splendidwave/Raman_fit</p>
]]></content>
      <categories>
        <category>科研项目</category>
        <category>工具项目</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>科研</tag>
        <tag>光谱</tag>
      </tags>
  </entry>
  <entry>
    <title>雅思考试小作文</title>
    <url>/2022/03/26/2022-3/%E9%9B%85%E6%80%9D%E8%80%83%E8%AF%95%E5%B0%8F%E4%BD%9C%E6%96%87/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>学习笔记</p>
<span id="more"></span>
<h2 id="介绍">1.介绍</h2>
<p>雅思考试的写作模块要求在1个小时内完成2篇作文(Task1和Task2)，分别要求150字以上和250字以上。时间分配大概是20分钟和40分钟。</p>
<p>其中小作文即task1，可以归为3个类型，流程图题、地图题和图表题。接下来按顺序依次总结。</p>
<h2 id="流程图题">2.流程图题</h2>
<h3 id="注意点">2.1 注意点</h3>
<p>题目一般为描述一个流程图，下图为剑16第四篇的小作文。和小学作文的看图写作差不多，稍微注意几点。
1.
流程图中很有可能会出现看不懂的词，这个问题不大，因为有些涉及行业的专有名词，只要能判断词性然后用常识适当推理就行。
2.
图中出现的英文单词务必要用上，而且不要同义替换，描述完图是采分点，不用替换是可能会改变原义。
3. 句型都用被动句，因为在图中是看不出动作的执行者的，所以尽量用被动句。
4. 注意时态通常为一般现在时，因为描述的是步骤，不太会改变。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203847.png"
alt="C16T4 task1" />
<figcaption aria-hidden="true">C16T4 task1</figcaption>
</figure>
<h3 id="段落分配">2.2 段落分配</h3>
<p>这个比较自由，除开开头段和结尾段，中间的段落可以随意，一般为2到4段。</p>
<p>开头段是对题目的改写，如将diagram改为picture，shows改成illustrates，process改成how引导的从句。然后加上一句"there
are X stages of the
process."其中X为流程图的步骤，图中如果未标明有多少步，则可以写个大概数，或者直接写several
stages.</p>
<p>结尾段写一句总结句，总结者开头结尾的步骤。结尾："To sum up, this
process begins with --- and culminates in ----"</p>
<p>中间可以加入些无关紧要的话凑下字，还可以使用一下“for further
treatment”等万能句式。</p>
<h3 id="连接词">2.3 连接词</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">中文</th>
<th style="text-align: center;">英文</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">首先</td>
<td style="text-align: center;">first, to begin, first of all</td>
</tr>
<tr class="even">
<td style="text-align: center;">最后</td>
<td style="text-align: center;">finally， in the last stage</td>
</tr>
<tr class="odd">
<td style="text-align: center;">下一步</td>
<td style="text-align: center;">then, next, in the next stage, after
that, following this, later, before doning, subsequently,
afterwards</td>
</tr>
<tr class="even">
<td style="text-align: center;">表示时间</td>
<td style="text-align: center;">during, it takes some time to do
sth</td>
</tr>
<tr class="odd">
<td style="text-align: center;">表同时</td>
<td style="text-align: center;">at the same time, in the meanwhile</td>
</tr>
<tr class="even">
<td style="text-align: center;">表目的</td>
<td style="text-align: center;">in order to, in order that, so that</td>
</tr>
<tr class="odd">
<td style="text-align: center;">表结果</td>
<td style="text-align: center;">as a result, consequently</td>
</tr>
</tbody>
</table>
<h3 id="示范">2.4 示范</h3>
<p>回应上图任务。</p>
<p>NB:这是自己写的，仅供参考。</p>
<p>The picture illustrates how plastic bottles are collected, sorted and
reproduced. There are 9 stages of the process.</p>
<p><strong>To begin</strong>, plastic bottles are dropped in the big
recycle bins, which are often seen in the garbage center of the
community. <strong>Then</strong> they are transported to the recycling
centre by truck <em>for further treatment</em>.</p>
<p><strong>In the next stage</strong>, they are sorted into two
parts(recyclable, unrecyclable, respectively) to be sent to different
places. And <strong>following this</strong>, recyclable plastic bottles
are compressed into blocks <em>to facilitate subsequent
processing</em>.</p>
<p><strong>Next</strong>, they are crushed to chips and washed in
solution before producing plastic pellets by machine.
<strong>Later</strong>, pellets are heated to form raw material, and
those materials can be offered to factories. <strong>Finally</strong>,
they are produced into end products, such as bottles, pencils, T-shirts
and bags and then sold to users.</p>
<p><strong>To sum up</strong>, this process begins with collecting
plastic bottles and culminates in producing products.</p>
<p>字数可能锵锵够，可以再多写点。</p>
<h2 id="地图题">3.地图题</h2>
<h3 id="注意点-1">3.1 注意点</h3>
<p>题目一般2-4个图，需要描述图中建筑的变化，可能是随着年份变化，也可能是计划规划，样式见下图。需要注意如下几点。
1. 注意图中的年份，可能在写作中需要变化时态。 2.
方向描述见指南针，如没有优先找主路，按close to等方位词。 3.
句型使用there be/被动句/定从。 4. 注意比例尺和脚注，如果有的话。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203859.png"
alt="地图题" />
<figcaption aria-hidden="true">地图题</figcaption>
</figure>
<h3 id="段落分配-1">3.2 段落分配</h3>
<p>选定描述顺序，一般为从北向南，也有可能自西向东，中间向四周。</p>
<p>开头段改写题目</p>
<p>第二段按顺序描写第一幅图片中的各个位置</p>
<p>第n段(n≥3)对比描写第n与第n-1段的变化</p>
<p>结尾段总结各个建筑的面积变化。</p>
<h3 id="词汇补充">3.3 词汇补充</h3>
<p>描述初始建造：bebuilt/established/constructed/sited/located</p>
<p>描述改变建造：create(凭空),convert sth into(转变)</p>
<p>计划：beplanned/projected/expected</p>
<p>变大：extend/expand/widen/enlarge/increase in size</p>
<p>变小：demolish/shorten/reduce in size</p>
<p>不变：remain unchanged</p>
<p>变了位置：relocate</p>
<h3 id="示范-1">3.4 示范</h3>
<p>回应上图任务</p>
<p>NB:部分借鉴范文</p>
<p>The two pictures illustrate the changes of a school from 2004 to
2024.</p>
<p>There were 600 students in school in 2004. According to the first
diagram, in the west, there is a road which leads to a carpark. And the
main entrance is opposite the carpark, facing the west side. there is a
path inside the school, that connects the entrance and the sports field.
two school buildings are located on the north and south sides of the
path respectively. other places in school are green areas.</p>
<p>by 2024, the school will have been reconstructed in order to
accommodate more students(about 1,000). For the convenience of teachers
and students, two school buildings will be linked together. And A new
school building is planned to be created. it will replace the original
sports field. At its east, a new carpark is planned, which will be
connected with the first one, via a newly-built road. In addition, the
sports field will be reduced in size and relocated to the south of its
previous location.</p>
<p>During the two decades, several developments take place, with the
addition of new buildings as well as the inclusion of a new road and car
park.</p>
<h2 id="图表题">4.图表题</h2>
<h3 id="图表题简介">4.1 图表题简介</h3>
<p>图表题是在小作文中最为常见的题型，比上两者要重要的多，比较考验写作者的逻辑思维判断能力。</p>
<p>图表题又可以分为静态图表和动态图表，区分依据为是否存在时间变化。整体来说静态图比动态图简单，动态图确定时刻即转变为静态图。所以当题目出现双图表时，最好写动静混合，这样句型不会过多重复。</p>
<p>图表题准备工作： 1. 看：看题目、看标题、看标注、看单位 2.
时：确定时态，一般为三个（一般现在时，一般过去式，一般将来时） 3.
点：选择数据点推荐10+-2 4. 段：分配段落</p>
<h3 id="图表信息处理">4.2 图表信息处理</h3>
<h4 id="静态图表">4.2.1 静态图表</h4>
<p>静态图处理比较简单，背住能熟练使用五大句型处理即可 1. 主动句：The
percentage of money on rent accounts for about 60%. 2. 被动句：60% of
money is spent on rent. 3. there be：There is 60% of money spent on
rent. 4. 60% of money is due to rent. 5. 比较句：A is (nearly/over)
twice as many/much as B.</p>
<h4 id="动态图表">4.2.2 动态图表</h4>
<p>相比之下动态图标不仅要点明数据，同时还要体现出它的变化趋势。</p>
<p>选择数据点（按下列顺序选取，选10个为止）： 1. 起点、终点 2. 最值点 3.
交叉点 多余数据可以不写，或者统一用范围法/平均值法描写</p>
<p>趋势有 1. 上升：grow, rise, increase 2. 下降：fall, decline, decrease
3. 稳定：stablilize, keep stable 4. 波动：fluctuate</p>
<p>副词 1. 大幅度：rapid/ly,sharp/ly,significant/ly,dramatic/ally 2.
小幅度：gradual/ly,steady/ily,slight/ly,slow/ly</p>
<p>动态图的句型 1. 副词+动词：The local-fixed line increased
significantly to about 88 billion minutes in 1999. 2. 形容词+名词：The
local-fixed line showed a trend of gradual decrease from 88 billion in
1999 to 72 billion in 2002. 3. 被动句：A steady increase to about 21
billion minutes was found in National and international-fixed line from
1995 to 2002. 4. 横坐标：The period between 1999 and 2002 saw a sharp
increase in mobile calls from 12 billion to 46 billion minutes. 5. There
be:There is a dramatic increase in mobile calls from 12 billion to 46
billion minutes between 1999 and 2002.</p>
<h3 id="段落处理">4.3 段落处理</h3>
<p>开头段，方法同上，改写题目</p>
<p>中间几段按逻辑分段，能自圆其说即可。如下题1，是一个动态图，可以按三个类别分为三段。</p>
<p>若有5条线，可以按走势（上升或下降）分为两段。若是两个图，可以一个图一段。按逻辑分段，条理更清楚，同时方便段间加逻辑连接词。</p>
<p>结尾段总结，静态图总结最多最少的部分，动态图总结最后变多还是变少了，也可以按静态图分析一下最后的点，也可以分析未来趋势。</p>
<h3 id="示范-2">4.4 示范</h3>
<h4 id="题1">题1</h4>
<p>C9T2</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203921.png"
alt="题1" />
<figcaption aria-hidden="true">题1</figcaption>
</figure>
<p>NB：部分借鉴范文</p>
<p>The figure illustrates how much time UK residents spent on three
different ways of telephone calls between 1995 and 2002.</p>
<p>The local-fixed line was the biggest part of all types during the
whole period. It increased significantly from 70 billion minutes in 1995
to about 88 billion minutes in 1999. After the following year, these
calls showed a trend of gradual decrease to about 72 billion in
2002.</p>
<p>A steady increase to about 24 billion minutes was found in National
and international-fixed line from 1995 to 2002(38 billion and 62 billion
respectively).</p>
<p>Similarly, The period between 1995 and 1999 saw a slight increase in
mobile calls from 2 billion to 12 billion minutes. And there is a
dramatic increase in mobile calls from 12 billion to 46 billion minutes
between 1999 and 2002, during which time the use of mobile phones more
than tripled.</p>
<p>To sum up, local-fixed line calls were still most popular in 2002,
but the gap between the three categories had narrowed.</p>
<h4 id="题2">题2</h4>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203958.jpg"
alt="题2" />
<figcaption aria-hidden="true">题2</figcaption>
</figure>
<p>NB：部分借鉴范文</p>
<p>The figure shows how the amount of water used worldwide changed from
1900 to 2000.</p>
<p>In the global area, water used by agriculture was the largest
quantity throughout the century, rasing from 500 <span
class="math inline">\(Km^3\)</span> in 1900 to around 3,000 <span
class="math inline">\(Km^3\)</span> in 2,000. water used in industrial
and domestic sectors also increased, a slight grow to just below 200
<span class="math inline">\(Km^3\)</span> was found in both two sectors
from 1900 to 1950. From 1950 onwards, industrial use rose steadily to
approximately over 1,000 <span class="math inline">\(Km^3\)</span>,
while domestic use increased more slowly to only 300 <span
class="math inline">\(Km^3\)</span>.</p>
<p>The table illustrates the consumption of water in two countries in
2000. the irrigated land in Brazil is bigger than that in Congo (26,500
<span class="math inline">\(km^2\)</span> and 100 <span
class="math inline">\(km^2\)</span> respectively). And this is reflected
in figures for water consumption per person, 359 <span
class="math inline">\(m^3\)</span> per person in Brazil, and only 8
<span class="math inline">\(m^2\)</span> in Congo. With a population of
176 million, the figures for Brazil indicate how high agricultural water
consumption can be in some countries.</p>
<h2 id="结束语">5.结束语</h2>
<p>本来这篇文章应该在十天前就发了，那时候只有两篇范文没写了，但收到雅思考试被取消的消息，我就不急着复习了，把这个放了一放，导致现在才弄完。</p>
<p>文章内容大部分出自考虫雅思王瑗老师的课程，本文仅作为学习笔记，并不能系统学习雅思写作。相比而言大作文会更难一些，我也没太大把握整理出方法，有空的时候会试着写写。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>雅思</tag>
      </tags>
  </entry>
  <entry>
    <title>麻辣烫问题+三门问题</title>
    <url>/2022/03/21/2022-3/%E9%BA%BB%E8%BE%A3%E7%83%AB%E9%97%AE%E9%A2%98+%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>这是一个吃麻辣烫时候想到的问题</p>
<p>已知一个人的辣觉感受可以分为10个等级（0-9），在点麻辣烫时若顾客没有指明辣度，
老板选择 1. 提供一个默认辣度 2. 每次随机辣度
哪个选择顾客满意度概率大,若为默认好，对于默认的取值为多少最优？</p>
<p>别问我老板为什么不直接问顾客要多辣。 <span id="more"></span></p>
<h3 id="直觉解">直觉解</h3>
<p>我和室友的直觉都认为是定为默认值会更优。</p>
<p>但我转念如果考虑到店内有些人是回头客的情况，肯定是取一个确定的默认值会比较好。</p>
<p>如果只考虑单次客人，从理论出发的话，结果还是需要严谨地验证一下。于是回头写了个程序跑一跑。</p>
<h3 id="使用python求解">使用python求解</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">Num = 100000 # 总样本数</span><br><span class="line">level = 10 #辣觉等级</span><br><span class="line"></span><br><span class="line">default_dic = &#123;&#125; # 默认值设定</span><br><span class="line">for i in range(level):</span><br><span class="line">    default_dic[i] = 0</span><br><span class="line">    </span><br><span class="line">cout_random = 0</span><br><span class="line">for i in range(Num):</span><br><span class="line">    Client_Spicy = random.randint(0,level-1) # 样本的辣度偏好</span><br><span class="line">    Random_Spicy = random.randint(0,level-1) # 随机到的辣度</span><br><span class="line">    if Client_Spicy == Random_Spicy:</span><br><span class="line">        cout_random += 1</span><br><span class="line">    default_dic[Client_Spicy] += 1</span><br><span class="line">    </span><br><span class="line">print(&quot;每次随机满意度为%.2f%%&quot;%(cout_random/Num*100))</span><br><span class="line">for i in range(level):</span><br><span class="line">    print(&quot;默认辣度为%d的满意度为%.2f%%&quot;%(i,default_dic[i]/Num*100))</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每次随机满意度为10.06%</span><br><span class="line">默认辣度为0的满意度为10.07%</span><br><span class="line">默认辣度为1的满意度为9.84%</span><br><span class="line">默认辣度为2的满意度为10.01%</span><br><span class="line">默认辣度为3的满意度为10.06%</span><br><span class="line">默认辣度为4的满意度为10.10%</span><br><span class="line">默认辣度为5的满意度为10.06%</span><br><span class="line">默认辣度为6的满意度为9.92%</span><br><span class="line">默认辣度为7的满意度为10.10%</span><br><span class="line">默认辣度为8的满意度为9.99%</span><br><span class="line">默认辣度为9的满意度为9.85%</span><br></pre></td></tr></table></figure>
<p>从这个结果上看无论做的是什么决策结果都是是相等的。仔细想想也确实，双方处于一个相互未知的状态，能撞一起的概率就应该是1/level.</p>
<p>下面考虑辣度感受为一个范围的情况，我刚开始觉的这种情况可归为等级划分细致程度不同，但后来想想可能存在出入，尤其是边值情况，所以还是写一个程序来验证下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 可接受度在一个范围</span><br><span class="line">import random</span><br><span class="line">Num = 10000 # 样本总数</span><br><span class="line">level = 10 #辣觉等级</span><br><span class="line">Acceptable = 1 #可接受度</span><br><span class="line"></span><br><span class="line">default_dic = &#123;&#125;</span><br><span class="line">for i in range(level):</span><br><span class="line">    default_dic[i] = 0</span><br><span class="line">cout_random = 0</span><br><span class="line"></span><br><span class="line">for i in range(Num):</span><br><span class="line">    Client_Spicy = random.randint(0,level-1) # 样本的辣度偏好</span><br><span class="line">    Random_Spicy = random.randint(0,level-1) # 随机到的辣度</span><br><span class="line">    if  Client_Spicy - Acceptable &lt;= Random_Spicy &lt;= Client_Spicy + Acceptable:</span><br><span class="line">        cout_random += 1</span><br><span class="line">    for j in range(Client_Spicy - Acceptable,Client_Spicy + Acceptable + 1):</span><br><span class="line">        if 0 &lt;= j &lt; level: </span><br><span class="line">            default_dic[j] += 1</span><br><span class="line">print(&quot;每次随机满意度为%.2f%%&quot;%(cout_random/Num*100))</span><br><span class="line">for i in range(level):</span><br><span class="line">    print(&quot;默认辣度为%d的满意度为%.2f%%&quot;%(i,default_dic[i]/Num*100))</span><br></pre></td></tr></table></figure>
<p>output <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每次随机满意度为27.49%</span><br><span class="line">默认辣度为0的满意度为20.67%</span><br><span class="line">默认辣度为1的满意度为30.74%</span><br><span class="line">默认辣度为2的满意度为29.59%</span><br><span class="line">默认辣度为3的满意度为29.32%</span><br><span class="line">默认辣度为4的满意度为29.44%</span><br><span class="line">默认辣度为5的满意度为29.58%</span><br><span class="line">默认辣度为6的满意度为30.01%</span><br><span class="line">默认辣度为7的满意度为29.76%</span><br><span class="line">默认辣度为8的满意度为30.37%</span><br><span class="line">默认辣度为9的满意度为20.00%</span><br></pre></td></tr></table></figure></p>
<p>随机情况能从10%左右升到不到30%非常地符合认知。默认值选中间会存在概率提升3倍，边值翻两倍。
看到结果后觉得还是符合预测的。</p>
<hr />
<h2 id="三门问题">三门问题</h2>
<p>自己想的问题还是过于简单了，于是我另找到一个迷惑直觉的概率问题--三门问题。问题是这样的：
在一个游戏节目中，有三扇门供你选择，其中两扇后面是羊，一扇后面是跑车，选门后就可以获得门后的奖品。很明显选中大奖的概率是1/3，但当你做出选择后，主持人没有立即开门，而是开了另外两扇中的其中一扇门，里面是一只羊，这时候主持人问题你是否需要改变主意改选剩下的那扇。改还是不改？获奖概率分别是多少？</p>
<h3 id="直觉解-1">直觉解</h3>
<p>部分人认为是1/2，因为此时问题变为了2选1，换与不换结果相同。</p>
<p>有人认为是2/3，因为玩家先做出了决策概率是1/3，如果选择换，相当于选择了另外两个，概率将提升到2/3.</p>
<h3 id="讨论">讨论</h3>
<p>我认为应该分为 1. 主持人知道车在哪扇门后面 2.
主持人不知道车在哪扇门后面 两种情况讨论。</p>
<p>在<strong>情况1</strong>下，记玩家不更改选中车事件为A，在三个门的情况下易知<span
class="math inline">\(P(A)=\frac{1}{3}\)</span>，记主持人选中羊所在门事件为B，因为主持人知道车在哪里所以也知道羊在哪里，选中羊的概率为<span
class="math inline">\(P(B)=1\)</span>.</p>
<p>现求在事件B的条件下A的概率，即<span class="math inline">\(P(A\mid
B)\)</span>,根据贝叶斯公式有 <span class="math display">\[P(A\mid B) =
\frac{P(B\mid A)P(A)}{P(B)}\]</span> 显然<span
class="math inline">\(P(B\mid A)\)</span>也应该为1，即可得 <span
class="math display">\[P(A\mid B)=P(A)=\frac{1}{3}\]</span></p>
<p>换门后选中车和不换选到车是一个事件集，所以换门后选到车概率为<span
class="math inline">\(\frac{2}{3}\)</span></p>
<hr />
<p><strong>情况2</strong>下，公式相同只需计算下<span
class="math inline">\(P(B\mid A)\)</span>和<span
class="math inline">\(P(B)\)</span>即可。</p>
<p><span class="math inline">\(P(B\mid
A)\)</span>为玩家第一次就选中车的情况下，主持人从另外两扇门中选中羊的概率，很明显概率为1</p>
<p>P(B)为在玩家选择后主持人再次选择抽中羊的概率，在数值上应为<span
class="math inline">\(P(B)=\frac{1}{3} \times 1 + \frac{2}{3} \times
\frac{1}{2} = \frac{2}{3}\)</span>.</p>
<p>所以 <span class="math display">\[P(A \mid B) = \frac{1 \times
\frac{1}{3}}{\frac{2}{3}}=\frac{1}{2}\]</span></p>
<h2 id="结语">结语</h2>
<p>三门问题用枚举法也可以解，问题本身也不算复杂。有人表示引起争论的原因可能是题目本身存在歧义。This
argument maybe true.</p>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>逻辑与科普</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>逻辑思维</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python进行科研绘图入门--共用坐标、全局字体</title>
    <url>/2022/12/14/2022-12/%E4%BD%BF%E7%94%A8python%E8%BF%9B%E8%A1%8C%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE%E5%85%A5%E9%97%A8--%E5%85%B1%E7%94%A8%E5%9D%90%E6%A0%87%E3%80%81%E5%85%A8%E5%B1%80%E5%AD%97%E4%BD%93/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>python绘图技巧备忘录</p>
<p>使用Matplotlib，以代码呈现为主</p>
<p>字体修改，公用x轴坐标 <span id="more"></span></p>
<h2 id="全局字体修改">1. 全局字体修改</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from matplotlib import rcParams</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">    &quot;font.family&quot;:&#x27;serif&#x27;,</span><br><span class="line">    &quot;font.size&quot;: 35,</span><br><span class="line">    &quot;mathtext.fontset&quot;:&#x27;stix&#x27;,</span><br><span class="line">    &quot;font.serif&quot;: [&#x27;SimSun&#x27;],</span><br><span class="line">&#125;</span><br><span class="line">rcParams.update(config)</span><br></pre></td></tr></table></figure>
<h2 id="局部字体">2.局部字体</h2>
<p>label <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plt.ylabel(r&#x27;Wavenumber $\left (  cm^&#123;-1&#125; \right )$&#x27;, fontdict=&#123;&#x27;family&#x27; : &#x27;Times New Roman&#x27;, &#x27;size&#x27;   : 35&#125;)</span><br></pre></td></tr></table></figure> plt自带latex语法</p>
<p>text <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ax2.text(12,12,r&#x27;$A_g^3$&#x27;,ha = &#x27;center&#x27;,va = &#x27;bottom&#x27;,fontsize=35)</span><br></pre></td></tr></table></figure></p>
<h2 id="共用x坐标">3.共用x坐标</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启画布</span><br><span class="line">plt.figure(1)</span><br><span class="line">x_major_locator=MultipleLocator(2)#准备刻度</span><br><span class="line"># 绘制第一幅图像</span><br><span class="line">ax1=plt.gca()</span><br><span class="line">ax1.xaxis.set_major_locator(x_major_locator)</span><br><span class="line">ax1.set_yticks(np.linspace(50, 100, 11)) </span><br><span class="line">plt.plot(x2,nih,linewidth=3.0,color=&#x27;#2878b5&#x27;)</span><br><span class="line">plt.tick_params(axis=&#x27;y&#x27;,colors=&#x27;#2878b5&#x27;)</span><br><span class="line"></span><br><span class="line"># 共用坐标</span><br><span class="line">ax2 = ax1.twinx()</span><br><span class="line">ax2.set_yticks(np.linspace(0, 50, 11))</span><br><span class="line">plt.plot(x1,nil,linewidth=3.0,color=&#x27;#c82423&#x27;)</span><br><span class="line">plt.tick_params(axis=&#x27;y&#x27;,colors=&#x27;#c82423&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果图如下</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221214142028.png"
alt="共用x坐标" />
<figcaption aria-hidden="true">共用x坐标</figcaption>
</figure>
<h2 id="参考资料">参考资料</h2>
<p>[1] <a
href="https://blog.csdn.net/weixin_42710615/article/details/124297710">Matplotlib文字处理</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习(4)--朴素贝叶斯法</title>
    <url>/2022/12/10/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(4)--%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>朴素贝叶斯法是基于贝叶斯定理与特征独立假设的分类方法，假设出数据集的输入输出的联合概率分布，然后基于此模型利用贝叶斯定理求出给定的输入x对应的后验概率最大的输出y。</p>
<span id="more"></span>
<h2 id="贝叶斯定理">1.贝叶斯定理</h2>
<p>贝叶斯学派认为概率是客观事实的可信度，事件A发生存在一个<strong>先验概率</strong><span
class="math inline">\(P(A)\)</span></p>
<p>在事件A条件下事件B发生的概率记为<span
class="math inline">\(P(B|A)\)</span>，称为<strong>似然概率</strong></p>
<p>相反的，在知道事件B条件下事件A发生的概率为<span
class="math inline">\(P(A|B)\)</span>，称为<strong>后验概率</strong></p>
<p>他们之间存在关系</p>
<p><span class="math display">\[
P(A \mid B)=P(A) \frac{P(B \mid A)}{P(B)}
\]</span></p>
<h2 id="朴素贝叶斯法">2.朴素贝叶斯法</h2>
<p>以分类问题为例，假设要判别的数据<span
class="math inline">\(Y\)</span>是事件A，已知新实例的特征<span
class="math inline">\(X\)</span>为事件B，则先验概率为</p>
<p><span class="math display">\[
P\left(Y=c_{k}\right), \quad k=1,2, \cdots, K
\]</span></p>
<p>其中c是分类的类别一共有K种。先验概率由主观可能性认定。</p>
<p>在已知新实例特征的情况下，该实例为类别<span
class="math inline">\(c_k\)</span>的可能性为后验概率<span
class="math inline">\(P(Y=c_k \mid X = x)\)</span></p>
<p>根据贝叶斯公式上式可以等价于</p>
<p><span class="math display">\[
P\left(Y=c_{k} \mid X=x\right)=\frac{P\left(X=x \mid Y=c_{k}\right)
P\left(Y=c_{k}\right)}{\sum_{k} P\left(X=x \mid Y=c_{k}\right)
P\left(Y=c_{k}\right)}
\]</span></p>
<p>显然后验概率最大的最有可能是这个实例的正确分类。</p>
<p>朴素贝叶斯之所以前面有个朴素，是因为它假设了所有实例特征之间相互独立，根据概率论的知识，独立的事件同时发生的概率就是它们的乘积。</p>
<p>所以上式又可以改写为</p>
<p><span class="math display">\[
y=f(x)=\arg \max _{c_{i}} \frac{P\left(Y=c_{k}\right) \prod_{j}
P\left(X^{(j)}=x^{(j)} \mid Y=c_{k}\right)}{\sum_{k}
P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} \mid
Y=c_{k}\right)}
\]</span></p>
<p>由于上式中的分母都是相同的，而且只要求最大值而不是准确值，所以还可以进一步简化为</p>
<p><span class="math display">\[
y=\arg \max _{c_{k}} P\left(Y=c_{k}\right) \prod_{j}
P\left(X^{(j)}=x^{(j)} \mid Y=c_{k}\right)
\]</span></p>
<p>值得一提的是，后验概率最大化等价于期望风险最小化。</p>
<h2 id="极大似然估计法">3.极大似然估计法</h2>
<p>我们现在只要知道先验概率和条件概率，就可以估计出新实例是属于哪一类的了。</p>
<p>某一类别的先验概率可以用训练集中该类的数量占总数量的比例来似然估计，即</p>
<p><span class="math display">\[
P\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N}
I\left(y_{i}=c_{k}\right)}{N}, k=1,2, \cdots, K
\]</span></p>
<p>其中N是样本总量，I是判别函数。</p>
<p>同理条件概率也可以同个数数获得，当第j个特征<span
class="math inline">\(x^{(j)}\)</span>的可能取值为<span
class="math inline">\({a_{j1},a_{j2},...,a_{js}}\)</span>时</p>
<p><span class="math display">\[
P\left(X^{(j)}=a_{j l} \mid Y=c_{k}\right)=\frac{\sum_{i=1}^{N}
I\left(x_{i}^{(j)}=a_{j l}, y_{i}=c_{k}\right)}{\sum_{i=1}^{N}
I\left(y_{i}=c_{k}\right)}
\]</span></p>
<h2 id="贝叶斯估计">4.贝叶斯估计</h2>
<p>极大似然估计符合人类对样本的直观感受，但可能会因为数据集的问题出现要估计的概率值为0的情况，这可能会影响到后面的计算结果。</p>
<p>为此引入贝叶斯估计，条件概率的贝叶斯估计是</p>
<p><span class="math display">\[
P_{\lambda}\left(X^{(j)}=a_{j l} \mid
Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(j)}=a_{j l},
y_{i}=c_{k}\right)+\lambda}{\sum_{i=1}^{N}
I\left(y_{i}=c_{k}\right)+S_{j} \lambda}
\]</span></p>
<p>其中<span class="math inline">\(\lambda \ge
0\)</span>等价于在随机变量的各个取值中都赋予一个正数，为1时，称为拉普拉斯平滑。<span
class="math inline">\(S_{j} \lambda\)</span>是为了加上分子中<span
class="math inline">\(\lambda\)</span>后使概率和仍为1.</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>统计学习</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习(5)--决策树</title>
    <url>/2022/12/18/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(5)--%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>决策树是一种基本的分类和回归方法，其具有可读性好，分类快等优点。在西瓜书中，决策树就作为例子引入了机器学习，说明了树模型是适合于新手入门学习的内容。本文会从基本概念逐一展开介绍几种决策树的基本算法。
<span id="more"></span></p>
<h2 id="什么是决策树">1.什么是决策树</h2>
<p>分类决策树是一种描述对实例进行分类的树形结构，正如书中西瓜好不好的决策判别。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221218092612.png"
alt="决策树判断西瓜是好瓜还是坏瓜" />
<figcaption aria-hidden="true">决策树判断西瓜是好瓜还是坏瓜</figcaption>
</figure>
<p>人可以同个经验来判别好坏瓜的条件，那对于机器来说，要如何实现并构造决策树呢？不可避免的我们需要一个判别依据，好在信息论里能够给我们一些启发。</p>
<h2 id="信息熵">2.信息熵</h2>
<p>信息熵是用来衡量一个体系的不确定度的物理量，熵这个词也是借用的热力学，信息熵越大，不确定性越强。计算公式如下</p>
<p><span class="math display">\[
H(X)=-\sum_{i=1}^{M} P\left(x_{i}\right) \log _{2} P\left(x_{i}\right)
\tag{1.1}
\]</span></p>
<p>如果不太清楚这个概念可以通过该链接去了解一下<a
href="https://splendidwave.github.io/2022/08/20/2022-8/%E4%BF%A1%E6%81%AF%E9%87%8F%E5%92%8C%E4%BF%A1%E6%81%AF%E7%86%B5/">信息量和信息熵</a></p>
<p>在理解信息熵这个概念后，这里再补充一个<strong>条件熵</strong>，它指的是在某一条件Y下体系具有的信息熵。公式如下</p>
<p><span class="math display">\[
H(X \mid Y)=-\sum_{i=1}^{M} P(x_i \mid Y) \log _{2} P(x_i \mid Y)
\tag{1.2}
\]</span></p>
<p>显然系统的条件熵要比信息熵要小一些，因为条件Y的发生让系统更加确定了一些，它们差值不妨就叫做<strong>信息增益</strong>。公式如下</p>
<p><span class="math display">\[
I(X, Y)=H(X)-H(X \mid Y)\tag{1.3}
\]</span></p>
<h2 id="判别条件">2.判别条件</h2>
<p>有了以上几个量化概念，我们就可以用来量化决策树。</p>
<p>可以看一个具体的例子，有一副去掉大小王的扑克牌(52张)，我从中随机抽取一张，想让机器狗旺财来帮我判别它是<strong>红色还是黑色</strong>。旺财无法直接识别颜色，它只能看见点数和花色,所以它需要用决策树的方法来处理这个问题。</p>
<p>旺财计算了一下该问题的信息熵</p>
<p><span class="math display">\[
\begin{align}
H(X) &amp; = -\sum_{i=1}^{M} P\left(x_{i}\right) \log _{2}
P\left(x_{i}\right)\nonumber\\
&amp; = \frac{1}{2} + \frac{1}{2} \nonumber \\
&amp; = 1 \nonumber
\end{align}
\]</span></p>
<h3 id="使用点数决策-y_1">2.1 使用点数决策 <span
class="math inline">\(Y_1\)</span></h3>
<p>它决定先试试点数，<strong>决策条件为点数大于等于10的都是红色</strong>。</p>
<p>那么条件熵为</p>
<p><span class="math display">\[
H(X \mid Y_1) = (\frac{4}{13}+\frac{9}{13})\cdot
(\frac{1}{4}\log_{2}{4}-\frac{3}{4}\log_{2}\frac{3}{4}) \approx 0.811
\]</span></p>
<p>好像这个条件并没有起到任何帮助，信息增益为<span
class="math inline">\(I(X, Y_1)=0.189\)</span></p>
<h3 id="使用花色决策-y_2">2.2 使用花色决策 <span
class="math inline">\(Y_2\)</span></h3>
<p>旺财改变了策略，<strong>红桃的牌都是红色</strong>。</p>
<p>红桃牌的概率是1/4且全是红色 那么条件熵为</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200707.jpg"
alt="决策2" />
<figcaption aria-hidden="true">决策2</figcaption>
</figure>
<p><span class="math display">\[
H(X \mid Y_2) = \frac{1}{4} \cdot 0 + \frac{3}{4} \cdot 0.91829 \approx
0.689
\]</span></p>
<p>信息增益为<span class="math inline">\(I(X,
Y_2)=0.311\)</span>，看起来好了一些。</p>
<h3 id="花色决策2.0-y_3">2.3 花色决策2.0 <span
class="math inline">\(Y_3\)</span></h3>
<p>旺财注意到上述决策中左节点的信息熵已经是0了，可以停止优化，而右节点的信息熵接近父节点的信息熵，说明优化空间很大，于是它对右节点再采策略认为<strong>方片也是红的</strong>。</p>
<p>毫无疑问信息信息增益达到了最大，旺财完美地完成了任务。</p>
<h2 id="id3算法">3.ID3算法</h2>
<p>ID 是 Iterative
Dichotomiser的缩写，迭代二分器/二叉树，虽然决策树不一定是二叉树，但通常情况下是二分的，3大概是第三代的意思吧。</p>
<p>上述这种以<strong>信息增益作为特征选择的度量</strong>，使用自顶向下的贪心算法遍历决策树空间的算法即为ID3算法。</p>
<p>通俗的讲该算法就是每一步都选择可以实现信息增益最大的特征作为该节点的分类条件直到特征用完或者分类结束。</p>
<p>程序流程图就放在后面给，现在来看看ID3算法优缺点。</p>
<h3 id="id3的优点">3.1 ID3的优点</h3>
<ol type="1">
<li>简单，只需要算信息熵就完了。</li>
<li>鲁棒性强，不容易受到噪声的影响</li>
<li>搜索空间完整，基本上会遍历所有特征</li>
</ol>
<h3 id="id3的缺点">3.2 ID3的缺点</h3>
<ol type="1">
<li>ID3算法会去选择可取值类别多的特征，这是信息熵的计算方法导致的，分得越细，确定性就会越高。</li>
<li>只能计算离散值</li>
<li>无法处理信息缺失</li>
<li>容易过拟合，因为它会遍历所有特征</li>
</ol>
<h2 id="c4.5算法">4.C4.5算法</h2>
<p>ID3 算法的发明人Ross
Quinlan也意识到了这些缺点，有问题就解决呗，ID3会对多分类有个偏好，这是因为信息增益的计算方式导致的，为了解决这一问题，必须将判别条件改变。</p>
<p>为此分裂信息的定义被提出，计算公式如下：</p>
<p><span class="math display">\[
SplitInfo_A(D)=-\sum_{i=1}^{n} \frac{\left|D_{i}\right|}{|D|} \log _{2}
\frac{\left|D_{i}\right|}{|D|}\tag{4.1}
\]</span></p>
<p>其中D是数据集，<span
class="math inline">\(D_i\)</span>是D在特征A下的第i个分类子集。可以看出分裂信息也特征的类别越多值就会越大。</p>
<p>所以只要将信息增益除以分裂信息就可以得到一个消除倾向的判别条件，我们称为<strong>信息增益率</strong>，计算公式如下：</p>
<p><span class="math display">\[
\operatorname{GainRatio}(D,A)=\frac{I(D,
A)}{\operatorname{SplitInfo_A}(D)} \tag{4.2}
\]</span></p>
<p>对于连续的特征值，可以选择遍历这些值找到信息增益最大的分界点来实现对值的二分离散化。</p>
<p>信息缺失可以选择补上期望值，过拟合就采用剪枝的方法来完成。</p>
<p>这样问题就解决了不少，但这类算法还是存在硬伤。一是算法只能用于分类，二是构造过程需要反复遍历，比较大小，还是对数运算，算法效率低。</p>
<h2 id="cart3算法">5.CART3算法</h2>
<h3 id="不如换个判别条件">5.1 不如换个判别条件</h3>
<p>既然对数运算费时，不如直接抛开熵这个数值条件，重新找一个判别依据，公式如下</p>
<p><span class="math display">\[
\operatorname{Gini}(D)=\sum_{k=1}^{K}
\frac{\left|C_{k}\right|}{|D|}\left(1-\frac{\left|C_{k}\right|}{|D|}\right)=1-\sum_{k=1}^{K}
p_{k}^{2} \tag{5.1}
\]</span></p>
<p>我们称它为基尼系数，其中k为类别，<span
class="math inline">\(p_k\)</span>是k类别的概率，它可以识别当前集合的纯度。来看一个具体例子，当k只能取两个值时，如红色牌的概率为<span
class="math inline">\(p_1\)</span> 黑色牌概率为<span
class="math inline">\(p_2\)</span>，而且有<span
class="math inline">\(p_1=1-p_2\)</span>，代入式(5.1)可得基尼系数是一个关于<span
class="math inline">\(p_1\)</span>的二次函数，关系如下图</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200727.jpg"
alt="基尼系数" />
<figcaption aria-hidden="true">基尼系数</figcaption>
</figure>
<p>当集合中只有红色时，即概率<span
class="math inline">\(p=1\)</span>，这时基尼系数为0，当红黑参半时，基尼系数会达到最大。由此可见，基尼系数越小，代表集合纯度越高。</p>
<p>我们可以以此为参考依据，遍历特征，选出加权基尼系数最小的分类方法作为策略。同时CART3永远对数据二分，离散连续一视同仁，二叉树的便捷性也是显而易见的。</p>
<h3 id="谁说树只能分类">5.2 谁说树只能分类</h3>
<p>CART树全名是Classification and Regression
Tree，这说明它既能分类也能回归，回归树的构建本质上是用<strong>平方误差最小化准则</strong>进行特征选择，去生成二叉树。</p>
<p>其判别的条件又不是基尼系数了，而是最小均方差值，公式如下</p>
<p><span class="math display">\[
\min_{j, s}\left[\min_{c_{1}} \sum_{x_{i} \in R_{1}(j,
s)}\left(y_{i}-c_{1}\right)^{2}+\min_{c_2} \sum_{x_{i} \in R_{2}(j,
s)}\left(y_{i}-c_{2}\right)^{2}\right] \tag{5.2}
\]</span></p>
<p>其中因为特征是连续值，该公式的意思是选择第j个特征的s为切分点，这样集合就分为了<span
class="math inline">\(R_1\)</span>和<span
class="math inline">\(R_2\)</span>，使得两个区域的label值和该划分区域的值c平方和最小。得到j和s作为划分的依据，其中<span
class="math inline">\(c_1\)</span>、<span
class="math inline">\(c_2\)</span>取集合的均值： <span
class="math display">\[
c_{1}=\frac{1}{N_{1}} \sum_{x_{i} \in R_{1}} y_{i}, \quad
c_{2}=\frac{1}{N_{2}} \sum_{x_{i} \in R_{2}} y_{i}
\]</span></p>
<p>回归树但看公式可能有些困难，最好找道例题或者自己敲遍代码加强理解。另外cart算法也容易过拟合，需要配合减枝。</p>
<h2 id="随机森林">6.随机森林</h2>
<p>树看起来内容差不多了，但有很多树的时候，就形成了森林。为什么需要很多树？这是因为我们在处理问题时可能会不知道那些特征是有用的，那些特征是没有用的，为此不妨多训练几颗树，让每个树的特征随机选取。最后通过统计所有树的输出结果少数服从多数得到答案。</p>
<p>随机森林的结构简单而高效，当不知道用什么算法时不妨试试随机森林。而且这类集成学习的方法也不单单适用于决策树，同时也可以集成神经网络。</p>
<h2 id="boosting算法">7.Boosting算法</h2>
<p>Boosting是提升的意思，Boosting算法是通过把弱学习器加强成强学习器。一个典型的例子是GBDT算法</p>
<p>GBDT全称是Gradient Boosting Decision
Tree，它利用CART的回归树作为弱学习器。这里只给出实现思路，具体公式暂不呈现。</p>
<p>我们引入一个残差的概念，它指的是模型的预测值和真实值的差距。当我们训练了一个树，它的输出结果会与真实值存在残差，我们可以再训练一个树来预测残差，当然这个预测残差的树也必然会与真实残差存在一个残差。不过没关系，我们可以套娃，套到结果可以接受的样子，大概的思路类似梯度下降法，同时公式也是用的一阶导数（负梯度）来近似残差。</p>
<p>另外还有XGBoost算法，XG是Extreme
Gradient的意思，XGBoost在GBDT的基础上又做了改进，使用了二阶导数的信息，同时又加了一个正则项来防止过拟合。</p>
<h2 id="参考资料">参考资料</h2>
<p>[1] 《统计学习方法》 李航</p>
<p>[2] 《机器学习》 周志华</p>
<p>[3] 知乎文章 <a
href="https://zhuanlan.zhihu.com/p/399549773">零基础一文读懂树模型：从决策树到LightGBM</a></p>
<p>[4] 知乎文章 <a
href="https://zhuanlan.zhihu.com/p/158633779">【预估排序】Xgboost、GBDT、CART等树模型联系和区别（超级详细）</a></p>
<p>[5] CSDN文章 <a
href="https://blog.csdn.net/weixin_45834080/article/details/103036401">对ID3算法的理解及其优缺点</a></p>
<p>[6] b站视频 <a
href="https://www.bilibili.com/video/BV1VA411A7AQ?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">决策树算法例题</a></p>
<p>[7] b站视频 <a
href="https://www.bilibili.com/video/BV1ar4y137GD?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">[5分钟学算法]
#03 决策树 小明毕业当行长</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>统计学习</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习(6)--逻辑斯谛回归</title>
    <url>/2022/12/26/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(6)--%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>逻辑斯谛回归模型利用了逻辑斯谛方程的对数特性，将特征参数映射到[0，1]之间，将问题转换为概率预测，从而实现判别。</p>
<span id="more"></span>
<h2 id="逻辑斯谛方程">1.逻辑斯谛方程</h2>
<p>学过数学建模的应该都知道，逻辑斯谛方程最早提出是用于人口增长模型。下面进行一个简单的推导。</p>
<p>假设人口随时间的函数是<span
class="math inline">\(W(t)\)</span>，人口增长率为<span
class="math inline">\(\beta\)</span>，则人口增长的微分方程为</p>
<p><span class="math display">\[
\frac{\mathrm{d} W(t)}{\mathrm{d} t}  = \beta W(t)
\]</span></p>
<p>解得</p>
<p><span class="math display">\[
W(t) = \exp （\beta t + C）
\]</span></p>
<p>这种指数爆炸型增长是不太可能发生的，毕竟资源是有限的，所以人口增长应该还要和生物容量<span
class="math inline">\(K\)</span>有关，再重新写出微分方程,这里的<span
class="math inline">\(\beta\)</span>和上面的可能存在数值上的差异。</p>
<p><span class="math display">\[
\frac{\mathrm{d} W(t)}{\mathrm{d} t}  = \beta W(t) (K-W(t))
\]</span></p>
<p>这就是逻辑斯谛方程的微分形式，其实这个方程虽然是推猜出来的，但其蕴含了一定的自然规律，所以他从人口模型应用到了其他各个领域，这点和傅里叶变换不谋而合。</p>
<h2 id="逻辑斯谛分布">2.逻辑斯谛分布</h2>
<p>现在我不关心数量了，我更想知道现在的人口占总容量的多少，记比例为<span
class="math inline">\(P(t)\)</span>我们有<span
class="math inline">\(P(t)=W(t)/K\)</span></p>
<p>对于P(t)有</p>
<p><span class="math display">\[
\begin{align}
\frac{\mathrm{d} P(t)}{\mathrm{d} t}  &amp;= \frac{\mathrm{d}
(W(t)/K)}{\mathrm{d} t} \\
&amp;= \frac{\beta}{K}W(t)(K-W(t)) \\
&amp;= K\beta P(t)[1-P(t)]
\end{align}
\]</span></p>
<p>等式就变成了微分方程 <span class="math display">\[
\frac{1}{P[1-P]} P \mathrm{d} P =  C * \mathrm{d} t
\]</span> 其中C是常数</p>
<p>解方程得</p>
<p><span class="math display">\[
P = \frac{\exp{(\alpha+\beta t)}}{1+\exp{(\alpha+\beta t)}}\tag{式1}
\]</span></p>
<p>其中<span class="math inline">\(\alpha\)</span>和<span
class="math inline">\(\beta\)</span>是常数，令<span
class="math inline">\(x = \alpha+\beta t\)</span></p>
<p>将上式函数绘制出来就如下图</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221230151405.png"
alt="逻辑斯谛分布" />
<figcaption aria-hidden="true">逻辑斯谛分布</figcaption>
</figure>
<p>P的物理意义是占比，也就是说它的取值范围在<span
class="math inline">\([0-1]\)</span>之间，这和概率不谋而合，将这个函数视作概率密度函数，可以得到逻辑斯谛分布函数方程和图如下</p>
<p><span class="math display">\[
F(x)=P(X \leqslant x)=\frac{1}{1+\mathrm{e}^{-(x-\mu) / \gamma}}
\]</span></p>
<p><span class="math display">\[
f(x)=F^{\prime}(x)=\frac{\mathrm{e}^{-(x-\mu) /
\gamma}}{\gamma\left(1+\mathrm{e}^{-(x-\mu) / \gamma}\right)^{2}}
\]</span></p>
<p>其中<span class="math inline">\(\mu\)</span>为位置参数，<span
class="math inline">\(\gamma&gt;0\)</span>是形状参数。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221230151747.png"
alt="分布函数" />
<figcaption aria-hidden="true">分布函数</figcaption>
</figure>
<h2 id="二项逻辑斯谛回归模型">3.二项逻辑斯谛回归模型</h2>
<p>对于二分类问题，使用统计学习中常用的<span
class="math inline">\(w\)</span>和<span
class="math inline">\(b\)</span>来代替式1的<span
class="math inline">\(\beta\)</span>和<span
class="math inline">\(\alpha\)</span>,可以得到</p>
<p><span class="math display">\[
P = \frac{\exp (w \cdot x+b)}{1+\exp (w \cdot x+b)}
\]</span></p>
<p>我们人为假定这个P是实例x在参数<span
class="math inline">\(w\)</span>和<span
class="math inline">\(b\)</span>条件下分类为1的概率，毕竟参数是可以训练的，那么有</p>
<p><span class="math display">\[
P(Y=0 \mid x)=\frac{1}{1+\exp (w \cdot x+b)}
\]</span></p>
<p>两者的和为1，使用训练集训练数据后，对于新实例，只需要计算两者的概率让后进行归类即可。</p>
<p>模型的参数可以使用极大似然估计法来得到，设</p>
<p><span class="math display">\[
P(Y=1 \mid x)=\pi(x), \quad P(Y=0 \mid x)=1-\pi(x)
\]</span></p>
<p>似然函数为</p>
<p><span class="math display">\[
\prod_{i=1}^{N}\left[\pi\left(x_{i}\right)\right]^{y_{i}}\left[1-\pi\left(x_{i}\right)\right]^{1-y_{i}}
\]</span></p>
<p>对数似然函数为</p>
<p><span class="math display">\[
\begin{aligned}
L(w) &amp; =\sum_{i=1}^{N}\left[y_{i} \log
\pi\left(x_{i}\right)+\left(1-y_{i}\right) \log
\left(1-\pi\left(x_{i}\right)\right)\right] \\
&amp; =\sum_{i=1}^{N}\left[y_{i} \log
\frac{\pi\left(x_{i}\right)}{1-\pi\left(x_{i}\right)}+\log
\left(1-\pi\left(x_{i}\right)\right)\right] \\
&amp; =\sum_{i=1}^{N}\left[y_{i}\left(w \cdot x_{i}\right)-\log
\left(1+\exp \left(w \cdot x_{i}\right)\right]\right.
\end{aligned}
\]</span></p>
<p>对<span
class="math inline">\(L(w)\)</span>用梯度下降法求极大值即可得到估计值。</p>
<p>最后给出多项逻辑斯谛回归的公式</p>
<p><span class="math display">\[
P(Y=k \mid x)=\frac{\exp \left(w_{k} \cdot x\right)}{1+\sum_{k=1}^{K-1}
\exp \left(w_{k} \cdot x\right)}, \quad k=1,2, \cdots, K-1
\]</span></p>
<h2 id="参考资料">参考资料</h2>
<p>[1] 《统计学习方法》 李航</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>统计学习</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习(7)--最大熵模型</title>
    <url>/2023/01/04/2022-12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(7)--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>支持向量机的学习的目标也是在特征空间中找到一个分离超平面，能将实例分到不同的类。不同与感知机的解有无穷多个，线性可分支持向量机利用间隔最大化求最优分离超平面，解是唯一的。</p>
<span id="more"></span>
<h2 id="间隔">1.间隔</h2>
<p>一般来说，一个点距离分离超平面的远近可以表示分类预测的确信程度。在超平面确定的情况下，点<span
class="math inline">\(x_i\)</span>与超平面的距离可以表示为函数</p>
<p><span class="math display">\[
\left|\frac{1}{\|w\|_{2}} \cdot\left(w \cdot x_i+b\right)\right|
\]</span></p>
<p>定义函数间隔（functional margin）为下式</p>
<p><span class="math display">\[
\hat{\gamma}_{i}=y_{i}\left(w \cdot x_{i}+b\right)
\]</span></p>
<p>记函数间隔<span
class="math inline">\(\hat{\gamma}_{i}\)</span>的最小值为<span
class="math inline">\(\hat{\gamma}\)</span>，函数间隔可以表示分类预测的正确性及准确度。对超平面的法向量添加约束，就可以得到几何间隔（geometric
margin），定义如下</p>
<p><span class="math display">\[
\gamma_{i}=y_{i}\left(\frac{w}{\|w\|} \cdot x_{i}+\frac{b}{\|w\|}\right)
\]</span></p>
<h3 id="最大间隔分离">1.1 最大间隔分离</h3>
<p>最大间隔具有存在性和唯一性，训练数据集的样本点中与分离超平面距离最近的样本点的实例称为支持向量（support
vector），在决定分离超平面时只有支持向量起作用，而其他实例点并不起作用。如果移动支持向量将改变所求的解；但是如果在间隔边界以外移动其他实例点，甚至去掉这些点，则解是不会改变的。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/01/20230104162422.png"
alt="支持向量" />
<figcaption aria-hidden="true">支持向量</figcaption>
</figure>
<h3 id="硬间隔">1.2 硬间隔</h3>
<p>硬间隔(hard
margin)：假定训练样本在样本空间或特征空间中是线性可分的，即存在一个超平面能将不同类的样本完全划分开。</p>
<p>对于硬间隔分类，可以将问题转化为优化问题，即求</p>
<p><span class="math display">\[
\max _{w, b} \quad  \hat{\gamma}_{i}
\]</span></p>
<p><span class="math display">\[
\text { s.t. }  y_{i}\left(\frac{w}{\|w\|} \cdot
x_{i}+\frac{b}{\|w\|}\right) \geqslant \hat{\gamma}, \quad i=1,2,
\cdots, N
\]</span></p>
<p>使用几何间隔来替代间隔函数，这样对超平面的参数<span
class="math inline">\(w,b\)</span>的缩放就不影响结果，可以令几何最小间隔<span
class="math inline">\(\hat{\gamma}=1\)</span>，将所求表达式转换为如下形式</p>
<p><span class="math display">\[
\max _{w, b} \frac{1}{\|w\|}
\]</span></p>
<p><span class="math display">\[
\text { s.t. } \quad y_{i}\left(w \cdot x_{i}+b\right) \geqslant 1,
\quad i=1,2, \cdots, N
\]</span></p>
<p>可以进一步可以变为求最小值优化</p>
<p><span class="math display">\[
\min _{w, b} \frac{1}{2}\|w\|^{2}
\]</span></p>
<p><span class="math display">\[
\text { s.t. } \quad y_{i}\left(w \cdot x_{i}+b\right)-1 \geqslant 0,
\quad i=1,2, \cdots, N
\]</span></p>
<h3 id="软间隔">1.3 软间隔</h3>
<p>实际中训练数据的不等式约束并不能都成立。并不能满足硬间隔，这就需
要修改硬间隔最大化，使其成为软间隔最大化。</p>
<p>为了解决这个问题，可以对每个样本点<span
class="math inline">\((x_i,y_i)\)</span>引进一个松弛变量<span
class="math inline">\(\xi_{\mathrm{i}} \geq
0\)</span>，使函数间隔加上松弛变量大于等于1。这样，约束条件变为</p>
<p><span class="math display">\[
y_{i}\left(w \cdot x_{i}+b\right) \geqslant 1-\xi_{i}
\]</span></p>
<h2 id="对偶算法">2.对偶算法</h2>
<h3 id="对偶关系证明">2.1 对偶关系证明</h3>
<p>使用拉格朗日乘子法引入对偶算法，注意这里要用小于0的约束条件</p>
<p><span class="math display">\[
L(w, b, \lambda)=\frac{1}{2}\|w\|^{2}+\sum_{i=1}^{N} \lambda_{i}
(1-y_{i}\left(w \cdot x_{i}+b\right))
\]</span></p>
<p>其中<span
class="math inline">\(\lambda\)</span>是拉格朗日乘子，要求大于等于0</p>
<p>原问题就转化为</p>
<p><span class="math display">\[
\max _{\lambda} \min _{w, b}  L(w, b, \lambda)
\]</span></p>
<p><span class="math display">\[
\text { s.t. } \lambda_{i} \geqslant 0
\]</span></p>
<p>这里解释一下取极大极小值的意义，。先将<span
class="math inline">\(\frac{1}{2}\|w\|^{2}\)</span>记为<span
class="math inline">\(f(w)\)</span>,后一项记为<span
class="math inline">\(\lambda g(w,b)\)</span> <span
class="math display">\[
\begin{align}
\max _{\lambda}\min _{w, b}  L(w, b, \lambda) &amp;=
\max_{\lambda}\min_{w, b}  f(w)+ \max_{\lambda}\min_{w, b} \lambda
g(w,b)\nonumber \\
&amp;= \min_{w} f(w) +  \max_{\lambda}\min_{w, b} \lambda g(w,b)
\nonumber
\end{align}
\]</span></p>
<p>因为<span class="math inline">\(y_{i}\left(w \cdot
x_{i}+b\right)\geqslant 1\)</span>，所以<span
class="math inline">\(g(w,b)\)</span>小于等于0，上式后一项的最大值就是0，即</p>
<p><span class="math display">\[
\max _{\lambda}\min _{w, b}  L(w, b, \lambda) =
\min_{w}\frac{1}{2}\|w\|^{2}
\]</span></p>
<p>和原式等价。</p>
<p>有些视频和书上最大最小符号前后是换位的，在该问题下是等价的，因为有<span
class="math inline">\(g(w,b)\)</span>小于等于0，所以</p>
<p><span class="math display">\[
\max_{\lambda} L(w,b,\lambda) = f(w)
\]</span></p>
<p>所以有</p>
<p><span class="math display">\[
\min_{w,b} f(w) = \min_{w,b} \max_{\lambda} L(w,b,\lambda) = \max
_{\lambda}\min _{w, b} L(w, b, \lambda)
\]</span></p>
<h3 id="拉格朗日求解">2.2 拉格朗日求解</h3>
<p>将拉格朗日函数分别对<span class="math inline">\(w,b\)</span>求导</p>
<p><span class="math display">\[
\nabla_{w} L(w, b, \lambda)=w-\sum_{i=1}^{N} \lambda_{i} y_{i} x_{i}=0
\]</span></p>
<p><span class="math display">\[
\nabla_{b} L(w, b, \lambda)=\sum_{i=1}^{N} \lambda_{i} y_{i}=0
\]</span></p>
<p>所以有</p>
<p><span class="math display">\[
w=\sum_{i=1}^{N} \lambda_{i} y_{i} x_{i}
\]</span></p>
<p><span class="math display">\[
\sum_{i=1}^{N} \lambda_{i} y_{i}=0
\]</span></p>
<p>将上式回代<span class="math inline">\(L(w, b, \lambda)\)</span>得</p>
<p><span class="math display">\[
\begin{aligned}
L(w, b,  \lambda) &amp; =\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N}
\lambda_{i} \lambda_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)\\
&amp;-\sum_{i=1}^{N} \lambda_{i} y_{i}\left(\left(\sum_{j=1}^{N}
\lambda_{j} y_{j} x_{j}\right) \cdot x_{i}+b\right)+\sum_{i=1}^{N}
\lambda_{i} \\
&amp; =-\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \lambda_{i}
\lambda_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)+\sum_{i=1}^{N}
\lambda_{i}
\end{aligned}
\]</span></p>
<p>这就是<span class="math inline">\(\min _{w, b} L(w, b,
\lambda)\)</span>，接下来对它求极大值</p>
<p>即求负的极小值</p>
<p><span class="math display">\[
\min _{\lambda} \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \lambda_{i}
\lambda_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)+\sum_{i=1}^{N}
\lambda_{i}
\]</span></p>
<p><span class="math display">\[
\begin{array}{ll}
\text { s.t. } &amp; \sum_{i=1}^{N} \lambda_{i} y_{i}=0 \\
&amp; \lambda_{i} \geqslant 0, \quad i=1,2, \cdots, N
\end{array}
\]</span></p>
<!-- ## 3.线性支持向量机

## 4.非线性支持向量机

## 5.SMO -->
<h2 id="参考资料">参考资料</h2>
<p>[1] 《统计学习方法》 李航</p>
<p>[2] <a
href="https://www.cnblogs.com/mo-wang/p/4775548.html">【整理】深入理解拉格朗日乘子法（Lagrange
Multiplier) 和KKT条件</a></p>
<p>[3] <a
href="https://www.bilibili.com/video/BV1Hs411w7ci/?p=2&amp;spm_id_from=333.880.my_history.page.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">机器学习-白板推导系列(六)-支持向量机SVM（Support
Vector Machine）</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>统计学习</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习(1)--定义速查</title>
    <url>/2022/11/18/2022-11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(1)--%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>统计学习/机器学习基本名词解释</p>
<span id="more"></span>
<h2 id="人工智能artificial-intelligence-ai">人工智能(Artificial
Intelligence, AI)</h2>
<p>人工智能指拥有类似与人类的自主思考甚至学习的计算机程序或系统。可分为弱人工智能和强人工智能。</p>
<h2 id="统计学习statistical-learning">统计学习(Statistical
Learning)</h2>
<p>统计学习是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。也被称为统计机器学习(statistical
machine learning)。</p>
<p>统计学习是机器学习的数学基础。</p>
<h2 id="机器学习分类">机器学习分类</h2>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210192601.png"
alt="思维导图" />
<figcaption aria-hidden="true">思维导图</figcaption>
</figure>
<h2 id="机器学习流程">机器学习流程</h2>
<ol type="1">
<li>获取数据</li>
<li>数据洞见与可视化</li>
<li>数据清洗与预处理</li>
<li>模型选择与训练</li>
<li>调整模型</li>
<li>启动监控与维护系统</li>
</ol>
<h2 id="输入空间输出空间特征空间">输入空间、输出空间、特征空间</h2>
<p>输入与输出所有可能取值的集合分别称为输入空间（input
space）与输出空间（output space）。这里的空间通常属于欧式空间。</p>
<p>输入空间的具体输入是一个实例(instance)，通常使用特征向量(feature
vector)表示。特征向量所在的空间称为特征空间(feature space)。</p>
<p>输入变量与输出变量均为连续变量的预测问题称为回归问题；输出变量为有限个离散变量的预测问题称为分类问题；输入变量与输出变量均为变量序列的预测问题称为标注问题。</p>
<h2 id="符号表示">符号表示</h2>
<p>在习惯上将输入变量记作X，输出变量记作Y，输入输出变量的取值用小写字母x/y表示。向量通常为列向量</p>
<p>输入实例x的特征向量记作</p>
<p><span class="math display">\[
x=\left(x^{(1)}, x^{(2)}, \cdots, x^{(i)}, \cdots,
x^{(n)}\right)^{\mathrm{T}}
\]</span></p>
<p>其中<span class="math inline">\(x^{(i)}\)</span>表示<span
class="math inline">\(x\)</span>的<span
class="math inline">\(i\)</span>个特征，如果是下标<span
class="math inline">\(x_i\)</span>则表示这是第<span
class="math inline">\(i\)</span>个变量。</p>
<p>监督学习训练数据由输入(或特征向量)与输出对构成，通常表示为 <span
class="math display">\[
T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right),
\cdots,\left(x_{N}, y_{N}\right)\right\}
\]</span></p>
<h2 id="统计学习三要素">统计学习三要素</h2>
<p><strong>方法＝模型＋策略＋算法</strong></p>
<h3 id="模型">模型</h3>
<p>称由<strong>决策函数</strong>表示的模型为非概率模型，由<strong>条件概率</strong>表示的模型为概率模型。</p>
<p>所有模型构成的空间称为假设空间(hypothesis space)</p>
<h3 id="策略">策略</h3>
<p><strong>损失函数</strong>，使用损失函数(代价函数)度量模型一次预测的好坏
（loss function / cost function）</p>
<p>常用的损失函数有以下几种： 1. 0-1损失函数</p>
<p><span class="math display">\[
L(Y, f(X))=\left\{\begin{array}{ll}
1, &amp; Y \neq f(X) \\
0, &amp; Y=f(X)
\end{array}\right.
\]</span></p>
<ol start="2" type="1">
<li>平方损失函数</li>
</ol>
<p><span class="math display">\[
L(Y, f(X))=(Y-f(X))^{2}
\]</span></p>
<ol start="3" type="1">
<li>绝对损失函数</li>
</ol>
<p><span class="math display">\[
L(Y, f(X))=|Y-f(X)|
\]</span></p>
<ol start="4" type="1">
<li>对数损失函数/对数似然损失函数</li>
</ol>
<p><span class="math display">\[
L(Y, P(Y \mid X))=-\log P(Y \mid X)
\]</span></p>
<p>损失函数值越小，模型就越好。因此可以计算以下损失函数的数学期望</p>
<p><span class="math display">\[
R_{\exp }(f)=E_{P}[L(Y, f(X))]=\int_{xy} L(y, f(x)) P(x, y) \mathrm{d} x
\mathrm{~d} y
\]</span></p>
<p>其中<span class="math inline">\(P(x,y)\)</span>服从<span
class="math inline">\((X,Y)\)</span>的联合概率分布，<span
class="math inline">\(R_{\exp }(f)\)</span> 被称为风险函数（risk
function）或 期望损失（expected loss）或<strong>期望风险</strong>。</p>
<p>但由于联合分布未知，这里需要使用训练集的平均损失<span
class="math inline">\(R_{\text {emp
}}\)</span>来近似估计期望风险，公式如下</p>
<p><span class="math display">\[
R_{\text {emp }}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i},
f\left(x_{i}\right)\right)
\]</span></p>
<p>它被称为<strong>经验风险</strong></p>
<h3 id="算法">算法</h3>
<p>算法是指学习模型的<strong>具体计算方法</strong>，习可以利用已有的最优化算法，有时也需要开发独自的最优化算法。</p>
<h2
id="经验风险最小化empirical-risk-minimizationerm">经验风险最小化(empirical
risk minimization，ERM)</h2>
<p>当样本容量足够大时，经验风险最小化能保证有很好的学习效果，在现实中被广泛采用。公式为</p>
<p><span class="math display">\[
\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i},
f\left(x_{i}\right)\right)
\]</span></p>
<p>其中<span class="math inline">\(\mathcal{F}\)</span>为假设空间</p>
<h2
id="结构风险最小化structural-risk-minimizationsrm">结构风险最小化(structural
risk minimization，SRM)</h2>
<p>经验风险最小化的准确度取决于样本，为了防止过拟合，提出了结构风险最小化，结构风险最小化等价于正则化（regularization），定义为</p>
<p><span class="math display">\[
R_{\mathrm{sm}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i},
f\left(x_{i}\right)\right)+\lambda J(f)
\]</span></p>
<p>其中<span
class="math inline">\(J(f)为模型的复杂度\)</span>$是系数通常大于0</p>
<h2 id="模型的训练与评估">模型的训练与评估</h2>
<h3 id="训练误差与测试误差">训练误差与测试误差</h3>
<p>数据集通常分为训练集和测试集，在选定损失函数后，训练误差和测试误差成为学习方法评估的标准。</p>
<p>训练误差的大小，对判断给定的问题是不是一个容易学习的问题是有意义的，但本质上不重要。测试误差反映了学习方法对未知的测试数据集的预测能力，是学习中的重要概念。显然，给定两种学习方法，测试误差小的方法具有更好的预测能力，是更有效的方法。通常将学习方法对未知数据的预测能力称为泛化能力（generalization
ability）</p>
<h3 id="过拟合">过拟合</h3>
<p>如果一味追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高。这种现象称为过拟合（over-fitting）。过拟合是指学习时选择的模型所包含的参数过多，以致于出现这一模型对已知数据预测得很好，但对未知数据预测得很差的现象。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210192722.png"
alt="训练误差与测试误差" />
<figcaption aria-hidden="true">训练误差与测试误差</figcaption>
</figure>
<h3 id="正则化">正则化</h3>
<p>为对抗过拟合的情况，一个典型的方法是引入正则化（regularization），正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大。一般形式如下</p>
<p><span class="math display">\[
\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i},
f\left(x_{i}\right)\right)+\lambda J(f)
\]</span></p>
<p>其中第一项是经验风险，第二项是正则化项，<span
class="math inline">\(\lambda\)</span>是两者关系系数，其值大于0</p>
<p>通常会使用2范数来作为正则项</p>
<p><span class="math display">\[
L(w)=\frac{1}{N} \sum_{i=1}^{N}\left(f\left(x_{i} ;
w\right)-y_{i}\right)^{2}+\frac{\lambda}{2}\|w\|^{2}
\]</span></p>
<p>其中<span class="math inline">\(w\)</span>是特征向量，<span
class="math inline">\(\|w\|^2\)</span>是向量<span
class="math inline">\(w\)</span>的2范数</p>
<h3 id="交叉验证">交叉验证</h3>
<p>如果给定的样本数据充足，进行模型选择的一种简单方法是随机地将数据集切分成三部分，分别为训练集（training
set）、验证集（validation set）和测试集（test set）。</p>
<p>但是，在许多实际应用中数据是不充足的。为了选择好的模型，可以采用交叉验证方法。可以重复多少使用数据。</p>
<ol type="1">
<li><p>简单交叉验证
随机将数据分为训练集(通常为70%)和测试集(通常为30%)。</p></li>
<li><p>S折交叉验证（S-fold cross validation）
首先随机地将已给数据切分为S个互不相交的大小相同的子集；然后利用S-1个子集的数据训练模型，利用余下的子集测试模型；将这一过程对可能的S种选择重复进行；最后选出S次评测中平均测试误差最小的模型。</p></li>
<li><p>留一交叉验证（leave-one-out cross validation）
将S折的S取为N，这里N是数据集的总容量。</p></li>
</ol>
<h2 id="生成模型与判别模型">生成模型与判别模型</h2>
<ol type="1">
<li>生成模型</li>
</ol>
<p>生成方法（generative
approach）由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型：</p>
<p><span class="math display">\[
P(Y \mid X)=\frac{P(X, Y)}{P(X)}
\]</span></p>
<p>模型表示了给定输入X产生输出Y的生成关系。典型的生成模型有：朴素贝叶斯法和隐马尔可夫模型</p>
<ol start="2" type="1">
<li>判别模型</li>
</ol>
<p>判别方法（discriminative
approach）直接学习决策函数f(X)或者条件概率分布P(Y|X)作为预测的模型，即判别模型。</p>
<p>典型的判别模型包括：k近邻法、感知机、决策树、逻辑斯谛回归模型、最大熵模型、支持向量机。</p>
<h2 id="问题分类">问题分类</h2>
<h3 id="分类问题">分类问题</h3>
<p>算法从数据中学习一个分类模型或分类决策函数，称为分类器（classifier）。分类器对新的输入进行输出的预测（prediction），称为分类（classification）。可能的输出称为类（class）。</p>
<p>评价分类器性能的指标一般是分类准确率（accuracy）也就是损失函数为0-1损失函数时测试集上的准确率。</p>
<p>分类最常见的是二分问题，当然其他分类其实也可以归为多个二分问题。对于二类分类问题常用的评价指标是精确率（precision）与召回率（recall）。将关注的类记为<strong>正类</strong>，其他类为<strong>负类</strong>，根据模型判别的对错可以分为四种情况，将他们出现的总是记为如下符号</p>
<p>TP——将正类预测为正类数； FN——将正类预测为负类数；
FP——将负类预测为正类数； TN——将负类预测为负类数。</p>
<p><strong>精准率</strong>的定义为</p>
<p><span class="math display">\[
P=\frac{T P}{T P+F P}
\]</span></p>
<p><strong>召回率</strong>的定义为</p>
<p><span class="math display">\[
R=\frac{T P}{T P+F N}
\]</span></p>
<p><strong><span
class="math inline">\(F_1\)</span>值</strong>是，精准率和召回率的调和均值</p>
<p><span class="math display">\[
\frac{2}{F_1}=\frac{1}{P}+\frac{1}{R}
\]</span></p>
<p><span class="math display">\[
F_1=\frac{2 T P}{2 T P+F P+F N}
\]</span></p>
<p><strong>混淆矩阵</strong>（Confusion
Matrix），又称为可能性矩阵或错误矩阵。是分类结果的一个可视化表现。形如</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210192755.png"
alt="混淆矩阵" />
<figcaption aria-hidden="true">混淆矩阵</figcaption>
</figure>
<h3 id="标注问题">标注问题</h3>
<p>标注（tagging）可以认为是分类问题的一个推广，输入是一组序列，输出也是一组序列。</p>
<h3 id="回归问题">回归问题</h3>
<p>回归（regression）用于预测输入变量（自变量）和输出变量（因变量）之间的关系，特别是当输入变量的值发生变化时，输出变量的值随之发生的变化。</p>
<p>回归学习最常用的损失函数是平方损失函数，在此情况下，回归问题可以由著名的最小二乘法（least
squares）求解。</p>
<h2 id="梯度下降法">梯度下降法</h2>
<p>梯度下降法（Gradient
descent）是迭代法的一种，利用求偏导的方法更新参数，实现找到极值。公式如下</p>
<p><span class="math display">\[
w_{i+1}=w_{i}-\alpha * \frac{d L}{d w_{i}}
\]</span></p>
<p>其中<span
class="math inline">\(\alpha\)</span>是学习率，其值影响迭代的速度，过大可能导致不收敛，过小收敛速度慢，且可能会陷入局部最优解。</p>
<p>批量梯度下降（Batch Gradient
Descent，BGD）每一次迭代会对所有样本进行计算，具有全局性，但计算量大</p>
<p>随机梯度下降（Stochastic Gradient
Descent，SGD）随机梯度下降是每次迭代使用一个样本来对参数进行更新，速度快但准确度可能会下降</p>
<p>小批量梯度下降（Mini-Batch Gradient Descent,
MBGD）中和上述两者特性</p>
<h2 id="感知机">感知机</h2>
<p>感知机（perceptron）是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，其通过一个超平面分离，输出取+1和–1二值。</p>
<p>单个感知机不能处理异或问题，多个感知机可以构成神经网络。</p>
<h2 id="支持向量机">支持向量机</h2>
<p>支持向量机的学习的目标也是在特征空间中找到一个分离超平面，能将实例分到不同的类。不同与感知机的解有无穷多个，线性可分支持向量机利用间隔最大化求最优分离超平面，解是唯一的。</p>
<p>支持向量机可以通过变换处理非线性分类问题。</p>
<h2 id="k近邻算法">k近邻算法</h2>
<p>k近邻法（k-nearest neighbor，k-NN）是一种基本分类与回归方法。</p>
<p>k近邻法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。</p>
<p>具体对于新的实例x，在训练集中找到与之相邻的k个实例，这k个实例的多数属于哪一类，就把这个实例分到哪一类中。当k为1时，称为最近邻算法。</p>
<h2 id="k-mean">k-mean</h2>
<p>k-means是一种聚类算法，是无监督学习算法。它将训练数据分为k组，每一组是一个簇，随机选择k个实例作为初始的聚类中心点，对于每一个实例，计算它和这k个聚类中心的距离，然后把它分配到与它距离最近的聚类中心所在的簇中去；计算每个簇中所有实例的平均值，作为新的聚类中心点，以此往复，直至聚类中心点不再发生明显变化。</p>
<h2 id="朴素贝叶斯">朴素贝叶斯</h2>
<p>朴素贝叶斯对实际问题进行了简化假设，利用概率最大这一符合人脑对事物的判断的方法实现对输入实例的分类。</p>
<h2 id="决策树">决策树</h2>
<p>分类决策树从根节点开始对实例的某个特征进行测试判别，然后将实例分配到对应节点，反复递归最终实现实例的全部分类。</p>
<p>决策树的特性决定了它会倾向于多分类，为此需要使用剪枝或修改判别依据来优化模型。</p>
<h2 id="逻辑斯谛回归">逻辑斯谛回归</h2>
<p>逻辑斯谛回归模型利用了逻辑斯谛方程的对数特性，将特征参数映射到[0，1]之间，将问题转换为概率预测，从而实现判别。</p>
<h2 id="最大熵">最大熵</h2>
<p>最大熵原理是概率模型学习的一个准则。其观点认为熵最大的模型就是最好的模型。</p>
<!-- ## 提升


## EM算法


## 隐马尔可夫模型


## 条件随机场 -->
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>统计学习</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习(2)--感知机</title>
    <url>/2022/11/23/2022-11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(2)--%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>感知机</p>
<span id="more"></span>
<h2 id="感知机的定义">1.感知机的定义</h2>
<p>对于一个输入空间，如果存在一个超平面将实例分为正负两类，那么可以认为输入空间的输出空间可以通过如下函数实现。</p>
<p><span class="math display">\[
f(x)=\operatorname{sign}(w^T \cdot x+b)
\]</span></p>
<p>该模型被称为感知机模型，其中<span
class="math inline">\(w^T\)</span>和<span
class="math inline">\(b\)</span>是感知机模型参数，线性方程</p>
<p><span class="math display">\[
w^T \cdot x+b
\]</span></p>
<p>是在特征空间中的一个超平面，其中<span
class="math inline">\(w\)</span>是超平面的法向量，b是超平面的截距。</p>
<p><span
class="math inline">\(\operatorname{sign}\)</span>是符号函数</p>
<p><span class="math display">\[
\operatorname{sign}(x)=\left\{\begin{array}{ll}
+1, &amp; x \geqslant 0 \\
-1, &amp; x&lt;0
\end{array}\right.
\]</span></p>
<h2 id="感知机学习策略">2.感知机学习策略</h2>
<h3 id="损失函数">2.1 损失函数</h3>
<p>感知机损失函数的一个自然选择是误分类点的总数，但这样损失函数不是参数<span
class="math inline">\(w\)</span>、<span
class="math inline">\(b\)</span>连续可导函数，不容易优化。</p>
<p>另一个选择是点到超平面S的总距离。</p>
<p>记空间中点为<span class="math inline">\(X^{(i)}\)</span>，超平面为
<span class="math inline">\(w^T \cdot X+b\)</span>
，空间中的任意一点到平面的距离 =
该点到平面任意一点的向量在平面的法向量上的投影。</p>
<p><span class="math display">\[
\begin{array}{l}
D=\left|\frac{w}{\|w\|_{2}} \cdot\left(X^{(i)}-X^{(0)}\right)\right| \\
=\left|\frac{1}{\|w\|_{2}} \cdot\left(w^{T} \cdot X^{(i)}-w^{T} \cdot
X^{(0)}\right)\right| \\
=\left|\frac{1}{\|w\|_{2}} \cdot\left(w^{T} \cdot
X^{(i)}+b\right)\right|
\end{array}
\]</span></p>
<p>其中<span class="math inline">\(X^{(0)}\)</span>是超平面上的点。</p>
<p>对于误分类数据<span class="math inline">\(\left(x_{i},
y_{i}\right)\)</span>来说，</p>
<p><span class="math display">\[
-y_{i}\left(w^T \cdot x_{i}+b\right)&gt;0
\]</span></p>
<p>假设误分类点集合为<span
class="math inline">\(M\)</span>,那么所有误分类点到超平面的总距离为</p>
<p><span class="math display">\[
-\frac{1}{\|w\|} \sum_{x_{i} \in M} y_{i}\left(w^T \cdot x_{i}+b\right)
\]</span></p>
<p>不考虑常数<span
class="math inline">\(\frac{1}{\|w\|}\)</span>,即可得到感知机学习的损失函数。这里省略转置，下同。</p>
<p><span class="math display">\[
L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdot x_{i}+b\right)
\]</span></p>
<p>该损失函数就是感知机的经验风险函数。</p>
<h3 id="随机梯度下降">2.2 随机梯度下降</h3>
<p>对于感知机模型来说最优化方法是随机梯度下降法，损失函数如下</p>
<p><span class="math display">\[
\min _{w, b} L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdot
x_{i}+b\right)
\]</span></p>
<p>梯度计算如下</p>
<p><span class="math display">\[
\nabla_{w} L(w, b)=-\sum_{x_{j} \in M} y_{i} x_{i} \\
\]</span></p>
<p><span class="math display">\[
\nabla_{b} L(w, b)=-\sum_{x_{i} \in M} y_{i}
\]</span></p>
<p>为此选取更新策略为</p>
<p><span class="math display">\[
\begin{array}{c}
w \leftarrow w+\eta y_{i} x_{i} \\
b \leftarrow b+\eta y_{i}
\end{array}
\]</span></p>
<h2 id="收敛性证明">3.收敛性证明</h2>
<p>将超平面简记为<span
class="math inline">\(\hat{w}\cdot\hat{x}\)</span></p>
<p>设训练集线性可分，则存在一个超平面<span
class="math inline">\(\hat{w}_{opt}\cdot\hat{x}\)</span>使得训练集完全正确分开，令<span
class="math inline">\(\|\hat{w}_{opt}\|=1\)</span>, 那么对有限的<span
class="math inline">\(i=1,2,...,N\)</span>均有</p>
<p><span class="math display">\[
y_{i}\left(\hat{w}_{\text {opt }} \cdot
\hat{x}_{i}\right)=y_{i}\left(w_{\text {opt }} \cdot x_{i}+b_{\text {opt
}}\right) \geqslant \gamma \tag{式1}
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
\gamma=\min _{i}\left\{y_{i}\left(w_{\mathrm{opt}} \cdot
x_{i}+b_{\mathrm{opt}}\right)\right\}
\]</span></p>
<p>根据更新公式</p>
<p><span class="math display">\[
\begin{array}{l}
w_{k} \leftarrow w_{k-1}+\eta y_{i} x_{i} \\
b_{k} \leftarrow b_{k-1}+\eta y_{i}
\end{array}
\]</span></p>
<p>可得</p>
<p><span class="math display">\[
\hat{w}_{k}=\hat{w}_{k-1}+\eta y_{i} \hat{x}_{i}
\]</span></p>
<p>假设初始值为<span class="math inline">\(\hat{w}_0 =
0\)</span>时,需要k次迭代达到最优值，有</p>
<p><span class="math display">\[
\begin{aligned}
\hat{w}_k\cdot\hat{w}_{\text{opt}} &amp; = (\hat{w}_{k-1}+\eta y_{i}
\hat{x}_{i})\cdot\hat{w}_{\text{opt}} \\
&amp; = \hat{w}_{k-1} \cdot \hat{w}_{\mathrm{opt}}+\eta y_{i}
\hat{w}_{\mathrm{opt}} \cdot \hat{x}_{i} \\
&amp; \geqslant  \hat{w}_{k-1} \cdot \hat{w}_{\mathrm{opt}}+ \eta \gamma
\\
&amp; \geqslant \cdots \\
&amp; \geqslant  \hat{w}_{0} \cdot \hat{w}_{\mathrm{opt}}+ k\eta \gamma
\\
&amp;  =  k\eta \gamma
\end{aligned}
\]</span></p>
<p>另外有</p>
<p><span class="math display">\[
\begin{aligned}
\left\|\hat{w}_{k}\right\|^{2} &amp;=\left\|\hat{w}_{k-1}\right\|^{2}+2
\eta y_{i} \hat{w}_{k-1} \cdot
\hat{x}_{i}+\eta^{2}\left\|\hat{x}_{i}\right\|^{2} \\
&amp;
\leqslant\left\|\hat{w}_{k-1}\right\|^{2}+\eta^{2}\left\|\hat{x}_{i}\right\|^{2}
\\
&amp; \leqslant\left\|\hat{w}_{k-1}\right\|^{2}+\eta^{2} R^{2} \\
&amp; \leqslant\left\|\hat{w}_{k-2}\right\|^{2}+2 \eta^{2} R^{2} \\
&amp; \leqslant \cdots \\
&amp; \leqslant k \eta^{2} R^{2}
\end{aligned}
\]</span></p>
<p>结合上述两式可得不等式</p>
<p><span class="math display">\[
k \eta \gamma \leqslant \hat{w}_{k} \cdot \hat{w}_{\mathrm{opt}}
\leqslant\left\|\hat{w}_{k}\right\|\left\|\hat{w}_{\mathrm{opt}}\right\|
\leqslant \sqrt{k} \eta R
\]</span></p>
<p>即对于k有</p>
<p><span class="math display">\[
k \leqslant\left(\frac{R}{\gamma}\right)^{2}
\]</span></p>
<p>该不等式的意义指出如果空间线性可分，迭代次数是有上界的。</p>
<h2 id="感知机学习算法的对偶形式">4.感知机学习算法的对偶形式</h2>
<p>在初始值为0的时候，对于N次迭代后参数<span
class="math inline">\(w\)</span>、<span
class="math inline">\(b\)</span>分别为</p>
<p><span class="math display">\[
w=\sum_{i=1}^{N} \alpha_{i} y_{i} x_{i} \tag{式2}
\]</span></p>
<p><span class="math display">\[
b=\sum_{i=1}^{N} \alpha_{i} y_{i}
\]</span></p>
<p>其中<span class="math inline">\(\alpha_{i} =\mathrm{n}_{\mathrm{i}}
\eta\)</span>，<span
class="math inline">\(\eta\)</span>为学习率，当<span
class="math inline">\(\eta=1\)</span>时，<span
class="math inline">\(\alpha_{i}\)</span>就代表了第<span
class="math inline">\(i\)</span>个实例由于误分而进行更新的次数。通常这个点会越接近分离超平面，因为这些点比较难被分类，它们对学习结果的影响最大。</p>
<p>使用(式2)代替损失函数的<span
class="math inline">\(w\)</span>值，可得对偶形式的训练条件为</p>
<p>当</p>
<p><span class="math display">\[
y_{i}\left(\sum_{j=1}^{N} \alpha_{j} y_{j} x_{j} \cdot x_{i}+b\right)
\leqslant 0\tag{式3}
\]</span></p>
<p>则</p>
<p><span class="math display">\[
\alpha_{i} \leftarrow \alpha_{i}+\eta
\]</span></p>
<p><span class="math display">\[
b \leftarrow b+\eta y_{i}
\]</span></p>
<p>由于(式3)中出现了大量内积形式的训练实例，可以预先将训练集的实例计算出来并储存为Gram矩阵</p>
<p>Gram矩阵的定义是</p>
<p><span class="math display">\[
G=A^{T} A=\left[\begin{array}{c}
\mathbf{a}_{1}^{T} \\
\mathbf{a}_{2}^{T} \\
\vdots \\
\mathbf{a}_{n}^{T}
\end{array}\right]\left[\begin{array}{llll}
\mathbf{a}_{1} &amp; \mathbf{a}_{2} &amp; \cdots &amp; \mathbf{a}_{n}
\end{array}\right]\\=\left[\begin{array}{cccc}
\mathbf{a}_{1}^{T} \mathbf{a}_{1} &amp; \mathbf{a}_{1}^{T}
\mathbf{a}_{2} &amp; \cdots &amp; \mathbf{a}_{1}^{T} \mathbf{a}_{n} \\
\mathbf{a}_{2}^{T} \mathbf{a}_{1} &amp; \mathbf{a}_{2}^{T}
\mathbf{a}_{2} &amp; \cdots &amp; \mathbf{a}_{2}^{T} \mathbf{a}_{n} \\
\mathbf{a}_{n}^{T} \mathbf{a}_{1} &amp; \mathbf{a}_{n}^{T}
\mathbf{a}_{2} &amp; \cdots &amp; \mathbf{a}_{n}^{T} \mathbf{a}_{n}
\end{array}\right]
\]</span></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>统计学习</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习(3)--k近邻和k均值</title>
    <url>/2022/11/25/2022-11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0(3)--k%E8%BF%91%E9%82%BB%E5%92%8Ck%E5%9D%87%E5%80%BC/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>k-NN和k-mean介绍</p>
<span id="more"></span>
<h2 id="k近邻算法">1.k近邻算法</h2>
<p>k近邻法（k-nearest neighbor，k-NN）是一种基本分类与回归方法。</p>
<p>k近邻法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。</p>
<p>具体对于新的实例x，在训练集中找到与之相邻的k个实例，这k个实例的多数属于哪一类，就把这个实例分到哪一类中。当k为1时，称为最近邻算法。</p>
<h3 id="k近邻模型">2.k近邻模型</h3>
<p>k近邻的算法非常简单，主要在于距离度量、k值和分类决策三者的选取。</p>
<ol type="1">
<li>度量距离
<ol type="1">
<li>欧氏距离</li>
<li>Lp距离（Lp distance）</li>
<li>Minkowski距离（Minkowski distance）</li>
</ol></li>
<li>k值
<ol type="1">
<li>选小会比较敏感</li>
<li>增大意味着整体模型变得简单</li>
</ol></li>
<li>分类决策
<ol type="1">
<li>多数表决等价于经验风险最小化</li>
</ol></li>
</ol>
<h3 id="kd树">3.kd树</h3>
<p>k近邻没有给出一个显式的表达式，而是每一次判定都是需要计算所有点到实例的距离，然后选取最近的k个点表决。所以当总量N越来越大时，算法会变得越来越慢。</p>
<p>为实现快速k近邻搜索，可以采用特殊结构存储，称为kd树。kd树是二叉树，表示对k维空间的一个划分（partition）。构造kd树相当于不断地用垂直于坐标轴的超平面将k维空间切分，构成一系列的k维超矩形区域。kd树的每个结点对应于一个k维超矩形区域。</p>
<h4 id="构造">3.1 构造</h4>
<p>输入：实例</p>
<p>输出：kd树</p>
<p>具体构造方式如下：</p>
<p>输入k维空间数据集：</p>
<p><span class="math display">\[
\mathrm{T}=\left\{\mathrm{x}_{1}, \mathrm{x}_{2}, \ldots,
\mathrm{x}_{\mathrm{N}}\right\}
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
x_{i}=\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots,
x_{i}^{(k)}\right)^{\mathrm{T}} , i  =1,2, \ldots, \mathrm{N}
\]</span></p>
<ol type="1">
<li>构造根节点</li>
</ol>
<p>选取<span
class="math inline">\(x^{(1)}\)</span>为坐标轴（这里也可以从方差最大的开始选），以所有数据的<span
class="math inline">\(x^{(1)}\)</span>特征的中位数作为切分点，生出深度为1的左右子节点。左小右大。</p>
<ol start="2" type="1">
<li>重复分割</li>
</ol>
<p>对深度为j的节点，选取<span
class="math inline">\(x^{(l)}\)</span>为切分坐标轴，<span
class="math inline">\(l=j(mod\enspace k)+1\)</span></p>
<p>生成j+1的左右子节点。</p>
<ol start="3" type="1">
<li>直到两个子区域没有实例</li>
</ol>
<h4 id="搜索">3.2 搜索</h4>
<p>输入：kd树，目标x</p>
<p>输出：x的最近邻点</p>
<ol type="1">
<li><p>从根节点出发递归地向下访问kd树。若目标点x当前维的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点。直
到子结点为叶结点为止。</p></li>
<li><p>记当前叶节点为最近点</p></li>
<li><p>检查另一子结点对应的区域是否与以目标点为球心、以目标点与“当前最近点”间的距离为半径的超球体相交。如果相交，移动到另一个子结点进行递归最近邻搜索；如果不相交，向上回退。如果存在更近点则更新最近点。</p></li>
</ol>
<p>(4)退回根节点后的最近点即为最近点。</p>
<h2 id="k-mean">4.k-mean</h2>
<p>k-means是一种聚类算法，是无监督学习算法。它将训练数据分为k组，每一组是一个簇，随机选择k个实例作为初始的聚类中心点，对于每一个实例，计算它和这k个聚类中心的距离，然后把它分配到与它距离最近的聚类中心所在的簇中去；计算每个簇中所有实例的平均值，作为新的聚类中心点，以此往复，直至聚类中心点不再发生明显变化。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>统计学习</tag>
      </tags>
  </entry>
  <entry>
    <title>pyinstaller使用（备忘录）</title>
    <url>/2022/05/28/2022-5/pyinstaller%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>pyinstaller编译python文件备忘录</p>
<span id="more"></span>
<h2 id="正文">正文</h2>
<p>在对应文件目录下输入（或给出绝对路径）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyinstaller -F &lt;文件名&gt;</span><br><span class="line">pyinstaller -w -F &lt;文件名&gt;</span><br><span class="line">pyinstaller -w -i curve.ico -F &lt;文件名&gt;</span><br></pre></td></tr></table></figure>
-F：仅仅生成一个文件，不暴露其他信息，启动较慢。</p>
<p>-D：生成一个文件夹，里面是多文件模式，启动快。</p>
<p>-w：窗口模式打包，不显示控制台。</p>
<p>-c：跟图标路径，作为应用icon。</p>
<p>ico是缩略图标格式，中间可以省略</p>
<p>源文件所在目录将生成 dist 和 build 两个文件夹。</p>
<p>其中，build 目录是 pyinstaller 存储临时文件的目录，可以安全删除。</p>
<p>最终的打包程序在 dist 内部的 dpython 目录中。</p>
<p><a href="http://www.bitbug.net/">在线制作ico</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python进行科研绘图入门--突出重点</title>
    <url>/2022/05/28/2022-5/python%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE_%E7%AA%81%E5%87%BA%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>python绘图技巧备忘录</p>
<p>使用Matplotlib，以代码呈现为主</p>
<p>标注，局部放大 <span id="more"></span></p>
<h2 id="图中文本标注">1. 图中文本标注</h2>
<h3 id="plt.text">1.1 plt.text()</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plt.text(x,y,&#x27;string&#x27;,ha = &#x27;center&#x27;,va = &#x27;bottom&#x27;,fontsize=7)#加标签</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x,y:表示坐标值上的值</span><br><span class="line"></span><br><span class="line">string:表示说明文字</span><br><span class="line"></span><br><span class="line">fontsize：字体大小</span><br><span class="line"></span><br><span class="line">va：垂直对齐方式（center top bottom baseline）</span><br><span class="line"></span><br><span class="line">ha：水平对齐方式（center right left）</span><br><span class="line"></span><br><span class="line">rotation 旋转角度</span><br><span class="line"></span><br><span class="line">wrap = True 自动换行</span><br></pre></td></tr></table></figure>
<h3 id="plt.annotate">1.2 plt.annotate()</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plt.annotate(&quot;(3, 6)&quot;,</span><br><span class="line">             xy=(3.3, 5.5),       # 在(3.3, 5.5)上做标注</span><br><span class="line">             fontsize=16,         # 设置字体大小为 16</span><br><span class="line">             xycoords=&#x27;data&#x27;)  # xycoords=&#x27;data&#x27; 是说基于数据的值来选位置</span><br></pre></td></tr></table></figure>
<h2 id="局部放大">2. 局部放大</h2>
<p>该函数代码转载自
https://blog.csdn.net/weixin_45826022/article/details/113486448
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def zone_and_linked(ax,axins,zone_left,zone_right,x,y,linked=&#x27;bottom&#x27;,</span><br><span class="line">                    x_ratio=0.05,y_ratio=0.05):</span><br><span class="line">    &quot;&quot;&quot;缩放内嵌图形，并且进行连线</span><br><span class="line">    ax:         调用plt.subplots返回的画布。例如： fig,ax = plt.subplots(1,1)</span><br><span class="line">    axins:      内嵌图的画布。 例如 axins = ax.inset_axes((0.4,0.1,0.4,0.3))</span><br><span class="line">    zone_left:  要放大区域的横坐标左端点</span><br><span class="line">    zone_right: 要放大区域的横坐标右端点</span><br><span class="line">    x:          X轴标签</span><br><span class="line">    y:          列表，所有y值</span><br><span class="line">    linked:     进行连线的位置，&#123;&#x27;bottom&#x27;,&#x27;top&#x27;,&#x27;left&#x27;,&#x27;right&#x27;&#125;</span><br><span class="line">    x_ratio:    X轴缩放比例</span><br><span class="line">    y_ratio:    Y轴缩放比例</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    xlim_left = x[zone_left]-(x[zone_right]-x[zone_left])*x_ratio</span><br><span class="line">    xlim_right = x[zone_right]+(x[zone_right]-x[zone_left])*x_ratio</span><br><span class="line"></span><br><span class="line">    y_data = np.hstack([yi[zone_left:zone_right] for yi in y])</span><br><span class="line">    ylim_bottom = np.min(y_data)-(np.max(y_data)-np.min(y_data))*y_ratio</span><br><span class="line">    ylim_top = np.max(y_data)+(np.max(y_data)-np.min(y_data))*y_ratio</span><br><span class="line"></span><br><span class="line">    axins.set_xlim(xlim_left, xlim_right)</span><br><span class="line">    axins.set_ylim(ylim_bottom, ylim_top)</span><br><span class="line"></span><br><span class="line">    ax.plot([xlim_left,xlim_right,xlim_right,xlim_left,xlim_left],</span><br><span class="line">            [ylim_bottom,ylim_bottom,ylim_top,ylim_top,ylim_bottom],&quot;black&quot;)</span><br><span class="line"></span><br><span class="line">    if linked == &#x27;bottom&#x27;:</span><br><span class="line">        xyA_1, xyB_1 = (xlim_left,ylim_top), (xlim_left,ylim_bottom)</span><br><span class="line">        xyA_2, xyB_2 = (xlim_right,ylim_top), (xlim_right,ylim_bottom)</span><br><span class="line">    elif  linked == &#x27;top&#x27;:</span><br><span class="line">        xyA_1, xyB_1 = (xlim_left,ylim_bottom), (xlim_left,ylim_top)</span><br><span class="line">        xyA_2, xyB_2 = (xlim_right,ylim_bottom), (xlim_right,ylim_top)</span><br><span class="line">    elif  linked == &#x27;left&#x27;:</span><br><span class="line">        xyA_1, xyB_1 = (xlim_right,ylim_top), (xlim_left,ylim_top)</span><br><span class="line">        xyA_2, xyB_2 = (xlim_right,ylim_bottom), (xlim_left,ylim_bottom)</span><br><span class="line">    elif  linked == &#x27;right&#x27;:</span><br><span class="line">        xyA_1, xyB_1 = (xlim_left,ylim_top), (xlim_right,ylim_top)</span><br><span class="line">        xyA_2, xyB_2 = (xlim_left,ylim_bottom), (xlim_right,ylim_bottom)</span><br><span class="line">        </span><br><span class="line">    con = ConnectionPatch(xyA=xyA_1,xyB=xyB_1,coordsA=&quot;data&quot;,</span><br><span class="line">                          coordsB=&quot;data&quot;,axesA=axins,axesB=ax)</span><br><span class="line">    axins.add_artist(con)</span><br><span class="line">    con = ConnectionPatch(xyA=xyA_2,xyB=xyB_2,coordsA=&quot;data&quot;,</span><br><span class="line">                          coordsB=&quot;data&quot;,axesA=axins,axesB=ax)</span><br><span class="line">    axins.add_artist(con)</span><br></pre></td></tr></table></figure> 测试 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from matplotlib.patches import  ConnectionPatch</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># 模拟数据</span><br><span class="line">x = np.linspace(0, 100, 1000)</span><br><span class="line">y = np.log(x)</span><br><span class="line"></span><br><span class="line">Perturbations = np.random.randint(-10,10,1000)</span><br><span class="line">y -= Perturbations/10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 绘制主图</span><br><span class="line">fig, ax = plt.subplots(1, 1)</span><br><span class="line">ax.plot(x,y,color=&quot;#2878b5&quot;, linewidth=1.0, linestyle=&quot;-&quot;,label = &#x27;log?&#x27;)</span><br><span class="line">ax.legend(loc=&quot;lower right&quot;)</span><br><span class="line"></span><br><span class="line"># 绘制缩放图</span><br><span class="line">axins = ax.inset_axes((0.4, 0.1, 0.4, 0.3))</span><br><span class="line"># （x0, y0, width, height）以父坐标系中的x0=0.2*x，y0=0.2*y为左下角起点，</span><br><span class="line"># 嵌入一个宽度为0.2*x，高度为0.3*y的子坐标系，其中x和y分别为父坐标系的坐标轴范围。</span><br><span class="line">axins.plot(x,y,color=&quot;#2878b5&quot;, linewidth=1.0, linestyle=&quot;-&quot;,alpha=0.7)</span><br><span class="line"></span><br><span class="line">zone_and_linked(ax, axins, 500, 650, x , [y], &#x27;bottom&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201010.png"
alt="output" />
<figcaption aria-hidden="true">output</figcaption>
</figure>
<h2 id="参考资料">参考资料</h2>
<p>[1] <a href="https://zhuanlan.zhihu.com/p/47588077">Python
绘图，我只用 Matplotlib（二）</a></p>
<p>[2] <a
href="https://blog.csdn.net/weixin_45826022/article/details/113486448">Python
绘制局部放大图</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>使用git管理GitHub（备忘录）</title>
    <url>/2022/05/28/2022-5/%E4%BD%BF%E7%94%A8git%E7%AE%A1%E7%90%86GitHub%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>库的建立,克隆,上传。</p>
<p>要事先安装好git和绑定ssh可以参考 <a
href="https://zhuanlan.zhihu.com/p/103391101">个人博客第3篇——绑定GitHub并提交文件</a></p>
<span id="more"></span>
<h2 id="命令速查">0.命令速查</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上传代码</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;name&quot;</span><br><span class="line">git push -u origin main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">初始化和关联</span><br><span class="line">git init</span><br><span class="line">git remote add origin ssh</span><br><span class="line"></span><br><span class="line">下载代码</span><br><span class="line">git clone https</span><br><span class="line"></span><br><span class="line">查询当前git的配置信息</span><br><span class="line">git config --global --list</span><br><span class="line"></span><br><span class="line">查询历史</span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line">查询状态</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">版本回退(本地管理)(硬重置)</span><br><span class="line">git log 查询版本id</span><br><span class="line">git reset --hard id</span><br><span class="line"></span><br><span class="line">创建分支</span><br><span class="line">git branch name</span><br><span class="line"></span><br><span class="line">切换分支</span><br><span class="line">git checkout name</span><br><span class="line"></span><br><span class="line">删除远程库</span><br><span class="line">git remote rm origin</span><br><span class="line"></span><br><span class="line">修改远程库别名</span><br><span class="line">git remote rename old_name new_name</span><br></pre></td></tr></table></figure>
<h2 id="建立github仓库">1.建立GitHub仓库</h2>
<p>点击左上角的new或者是加号点new repository。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201218.png"
alt="新建仓库" />
<figcaption aria-hidden="true">新建仓库</figcaption>
</figure>
<p>输入Repository name，勾选Add a README file</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201231.png"
alt="空仓库" />
<figcaption aria-hidden="true">空仓库</figcaption>
</figure>
<h2 id="克隆到本地">2.克隆到本地</h2>
<p>复制HTTPS/ssh</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201250.png"
alt="复制https" />
<figcaption aria-hidden="true">复制https</figcaption>
</figure>
<p>在本地文件夹右击，<code>Git Bash Here</code></p>
<p>输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https</span><br></pre></td></tr></table></figure> 其中https换成库对应的</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201304.png"
alt="克隆成功" />
<figcaption aria-hidden="true">克隆成功</figcaption>
</figure>
<h2 id="修改文件并上传">3.修改文件并上传</h2>
<p>注意不要在本地修改readme文件，我这里新建一个txt文件</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201329.png"
alt="新建文件" />
<figcaption aria-hidden="true">新建文件</figcaption>
</figure>
<p>在clone后的文件夹中右击，<code>Git Bash Here</code></p>
<p>在git窗口依次输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;name&quot;</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<p>第一行是将所有文件加入缓存区，注意add和.间有空格</p>
<p>第二行是为本次提交取名，引号内内容可以自行修改</p>
<p>第三行是推到GitHub仓库</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201343.png"
alt="推送成功" />
<figcaption aria-hidden="true">推送成功</figcaption>
</figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python+blender绘制原子结构示意图--以黑磷为例</title>
    <url>/2022/05/09/2022-5/%E4%BD%BF%E7%94%A8python+blender%E7%BB%98%E5%88%B6%E5%8E%9F%E5%AD%90%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>使用python+blender绘制原子结构示意图 --以黑磷为例</p>
<p>也可以代入其他原子结构 <span id="more"></span></p>
<h2 id="结果样式">1.结果样式</h2>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201410.png"
alt="黑磷原子结构示意图" />
<figcaption aria-hidden="true">黑磷原子结构示意图</figcaption>
</figure>
<h2 id="blender和bpy">2.blender和bpy</h2>
<p>Blender是一款免费开源三维图形图像软件，支持python脚本创作。其中bpy库就是用来对其进行操作的。</p>
<h2 id="绘图步骤">3.绘图步骤</h2>
<h3 id="准备工作">3.1 准备工作</h3>
<h4 id="安装blender">3.1.1 安装blender</h4>
<p>官网： <a
href="https://www.blender.org/">https://www.blender.org/</a></p>
<h4 id="计算参数">3.1.2 计算参数</h4>
<p>将需要绘制的atoms和bonds写成json文件</p>
<p>atom有4个元素：原子种类，颜色，半径，位置
bond有一个列表元素，列表中包含了bond的起始坐标和结束坐标。</p>
<p>其中前面的名字可以随意写。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201429.png"
alt="输入文件" />
<figcaption aria-hidden="true">输入文件</figcaption>
</figure>
<p>注：这里的数据不是黑磷的真实数据。</p>
<h3 id="绘制图像">3.2 绘制图像</h3>
<h4 id="执行脚本">3.2.1 执行脚本</h4>
<p>打开blender选择常规,可以看见下图画面。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201443.png"
alt="blender初始界面" />
<figcaption aria-hidden="true">blender初始界面</figcaption>
</figure>
<p>按a，再按del，删除所有元素。</p>
<p>在编辑-偏好设置里可以改成中文。</p>
<p>选择上面菜单栏中的Scripting进入脚本编辑工作区</p>
<p>在右边的区域新建文档将下面的代码复制粘贴进去 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import bpy</span><br><span class="line">import math</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def cylinder_between(x1, y1, z1, x2, y2, z2, r = 0.1):</span><br><span class="line"></span><br><span class="line">    dx = x2 - x1</span><br><span class="line">    dy = y2 - y1</span><br><span class="line">    dz = z2 - z1    </span><br><span class="line">    dist = math.sqrt(dx**2 + dy**2 + dz**2)</span><br><span class="line"> </span><br><span class="line">    bpy.ops.mesh.primitive_cylinder_add(</span><br><span class="line">        radius = r, </span><br><span class="line">        depth = dist,</span><br><span class="line">        location = (dx/2 + x1, dy/2 + y1, dz/2 + z1)   </span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    phi = math.atan2(dy, dx) </span><br><span class="line">    theta = math.acos(dz/dist) </span><br><span class="line"></span><br><span class="line">    bpy.context.object.rotation_euler[1] = theta </span><br><span class="line">    bpy.context.object.rotation_euler[2] = phi</span><br><span class="line">    </span><br><span class="line">    try:</span><br><span class="line">        bpy.context.object.active_material = bpy.data.materials[&#x27;bond&#x27;]</span><br><span class="line">    except:</span><br><span class="line">        bpy.data.materials.new(name=&#x27;bond&#x27;)</span><br><span class="line">        bpy.data.materials[&#x27;bond&#x27;].diffuse_color = [0.5,0.5,0.5,1]</span><br><span class="line">        bpy.data.materials[&#x27;bond&#x27;].specular_intensity = 0.2</span><br><span class="line">        bpy.context.object.active_material = bpy.data.materials[&#x27;bond&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def draw_molecule(molecule, center=(0, 0, 0), show_bonds=True, join=False,</span><br><span class="line">                  name=&#x27;molecule&#x27;):</span><br><span class="line"></span><br><span class="line">    collection = bpy.data.collections.new(&#x27;atom&#x27;)</span><br><span class="line">    bpy.context.scene.collection.children.link(collection)</span><br><span class="line">    # add atom primitive</span><br><span class="line">    bpy.ops.object.select_all(action=&#x27;DESELECT&#x27;)</span><br><span class="line">    bpy.ops.mesh.primitive_uv_sphere_add()</span><br><span class="line">    sphere = bpy.context.object</span><br><span class="line">    for key,atom in molecule[&#x27;atoms&#x27;].items():</span><br><span class="line">        if atom[&#x27;element&#x27;] not in bpy.data.materials:</span><br><span class="line">            key = atom[&#x27;element&#x27;]</span><br><span class="line">            bpy.data.materials.new(name=key)</span><br><span class="line">            bpy.data.materials[key].diffuse_color = atom[&#x27;color&#x27;] + [1]</span><br><span class="line">            bpy.data.materials[key].specular_intensity = 0.2</span><br><span class="line">            </span><br><span class="line">        loc = atom[&#x27;location&#x27;]</span><br><span class="line">        atom_sphere = sphere.copy()</span><br><span class="line">        atom_sphere.data = sphere.data.copy()</span><br><span class="line">        atom_sphere.location = [loc[0],loc[1],loc[2]]</span><br><span class="line">        atom_sphere.dimensions = [atom[&#x27;radius&#x27;]*2]*3</span><br><span class="line">        atom_sphere.active_material = bpy.data.materials[atom[&#x27;element&#x27;]]</span><br><span class="line">        collection.objects.link(atom_sphere)</span><br><span class="line">        </span><br><span class="line">    bpy.ops.object.select_all(action=&#x27;DESELECT&#x27;)</span><br><span class="line">    sphere.select_set(True)</span><br><span class="line">    bpy.ops.object.delete()</span><br><span class="line">    </span><br><span class="line">    for key,bond in molecule[&#x27;bonds&#x27;].items():</span><br><span class="line">        s = bond[0]</span><br><span class="line">        e = bond[1]</span><br><span class="line"></span><br><span class="line">        cylinder_between(s[0],s[1],s[2],e[0],e[1],e[2])</span><br><span class="line"></span><br><span class="line">               </span><br><span class="line">    if join:</span><br><span class="line">        bpy.ops.object.select_all(action=&#x27;SELECT&#x27;)</span><br><span class="line">        bpy.ops.object.join()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    r = 0.3 # radius</span><br><span class="line">    with open(r&#x27;E:\blenderproject\bl3\BP.json&#x27;) as in_file:</span><br><span class="line">        molecule = json.load(in_file)</span><br><span class="line"></span><br><span class="line">    draw_molecule(molecule)</span><br></pre></td></tr></table></figure>
代码参考参考资料[1,2]中的内容。</p>
<p>将BP.json的文件路径改为先前创建好的文件的路径。
一些其他需要修改的地方（bond的半径，颜色等）也可以自行修改。</p>
<p>点击运行或按alt+P执行程序。可以得到下图：</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201501.png"
alt="执行后界面" />
<figcaption aria-hidden="true">执行后界面</figcaption>
</figure>
<h4 id="扩展整列">3.2.2 扩展整列</h4>
<p>切换到layout，选择处于原点的原子。</p>
<p>按a全选，再按ctrl+j结合所有元素组合</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201533.png"
alt="组合后界面" />
<figcaption aria-hidden="true">组合后界面</figcaption>
</figure>
<p>点击修改器属性，添加阵列修改器，数量选择20，相对位移x改为0.886，其他为0。再添加一个，这个相对偏移上y改为0.886。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201519.png"
alt="修改阵列" />
<figcaption aria-hidden="true">修改阵列</figcaption>
</figure>
<p>最后shift+a添加面光、平面、相机。选取合适的角度进行渲染拍摄吧。参考资料[3]</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201600.png"
alt="准备拍摄" />
<figcaption aria-hidden="true">准备拍摄</figcaption>
</figure>
<h2 id="参考资料">参考资料</h2>
<p>[1] github 代码 <a
href="https://github.com/patrickfuller/blender-chemicals">blender-chemicals</a></p>
<p>[2] <a
href="https://www.cnblogs.com/dalanjing/p/13090708.html">Blender &amp;
Python 两点坐标建立圆柱</a></p>
<p>[3]【Blender科研绘图】<a
href="https://mp.weixin.qq.com/s/ZO2sTGvdaFZVVtLHBd9J2A">案例2-石墨烯</a></p>
]]></content>
      <categories>
        <category>科研项目</category>
        <category>黑磷的拉曼光谱</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>科研</tag>
        <tag>blender</tag>
      </tags>
  </entry>
  <entry>
    <title>使用紧束缚近似绘制单层黑磷能带图</title>
    <url>/2022/05/08/2022-5/%E4%BD%BF%E7%94%A8%E7%B4%A7%E6%9D%9F%E7%BC%9A%E8%BF%91%E4%BC%BC%E7%BB%98%E5%88%B6%E5%8D%95%E5%B1%82%E9%BB%91%E7%A3%B7%E8%83%BD%E5%B8%A6%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>紧束缚近似下使用二次量子化表示黑磷哈密顿量并利用
python编写代码绘制黑磷能带图。</p>
<span id="more"></span>
<h2 id="黑磷的结构">1.黑磷的结构</h2>
<p>黑磷作为一种新型的二维材料，不同于石墨烯的零带隙和过渡金属硫化物的低载流子迁移率。黑磷具备可以控制的直接带隙、高开关比及高载流子迁移率。因此黑磷烯也被广泛应用于光电、化学、生物等多个领域。</p>
<p>其具有与石墨烯类似的蜂窝型层状结构，不同之处在于黑磷的片层结构有着褶皱形态。黑磷原子结构见图1.</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201650.png"
alt="黑磷原子结构示意图" />
<figcaption aria-hidden="true">黑磷原子结构示意图</figcaption>
</figure>
<p>图片使用blender绘制，方法参考<a
href="https://splendidwave.github.io/2022/05/09/2022-5/%E4%BD%BF%E7%94%A8python+blender%E7%BB%98%E5%88%B6%E5%8E%9F%E5%AD%90%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE/#more">使用python+blender绘制原子结构示意图--以黑磷为例</a></p>
<p>黑磷的一个原胞中共有4个原子，标为ABCD，其中原子AB或者CD间的键长<span
class="math inline">\(a_1=2.22 \mathring{A}\)</span>
原子BC或AD间的键长为<span class="math inline">\(a_2=2.24
\mathring{A}\)</span></p>
<p>俯视图为六边形结构，如图2,图中另外标明了</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201712.png"
alt="单层黑磷俯视图" />
<figcaption aria-hidden="true">单层黑磷俯视图</figcaption>
</figure>
<p>其中键角<span class="math inline">\(\alpha_2=101.9^{\circ}\)</span>,
<span class="math inline">\(\alpha_1=96.5^{\circ}\)</span>, <span
class="math inline">\(\cos \beta=-\cos \alpha_2 / \cos
\frac{\alpha_1}{2}\)</span></p>
<p>数据来源参考资料[2]（参考资料中的<span class="math inline">\(\cos
\beta\)</span>这一项应为上文表达式，给个潦草的推导。）</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201732.png"
alt="由α Pav提供的推导草稿" />
<figcaption aria-hidden="true">由α Pav提供的推导草稿</figcaption>
</figure>
<h2 id="单层黑磷的哈密顿量">2.单层黑磷的哈密顿量</h2>
<p>黑磷的哈密顿量可以写作 <span class="math display">\[
H=\sum_{\langle i, j\rangle} t_{i j} c_{i}^{\dagger} c_{j} \tag{1}
\]</span></p>
<p>公式(1)的含义可以间参考资料[1]</p>
<p>这里采用5跳近似。</p>
<p>先以AB原子跃迁为例，考虑近邻和次近邻共四项。由图2中<span
class="math inline">\(t_1\)</span>,<span
class="math inline">\(t_3\)</span>标记所示。若以原子B为坐标原点，四个A的坐标分别为
<span class="math display">\[
\begin{align}
&amp;A_1 = (-a_1 \cos \frac{\alpha_1}{2},-a_1 \sin
\frac{\alpha_1}{2})\nonumber\\
&amp;A_2 = (-a_1 \cos \frac{\alpha_1}{2},a_1 \sin
\frac{\alpha_1}{2})\nonumber\\
&amp;A_3 = (a_1 \cos \frac{\alpha_1}{2}+2a_2 \cos \beta,a_1 \sin
\frac{\alpha_1}{2})\nonumber\\
&amp;A_4 = (a_1 \cos \frac{\alpha_1}{2}+2a_2 \cos \beta,-a_1 \sin
\frac{\alpha_1}{2})\nonumber\\
\end{align}
\]</span></p>
<p>由参考资料[1]中推得的结果有：</p>
<p><span class="math display">\[
t \sum_{n} a_{n}^\dagger b_{n} =t \sum_{k} a_{k}^\dagger b_{k} e^{i
k\vec{r}}\tag{2}
\]</span></p>
<p>其中<span
class="math inline">\(\vec{r}\)</span>是a到b的位置向量。所以对于<span
class="math inline">\(A_1\)</span>原子有</p>
<p><span class="math display">\[
\begin{align}
t_1 \sum A_1^\dagger B &amp;= t_1 \sum A_k^\dagger B_k e^{i [k_x(a_1
\cos \frac{\alpha_1}{2})+k_y(a_1 \sin \frac{\alpha_1}{2})]}\nonumber\\
&amp;=t_1 \sum A_k^\dagger B_k e^{ik_x a_1 \cos \frac{\alpha_1}{2}}
e^{ik_ya_1 \sin \frac{\alpha_1}{2}}\nonumber
\end{align}
\]</span></p>
<p>对于AB的两个最近邻项有</p>
<p><span class="math display">\[
\begin{align}
&amp;t_1 \sum (A_1^\dagger B +A_2^\dagger B) \nonumber\\
&amp; = t_1 \sum A_k^\dagger B_k [e^{ik_x a_1 \cos \frac{\alpha_1}{2}}
e^{ik_ya_1 \sin \frac{\alpha_1}{2}} + e^{ik_x a_1 \cos
\frac{\alpha_1}{2}}e^{-ik_ya_1 \sin \frac{\alpha_1}{2}}]\nonumber\\
&amp; =\sum A_k^\dagger B_k  \left \{   2t_1  \cos [k_ya_1\sin
(\alpha_1/2)]\times exp[ik_x a_1 \cos (\alpha _1/2)] \right \}\nonumber
\end{align}
\]</span></p>
<p>另外两个次近邻项有</p>
<p><span class="math display">\[
\begin{align}
&amp;t_1 \sum (A_3^\dagger B +A_4^\dagger B) \nonumber\\
&amp; =\sum A_k^\dagger B_k  \left \{2 t_3  \cos [k_ya_1\sin
(\alpha_1/2)]\times exp\{-ik_x [a_1 \cos (\alpha _1/2)+2a_2 \cos \beta ]
\} \right \}\nonumber
\end{align}
\]</span></p>
<p>上两者大括号内部分只和即为原子AB间的跃迁项，记为</p>
<p><span class="math display">\[
\begin{aligned}
t_{A B}(k)=&amp; 2 t_{1} \cos \left[k_{y} a_{1} \sin \left(\alpha_{1} /
2\right)\right] \times \exp \left[i k_{x} a_{1} \cos \left(\alpha_{1} /
2\right)\right] \\
&amp;+2 t_{3} \cos \left[k_{y} a_{1} \sin \left(\alpha_{1} /
2\right)\right] \times \exp \left\{-i k_{x}\left[a_{1} \cos
\left(\alpha_{1} / 2\right)+2 a_{2} \cos \beta\right]\right\}
\end{aligned}\tag{3}
\]</span></p>
<p>同理可得CB，DB项</p>
<p><span class="math display">\[
t_{C B}(k)=t_{2} \exp \left[-i k_{x} a_{2} \cos \beta\right]+t_{5} \exp
\left\{i k_{x}\left[2 a_{1} \cos \left(\alpha_{1} / 2\right)+a_{2} \cos
\beta\right]\right\}\tag{4}
\]</span> <span class="math display">\[
t_{D B}(k)=4 t_{4} \cos \left[k_{y} a_{1} \sin \left(\alpha_{1} /
2\right)\right] \cos \left\{k_{x}\left[a_{1} \cos \left(\alpha_{1} /
2\right)+a_{2} \cos \beta\right]\right\}\tag{5}
\]</span></p>
<p>有了式(2)(3)(4)后我们可以看出一些没有写出表达式的如AC间跳跃，是可以等价于已写出的表达式BD间的跳跃的。</p>
<p>为此以ABCD四个原子的电子波函数作为本征态，写出单层黑磷的哈密顿量</p>
<p><span class="math display">\[
H_{\text {m}}=\left(\begin{array}{ll}
H_{0} &amp; H_{1} \\
H_{1}  &amp; H_{0}
\end{array}\right)\tag{6}
\]</span></p>
<p>其中 <span class="math display">\[
\begin{array}{l}
H_{0}=\left(\begin{array}{cc}
0 &amp; t_{A B}(k) \\
t_{A B}^{*}(k) &amp; 0
\end{array}\right) \\
H_{1}=\left(\begin{array}{cc}
t_{D B}(k) &amp; t_{C B}(k) \\
t_{C B}^{*}(k) &amp; t_{D B}(k)
\end{array}\right)
\end{array}
\]</span></p>
<h2 id="使用python绘制能带图">2.使用python绘制能带图</h2>
<p>先给出一个参数文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># para.py</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># 黑磷晶格参数</span><br><span class="line">a1 = 2.22</span><br><span class="line">a2 = 2.24</span><br><span class="line">alpha1 = np.pi*96.5/180</span><br><span class="line">alpha2 = np.pi*101.9/180</span><br><span class="line">cos_beta = -np.cos(alpha2)/np.cos(alpha1/2)</span><br><span class="line"></span><br><span class="line">t1 = -1.220</span><br><span class="line">t2 = 3.665</span><br><span class="line">t3 = -0.205</span><br><span class="line">t4 = -0.105</span><br><span class="line">t5 = -0.055</span><br></pre></td></tr></table></figure></p>
<p>给出单层黑磷的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from para import *</span><br><span class="line">import cmath</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">def ham(kx,ky):</span><br><span class="line">    tab = 2*t1*np.cos(ky*a1*np.sin(alpha1/2))*cmath.exp(1j*kx*a1*np.cos(alpha1/2))+\</span><br><span class="line">        2*t3*np.cos(ky*a1*np.sin(alpha1/2))*cmath.exp(-1j*kx*(a1*np.cos(alpha1/2)+2*a2*cos_beta))</span><br><span class="line">    tcb = t2*cmath.exp(-1j*kx*a2*cos_beta) + t5*cmath.exp(1j*kx*(2*a1*np.cos(alpha1/2)+a2*cos_beta))</span><br><span class="line">    tdb = 4*t4*np.cos(ky*a1*np.sin(alpha1/2))*np.cos(kx*(a1*np.cos(alpha1/2)+a2*cos_beta))</span><br><span class="line"></span><br><span class="line">    h0 = np.zeros((2, 2), dtype=complex)</span><br><span class="line">    h1 = np.zeros((2, 2), dtype=complex)</span><br><span class="line">    hm = np.zeros((4, 4), dtype=complex)</span><br><span class="line"></span><br><span class="line">    h0[0,0] = 0</span><br><span class="line">    h0[1,1] = 0</span><br><span class="line">    h0[0,1] = tab</span><br><span class="line">    h0[1,0] = h0[0,1].conj()</span><br><span class="line"></span><br><span class="line">    h1[0,0] = tdb</span><br><span class="line">    h1[1,1] = tdb</span><br><span class="line">    h1[0,1] = tcb</span><br><span class="line">    h1[1,0] = h1[0,1].conj()</span><br><span class="line"></span><br><span class="line">    hm[:2,:2] = h0</span><br><span class="line">    hm[2:,2:] = h0</span><br><span class="line">    hm[:2,2:] = h1</span><br><span class="line">    hm[2:,:2] = h1</span><br><span class="line"></span><br><span class="line">    return hm </span><br><span class="line"></span><br><span class="line">def Draw_1d(kx, ky, eig, n_step):</span><br><span class="line">    &quot;&quot;&quot;画图函数&quot;&quot;&quot;</span><br><span class="line">    # 计算带隙</span><br><span class="line">    Conduction_bottom = np.min(np.where(eig &gt; 0, eig, np.inf))</span><br><span class="line">    Valence_top = np.max(np.where(eig &lt; 0, eig, -np.inf))</span><br><span class="line">    print(&quot;带隙为&quot;,Conduction_bottom-Valence_top)</span><br><span class="line">    dim = eig.shape[-1]</span><br><span class="line">    for i in range(dim):</span><br><span class="line">        plt.plot(kx, eig[0,:,i],&#x27;b-&#x27;)</span><br><span class="line">        plt.plot(ky, eig[1,:,i],&#x27;b-&#x27;)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">def Draw_2d(kx, ky, eig, n_step):</span><br><span class="line">    &quot;&quot;&quot;画图函数&quot;&quot;&quot;</span><br><span class="line">    fig = plt.axes(projection=&#x27;3d&#x27;)</span><br><span class="line">    x, y = np.meshgrid(kx, ky)</span><br><span class="line">    zero_plane = np.zeros((n_step, n_step))</span><br><span class="line">    # 画能带图</span><br><span class="line">    dim = eig.shape[-1]</span><br><span class="line">    for i in range(dim):</span><br><span class="line">        fig.plot_surface(x, y, eig[:, :, i], cmap=&#x27;spring&#x27;)</span><br><span class="line">    fig.plot_surface(x, y, zero_plane, cmap=&#x27;gray&#x27;)</span><br><span class="line">    plt.xlabel(&quot;Kx&quot;)</span><br><span class="line">    plt.ylabel(&quot;Ky&quot;)</span><br><span class="line">    fig.view_init(elev=2, azim=140)</span><br><span class="line">    # 计算带隙</span><br><span class="line">    Conduction_bottom = np.min(np.where(eig &gt; 0, eig, np.inf))</span><br><span class="line">    Valence_top = np.max(np.where(eig &lt; 0, eig, -np.inf))</span><br><span class="line">    print(&quot;带隙为&quot;,Conduction_bottom-Valence_top)</span><br><span class="line">    #plt.savefig(&quot;single_BP_2D_Band.jpg&quot;, dpi=600)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main2():</span><br><span class="line">    n_step = 100</span><br><span class="line">    kx_list = np.linspace(-np.pi, np.pi, n_step)</span><br><span class="line">    ky_list = np.linspace(-np.pi, np.pi, n_step)</span><br><span class="line">    two_dim_eig = np.zeros((n_step, n_step, 4))</span><br><span class="line"></span><br><span class="line">    for x in range(n_step):</span><br><span class="line">        kx = kx_list[x]</span><br><span class="line">        for y in range(n_step):</span><br><span class="line">            ky = ky_list[y]</span><br><span class="line">            h = ham(kx, ky)</span><br><span class="line">            eigenvalue, eigenvector = np.linalg.eigh(h)</span><br><span class="line">            two_dim_eig[x, y, :] = eigenvalue</span><br><span class="line">    Draw_2d(kx_list, ky_list, two_dim_eig, n_step)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main1():</span><br><span class="line">    n_step = 1000</span><br><span class="line">    kx_list = np.linspace(0, np.pi, n_step)</span><br><span class="line">    ky_list = np.linspace(-np.pi, 0, n_step)</span><br><span class="line">    two_eig = np.zeros((2 , n_step, 4))</span><br><span class="line"></span><br><span class="line">    ky = 0 </span><br><span class="line">    for x in range(n_step):</span><br><span class="line">        kx = kx_list[x]</span><br><span class="line">        h = ham(kx, ky)</span><br><span class="line">        eigenvalue, eigenvector = np.linalg.eigh(h)</span><br><span class="line">        two_eig[0, x, :] = eigenvalue</span><br><span class="line">    kx = 0</span><br><span class="line">    for y in range(n_step):</span><br><span class="line">        ky = ky_list[y]</span><br><span class="line">        h = ham(kx,ky)</span><br><span class="line">        eigenvalue, eigenvector = np.linalg.eigh(h)</span><br><span class="line">        two_eig[1, y, :] = eigenvalue</span><br><span class="line">    Draw_1d(kx_list, ky_list, two_eig, n_step)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main2()</span><br></pre></td></tr></table></figure>
<p>main1()是用来画一维的能带，main2()是画立体的。单层黑磷的能带结构图如下：</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201803.png"
alt="单层黑磷能带图" />
<figcaption aria-hidden="true">单层黑磷能带图</figcaption>
</figure>
<p>同时会输出带隙，在1.52左右，是符合之前的工作结果的。</p>
<h2 id="参考资料">4.参考资料</h2>
<p>[1] <a
href="https://splendidwave.github.io/2022/04/28/2022-4/%E8%83%BD%E5%B8%A6%E7%90%86%E8%AE%BA-%E7%B4%A7%E6%9D%9F%E7%BC%9A%E8%BF%91%E4%BC%BC%E4%B8%8E%E4%BA%8C%E6%AC%A1%E9%87%8F%E5%AD%90%E5%8C%96%E8%A1%A8%E7%A4%BA/#more">能带理论-紧束缚近似与二次量子化表示</a></p>
<p>[2] 罗雪琴.
外电场相关不同层数黑磷双光子吸收性质的理论研究[D].云南师范大学,2021.DOI:10.27459/d.cnki.gynfc.2021.001019.</p>
<p>[3] 关济寰大佬的博客<a
href="https://www.guanjihuan.com/archives/408">石墨烯哈密顿量与能带图（附Python代码）</a></p>
]]></content>
      <categories>
        <category>科研项目</category>
        <category>黑磷的拉曼光谱</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>固体物理</tag>
        <tag>能带</tag>
        <tag>黑磷</tag>
      </tags>
  </entry>
  <entry>
    <title>使用紧束缚近似绘制多层黑磷能带图</title>
    <url>/2022/05/13/2022-5/%E4%BD%BF%E7%94%A8%E7%B4%A7%E6%9D%9F%E7%BC%9A%E8%BF%91%E4%BC%BC%E7%BB%98%E5%88%B6%E5%A4%9A%E5%B1%82%E9%BB%91%E7%A3%B7%E8%83%BD%E5%B8%A6%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>紧束缚近似下使用二次量子化表示黑磷哈密顿量并利用
python编写代码绘制黑磷能带图。</p>
<span id="more"></span>
<h2 id="单层及基础原理">1.单层及基础原理</h2>
<p><a href="">使用紧束缚近似绘制单层黑磷能带图</a></p>
<h2 id="双层黑磷的能带结构">2.双层黑磷的能带结构</h2>
<p>这里双层是指最常见的AB型堆垛方式的双层，其正面图及俯视图如下图</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201834.png"
alt="双层黑磷原子结构图" />
<figcaption aria-hidden="true">双层黑磷原子结构图</figcaption>
</figure>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201847.png"
alt="双层黑磷俯视图" />
<figcaption aria-hidden="true">双层黑磷俯视图</figcaption>
</figure>
<p>下层的原子仍然标记为ABCD，上层的原子标记为A'B'C'D'</p>
<p>俯视图中给出了上下层间的跳跃项。其中只考虑上层中的蓝色原子A'B'跳跃到下层中的红色CD。橙色的点为B'原子，记为跳跃起点，蓝色箭头是跳跃到下一层的原子C，短的跳跃参数记为<span
class="math inline">\(t_1^\perp\)</span>，长的记为<span
class="math inline">\(t_4^\perp\)</span>。绿色数字是跳跃到下一层的原子D，短的记为<span
class="math inline">\(t_2^\perp\)</span>，长的记为<span
class="math inline">\(t_3^\perp\)</span>.</p>
<p>给出这两项的表达式</p>
<p><span class="math display">\[
\begin{aligned}
t_{B C}^{\prime}(k)=&amp; 2 t_{1}^{\perp} \cos \left[k_{y} a_{1} \sin
\left(\alpha_{1} / 2\right)\right] \times \exp \left[i k_{x} a_{2} \cos
\beta\right] \\
&amp;+2 t_{4}^{\perp} \cos \left[k_{y} a_{1} \sin \left(\alpha_{1} /
2\right)\right] \times \exp \left\{-i k_{x}\left[2 a_{1} \cos
\left(\alpha_{1} / 2\right)+a_{2} \cos \beta\right]\right\}
\end{aligned}\tag{1}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
t_{B D}^{\prime}(k)=&amp; 4 t_{3}^{\perp} \cos \left[k_{y} 2 a_{1} \sin
\left(\alpha_{1} / 2\right)\right] \times \cos \left\{k_{x}\left[a_{1}
\cos \left(\alpha_{1} / 2\right)+a_{2} \cos \beta\right]\right\} \\
&amp;+2 t_{2}^{\perp} \cos \left\{k_{x}\left[a_{1} \cos \left(\alpha_{1}
/ 2\right)+a_{2} \cos \beta \right] \right\}
\end{aligned}\tag{2}
\]</span></p>
<p>以8个原子的电子波函数为基底写出双层黑磷的哈密顿量如下</p>
<p><span class="math display">\[
H_{b i}=\left(\begin{array}{cc}
H &amp; H_{c} \\
H_{c}^{\dagger} &amp; H
\end{array}\right)\tag{3}
\]</span></p>
<p>其中H是单层黑磷的哈密顿量，</p>
<p><span class="math display">\[
H_{c}=\left(\begin{array}{cc}
0 &amp; 0 \\
H_{2} &amp; 0
\end{array}\right)\tag{4}
\]</span></p>
<p>上式中</p>
<p><span class="math display">\[
H_{2}=\left(\begin{array}{ll}
t_{B D}^{\prime}(k) &amp; {t_{B C}^{\prime}}^{*}(k) \\
t_{B C}^{\prime}(k)&amp; t_{B D}^{\prime}(k)
\end{array}\right)\tag{5}
\]</span></p>
<p>使用python编写程序,其实只是在上一个程序上稍加修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from para import *</span><br><span class="line">import cmath</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">def ham(kx,ky):</span><br><span class="line">    tab = 2*t1*np.cos(ky*a1*np.sin(alpha1/2))*cmath.exp(1j*kx*a1*np.cos(alpha1/2))+\</span><br><span class="line">        2*t3*np.cos(ky*a1*np.sin(alpha1/2))*cmath.exp(-1j*kx*(a1*np.cos(alpha1/2)+2*a2*cos_beta))</span><br><span class="line">    tcb = t2*cmath.exp(-1j*kx*a2*cos_beta) + t5*cmath.exp(1j*kx*(2*a1*np.cos(alpha1/2)+a2*cos_beta))</span><br><span class="line">    tdb = 4*t4*np.cos(ky*a1*np.sin(alpha1/2))*np.cos(kx*(a1*np.cos(alpha1/2)+a2*cos_beta))</span><br><span class="line"></span><br><span class="line">    tbc = 2*t1p*np.cos(ky*a1*np.sin(alpha1/2))*cmath.exp(1j*kx*a2*cos_beta) + 2*t4p*np.cos(ky*a1*np.sin(alpha1/2))*cmath.exp(-1j*kx*(2*a1*np.cos(alpha1/2)+a2*cos_beta))</span><br><span class="line">    tbd = 4*t3p*np.cos(ky*2*a1*np.sin(alpha1/2))*np.cos(kx*(a1*np.cos(alpha1/2)+a2*cos_beta)) + 2*t2p*np.cos(kx*(a1*np.cos(alpha1/2)+a2*cos_beta))</span><br><span class="line"></span><br><span class="line">    h0 = np.zeros((2, 2), dtype=complex)</span><br><span class="line">    h1 = np.zeros((2, 2), dtype=complex)</span><br><span class="line">    hm = np.zeros((4, 4), dtype=complex)</span><br><span class="line">    h2 = np.zeros((2, 2), dtype=complex)</span><br><span class="line">    hc = np.zeros((4, 4), dtype=complex)</span><br><span class="line">    hb = np.zeros((8, 8), dtype=complex)</span><br><span class="line"></span><br><span class="line">    h0[0,0] = 0</span><br><span class="line">    h0[1,1] = 0</span><br><span class="line">    h0[0,1] = tab</span><br><span class="line">    h0[1,0] = h0[0,1].conj()</span><br><span class="line"></span><br><span class="line">    h1[0,0] = tdb</span><br><span class="line">    h1[1,1] = tdb</span><br><span class="line">    h1[0,1] = tcb</span><br><span class="line">    h1[1,0] = h1[0,1].conj()</span><br><span class="line"></span><br><span class="line">    h2[0,0] = tbd</span><br><span class="line">    h2[1,1] = tbd</span><br><span class="line">    h2[1,0] = tbc</span><br><span class="line">    h2[0,1] = h2[1,0].conj()</span><br><span class="line"></span><br><span class="line">    hm[:2,:2] = h0</span><br><span class="line">    hm[2:,2:] = h0</span><br><span class="line">    hm[:2,2:] = h1</span><br><span class="line">    hm[2:,:2] = h1</span><br><span class="line"></span><br><span class="line">    hc[2:,:2] = h2</span><br><span class="line"></span><br><span class="line">    hb[:4,:4] = hm</span><br><span class="line">    hb[4:,4:] = hm</span><br><span class="line">    hb[:4,4:] = hc</span><br><span class="line">    hb[4:,:4] = hc.T.conj()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return hb</span><br><span class="line"></span><br><span class="line">def Draw_1d(kx, ky, eig, n_step):</span><br><span class="line">    &quot;&quot;&quot;画图函数&quot;&quot;&quot;</span><br><span class="line">    # 计算带隙</span><br><span class="line">    Conduction_bottom = np.min(np.where(eig &gt; 0, eig, np.inf))</span><br><span class="line">    Valence_top = np.max(np.where(eig &lt; 0, eig, -np.inf))</span><br><span class="line">    print(&quot;带隙为&quot;,Conduction_bottom-Valence_top)</span><br><span class="line">    dim = eig.shape[-1]</span><br><span class="line">    for i in range(dim):</span><br><span class="line">        plt.plot(kx, eig[0,:,i],&#x27;b-&#x27;)</span><br><span class="line">        plt.plot(ky, eig[1,:,i],&#x27;b-&#x27;)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">def Draw_2d(kx, ky, eig, n_step):</span><br><span class="line">    &quot;&quot;&quot;画图函数&quot;&quot;&quot;</span><br><span class="line">    fig = plt.axes(projection=&#x27;3d&#x27;)</span><br><span class="line">    x, y = np.meshgrid(kx, ky)</span><br><span class="line">    zero_plane = np.zeros((n_step, n_step))</span><br><span class="line">    # 画能带图</span><br><span class="line">    dim = eig.shape[-1]</span><br><span class="line">    for i in range(dim):</span><br><span class="line">        fig.plot_surface(x, y, eig[:, :, i], cmap=&#x27;spring&#x27;)</span><br><span class="line">    fig.plot_surface(x, y, zero_plane, cmap=&#x27;gray&#x27;)</span><br><span class="line">    plt.xlabel(&quot;Kx&quot;)</span><br><span class="line">    plt.ylabel(&quot;Ky&quot;)</span><br><span class="line">    fig.view_init(elev=2, azim=140)</span><br><span class="line">    # 计算带隙</span><br><span class="line">    Conduction_bottom = np.min(np.where(eig &gt; 0, eig, np.inf))</span><br><span class="line">    Valence_top = np.max(np.where(eig &lt; 0, eig, -np.inf))</span><br><span class="line">    print(&quot;带隙为&quot;,Conduction_bottom-Valence_top)</span><br><span class="line">    #plt.savefig(&quot;single_BP_2D_Band.jpg&quot;, dpi=600)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main2():</span><br><span class="line">    n_step = 100</span><br><span class="line">    kx_list = np.linspace(-np.pi, np.pi, n_step)</span><br><span class="line">    ky_list = np.linspace(-np.pi, np.pi, n_step)</span><br><span class="line">    h = ham(0,0)</span><br><span class="line">    size = len(h)</span><br><span class="line">    two_dim_eig = np.zeros((n_step, n_step, size))</span><br><span class="line"></span><br><span class="line">    for x in range(n_step):</span><br><span class="line">        kx = kx_list[x]</span><br><span class="line">        for y in range(n_step):</span><br><span class="line">            ky = ky_list[y]</span><br><span class="line">            h = ham(kx, ky)</span><br><span class="line">            eigenvalue, eigenvector = np.linalg.eigh(h)</span><br><span class="line">            two_dim_eig[x, y, :] = eigenvalue</span><br><span class="line">    Draw_2d(kx_list, ky_list, two_dim_eig, n_step)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main1():</span><br><span class="line">    n_step = 1000</span><br><span class="line">    kx_list = np.linspace(0, np.pi, n_step)</span><br><span class="line">    ky_list = np.linspace(-np.pi, 0, n_step)</span><br><span class="line">    h = ham(0,0)</span><br><span class="line">    size = len(h)</span><br><span class="line">    two_eig = np.zeros((2 , n_step, size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ky = 0 </span><br><span class="line">    for x in range(n_step):</span><br><span class="line">        kx = kx_list[x]</span><br><span class="line">        h = ham(kx, ky)</span><br><span class="line">        eigenvalue, eigenvector = np.linalg.eigh(h)</span><br><span class="line">        two_eig[0, x, :] = eigenvalue</span><br><span class="line">    kx = 0</span><br><span class="line">    for y in range(n_step):</span><br><span class="line">        ky = ky_list[y]</span><br><span class="line">        h = ham(kx,ky)</span><br><span class="line">        eigenvalue, eigenvector = np.linalg.eigh(h)</span><br><span class="line">        two_eig[1, y, :] = eigenvalue</span><br><span class="line">    Draw_1d(kx_list, ky_list, two_eig, n_step)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main1()</span><br></pre></td></tr></table></figure>
<h2 id="n层黑磷的能带结构">3.N层黑磷的能带结构</h2>
<p>因为仅考虑近邻项的跳跃，所以我们可以推广到N层AB型堆垛的黑磷的哈密顿量为：</p>
<p><span class="math display">\[
H_{N}=\left(\begin{array}{ccccc}
H &amp; H_{c} &amp; &amp; &amp; \\
H_{c}^{\dagger} &amp; H &amp; H_{c} &amp; &amp; \\
&amp; H_{c}^{\dagger} &amp; H &amp; H_{c} &amp; \\
&amp; &amp; &amp; \ddots &amp; \\
&amp; &amp; &amp; &amp; H_{c} \\
&amp; &amp; &amp; H_{c}^{\dagger} &amp; H
\end{array}\right)_{N \times N}
\]</span></p>
<p>代码也差不多，但因为紧束缚的参数是通过DFT计算出能带再拟合出来的，仍使用这些参数可能会使多层的数值偏离实际值。</p>
<h2 id="参考资料">4.参考资料</h2>
<p>[1] <a
href="https://splendidwave.github.io/2022/05/08/2022-5/%E4%BD%BF%E7%94%A8%E7%B4%A7%E6%9D%9F%E7%BC%9A%E8%BF%91%E4%BC%BC%E7%BB%98%E5%88%B6%E5%8D%95%E5%B1%82%E9%BB%91%E7%A3%B7%E8%83%BD%E5%B8%A6%E5%9B%BE/">使用紧束缚近似绘制单层黑磷能带图</a></p>
]]></content>
      <categories>
        <category>科研项目</category>
        <category>黑磷的拉曼光谱</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>固体物理</tag>
        <tag>能带</tag>
        <tag>黑磷</tag>
      </tags>
  </entry>
  <entry>
    <title>密度泛函理论-泛函</title>
    <url>/2022/05/27/2022-5/%E5%AF%86%E5%BA%A6%E6%B3%9B%E5%87%BD%E7%90%86%E8%AE%BA_%E6%B3%9B%E5%87%BD/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>泛函简介，从费马原理出发利用泛函介绍了光为什么沿直线传播，光的折射定律。</p>
<span id="more"></span>
<h2 id="什么是泛函">1.什么是泛函？</h2>
<p>如果一个函数的变量也是一个函数，则称为泛函。</p>
<p>泛函就是函数的函数。</p>
<h2 id="泛函有什么用">2.泛函有什么用？</h2>
<p>我们都知道微分是指函数(f(x))在某一点处（dx<span
class="math inline">\(\approx\)</span>无穷小）的变化量。</p>
<p>泛函的微分那就不能叫这么土的名字了，得换个有b格的名字，叫做<strong>变分</strong>，泛函的自变量也得换个名字叫<strong>宗量</strong></p>
<p>提到变分，肯定绕不开大名鼎鼎的<strong>变分法</strong>，变分法讲的最多的是最速降线的问题，但实际上伯努利的解法参考了光学中的费马原理。</p>
<p>费马原理说的是：过两个定点的光总走光程的一阶变分为零的路径。[2]</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201147.png"
alt="最速降线问题" />
<figcaption aria-hidden="true">最速降线问题</figcaption>
</figure>
<p>图来自参考资料[3]</p>
<p>假设在xy平面存在折射率为n(y)的介质（这里可以理解为有很多层不同的介质）光线从原点出发，会选择走那条路径？</p>
<p>我们都知道光程是折射率乘光线在介质中走过的路程，所以有光程S为： <span
class="math display">\[
\begin{aligned}
S &amp;=\int n(y) \sqrt{(d x)^{2}+(d y)^{2}} \\
&amp;=\int n(y) \sqrt{1+\left(\frac{d y}{d x}\right)^{2}} d x \\
&amp;=\int n(y) \sqrt{1+\left(y^{\prime}\right)^{2}} d x
\end{aligned}\tag{1}
\]</span></p>
<p>我们令 <span class="math display">\[
L\left(y, y^{\prime}\right) = n(y)
\sqrt{1+\left(y^{\prime}\right)^{2}}\tag{2}
\]</span></p>
<p>又因为是从A点积分到B点，光程可以表达为下述简洁的模式： <span
class="math display">\[
S = \int_{A}^{B} d x L\left(y, y^{\prime}\right)\tag{3}
\]</span></p>
<p>光经过的路线可以写作<span
class="math inline">\(y=f(x)\)</span>这样一个函数，可以看出光程S是以y为宗量的泛函，所以只要将光程的一阶变分写出来，根据费马原理它等于0，求解出<span
class="math inline">\(f(x)\)</span>就解完了。</p>
<p>所以一阶变分怎么写呢？我们知道变分是泛函的微分。微分是函数的微小变化，先看宗量如果发生了微小变化<span
class="math inline">\(\delta y(x)\)</span></p>
<p>那么 <span class="math display">\[
\delta L\left(y, y^{\prime}\right) = \frac{\partial L}{\partial y}
\delta y+\frac{\partial L}{\partial y^{\prime}} \delta y^{\prime}\tag{4}
\]</span></p>
<p>光程的变分为 <span class="math display">\[
\begin{aligned}
\delta S[y(x)] &amp;=\int_{A}^{B} d x \delta L\left(y, y^{\prime}\right)
\\
&amp;=\int_{A}^{B} d x\left[\frac{\partial L}{\partial y} \delta
y+\frac{\partial L}{\partial y^{\prime}}(\delta y)^{\prime}\right] \\
\end{aligned}\tag{5}
\]</span></p>
<p>上式第二项中可以写作<span class="math inline">\(\frac{\partial
L}{\partial y^\prime} \frac{\mathrm{d}(\delta y)}{\mathrm{d}
x}\)</span>对该项使用分部积分得</p>
<p><span class="math display">\[
\begin{aligned}
\int_{A}^{B} \frac{\partial L}{\partial y^{\prime}} \delta y^{\prime}
\mathrm{d} x &amp;=\int_{A}^{B} \frac{\partial L}{\partial y^{\prime}}
\mathrm{d}(\delta y) \\
&amp;=\left.\frac{\partial L}{\partial y^{\prime}} \delta y\right|_{A}
^{B}-\int_{A}^{B} \delta y \frac{\mathrm{d}}{\mathrm{d}
x}\left(\frac{\partial L}{\partial y^{\prime}}\right) \mathrm{d} x
\end{aligned}\tag{6}
\]</span></p>
<p>又因为断点固定所以有两段变分为零。即 <span class="math display">\[
\delta y(A)=\delta y(B)=0\tag{7}
\]</span></p>
<p>代入回式(5)有 <span class="math display">\[
\delta S[y(x)]=\int_{a}^{b} d x\left[\frac{\partial L}{\partial
y}-\frac{d}{d x}\left(\frac{\partial L}{\partial
y^{\prime}}\right)\right] \delta y \tag{8}
\]</span></p>
<p>要想让光程的变分为0，则有 <span class="math display">\[
\frac{\partial L}{\partial y}-\frac{d}{d x}\left(\frac{\partial
L}{\partial y^{\prime}}\right) = 0\tag{9}
\]</span></p>
<p>注意，我这里始终没有把L的具体函数代入，也就是说这个方程是一个通用的方程。实际上这就是著名的<strong>欧拉-拉格朗日方程</strong>。费马原理其实是物理中的最小作用量原理。利用变分法我们就可以在物理学世界嘎嘎乱杀。比如说</p>
<h3 id="光在均匀介质中走的是直线">2.1 光在均匀介质中走的是直线</h3>
<p>我们有<span class="math inline">\(n(y)=n\)</span>，<span
class="math inline">\(L=n\sqrt{1+\left(y^{\prime}\right)^{2}}\)</span>可得</p>
<p><span class="math display">\[
\frac{\partial L}{\partial y}=0, \quad \frac{\partial L}{\partial
y^{\prime}}=\frac{ny^{\prime}}{\sqrt{1+y^{\prime 2}}}\tag{10}
\]</span></p>
<p>代回公式(9)</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d}
x}\left(\frac{ny^{\prime}}{\sqrt{1+y^{\prime 2}}}\right)=0\tag{11}
\]</span></p>
<p>显而易见解为<span class="math inline">\(y(x) = k
x+c\)</span>是一条直线，</p>
<h3 id="光的折射定律">2.2 光的折射定律</h3>
<p>光为什么会发生折射，我们现在知道了光在均匀介质中沿直线传播，假设光平行于xy平面入射介质在<span
class="math inline">\(y=0\)</span>处交接，设光线在x轴的交点为<span
class="math inline">\((x,0)\)</span>，则点AB间的光程可以写作。</p>
<p><span class="math display">\[
\begin{aligned}
S &amp; = n_{1} \sqrt{y_{1}^{2}+(x-x_1)^{2}}\\
&amp; + n_{2} \sqrt{y_{2}^{2}+(x_2-x)^{2}}
\end{aligned}\tag{12}
\]</span></p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201127.png"
alt="折射" />
<figcaption aria-hidden="true">折射</figcaption>
</figure>
<p>光程的变分为零即为<span class="math inline">\(\frac{dS}{dx} =
0\)</span></p>
<p><span class="math display">\[
\begin{aligned}
\frac{d S}{d x} &amp; = n_{1}
\frac{x-x_{1}}{\sqrt{y_{1}^{2}+\left(x-x_{1}\right)^{2}}}\\
&amp;- n_{2} \frac{x_{2}-x}{\sqrt{y_{2}^{2}+\left(x_{2}-x\right)^{2}}}
\\
&amp; = 0
\end{aligned}\tag{13}
\]</span></p>
<p>所以有 <span class="math display">\[
n_{1} \sin i_{1}-n_{2} \sin i_{2}=0\tag{14}
\]</span></p>
<h2 id="参考资料">参考资料</h2>
<p>[1] 密度泛函理论 胡英 刘洪来</p>
<p>[2] <a
href="https://www.guokr.com/article/59377/">献给业余数学之王：澄清对费马原理的误解</a></p>
<p>[3] 知乎文章 <a
href="https://zhuanlan.zhihu.com/p/102780316">1、开篇——最速降线经典问题</a></p>
<p>[4] 知乎文章 <a
href="https://zhuanlan.zhihu.com/p/139018146">浅谈变分原理</a></p>
<p>[5] 陈童老师的<a
href="https://newquanta.com/%e3%80%8a%e7%90%86%e8%ae%ba%e5%8a%9b%e5%ad%a6%e6%96%b0%e8%ae%b2%e3%80%8b%e4%b8%8b%e8%bd%bd/">理论力学新讲</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>物理</category>
      </categories>
      <tags>
        <tag>光学</tag>
        <tag>能带</tag>
        <tag>密度泛函理论</tag>
      </tags>
  </entry>
  <entry>
    <title>第二次分类整理</title>
    <url>/2022/05/10/2022-5/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%88%86%E7%B1%BB%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>记录一下博客第二次分类整理。 <span id="more"></span></p>
<h2 id="正文">正文</h2>
<p>上次整理完六大块后发现子项目分的太细了，可读性不是很高，不能一眼就找到所需要的内容。</p>
<p>本来的分类是这样的</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200941.png"
alt="分类" />
<figcaption aria-hidden="true">分类</figcaption>
</figure>
<p>于是准备再重构一次。一级分类改动方案拟定删减为4个：</p>
<ol type="1">
<li>解决方案</li>
<li>学习笔记</li>
<li>科研项目</li>
<li>文化娱乐</li>
</ol>
<p>将科普和日记并入文化娱乐中。并整合一下过多的二级分类词条。</p>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>随笔与记录</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>英语六级口语</title>
    <url>/2022/05/21/2022-5/%E8%8B%B1%E8%AF%AD%E5%85%AD%E7%BA%A7%E5%8F%A3%E8%AF%AD/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>5/21明天就要考六级口语，临时抱个佛脚。
写的不对的地方明天考完了我会更新的。</p>
<p>5.22考完了，准备了个寂寞。 <span id="more"></span></p>
<h2 id="考题流程">1.考题流程</h2>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201910.png"
alt="六级口语流程" />
<figcaption aria-hidden="true">六级口语流程</figcaption>
</figure>
<p>在考前还会有个调音过程。</p>
<h2 id="part1">2.PART1</h2>
<p>自我介绍可以提前准备，简单介绍一下姓名年龄专业爱好，反倒觉得20s稍微有点短。下面给出我自己的模板。</p>
<p>My name is XXX, I'm 25 years old. And I'm a postgraduate student,
second year accurately. My major is Physics, more specifically, I study
in Raman spectroscopy of two-dimensional crystal materials.</p>
<p>问题一般是小问题，属于热身环节。下面给出几个例题，摘录自星火英语。</p>
<ol type="1">
<li>Where do you usually have your meals? How do you like the food
there?(Food Safety)</li>
<li>What is your favorite movie? Why?(Movie Violence)</li>
<li>Can you live without a smartphone? Why?(The Smartphone)</li>
</ol>
<p>回答大概就是<strong>事实陈述+原因/感受</strong></p>
<p>如问题一的回答：I often have my meals in the school canteen, beacuse
it is very convenient and the price of dish is cheaper than outside. I
think the food in there is not bad, maybe some people will get tired of
eating in school, but general speaking it is suitable for me.</p>
<p>如果一时间没想好怎么回答，可以用些句型来拖一下。如</p>
<p>问题三：In my opinion, I think the answer is no, that is not beacuse
I am addicted to the smartphone, but since I need to show my heath code
when I go out or in to the school gate.</p>
<p>如果发现说完时间还有多怎么办，可以随便扯一点，然后做个总结。</p>
<p>What's more，nowadays we can't live without e-pay, so it is
impossible for me to live without a smartphone.</p>
<h2 id="part2">3.PART2</h2>
<h3 id="自我陈述">3.1 自我陈述</h3>
<p>答题卡样例如下</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201924.png"
alt="六级口语part2答题卡" />
<figcaption aria-hidden="true">六级口语part2答题卡</figcaption>
</figure>
<p>准备一分钟。这里我们主要考虑的是论点。</p>
<p>内容短时间想不出来的主要从四个角度考虑，政府、社会、家庭、个人(<del>社会主义核心价值观</del>).另外没啥东西讲也可以选择举例子（我有一个朋友系列）。当然这个方法也可以套用在对话部分。</p>
<p>基本上话题是分析现象/问题/原因</p>
<p>下面通过三部分构建自我陈述内容。</p>
<h4 id="背景句">3.1.1 背景句</h4>
<p>陈述前可以先铺垫一个背景句，然后引出话题。</p>
<ol type="1">
<li>As the income increases, there is a tendency among people that…</li>
<li>Nowadays, it is a common phenomenon for people to…</li>
<li>with the development of Internet and digital technology,</li>
</ol>
<p>如Card A，背景句如下：</p>
<p>Nowadays, it is a common phenomenon for people to pursue the
spiritual satisfaction, So, many people choose to watch movie in their
spare time.</p>
<p>With the increase of film types, these images of violence and death
beacome more and more popular.</p>
<h4 id="充实内容">3.1.2 充实内容</h4>
<p>这个话题中间还真不好想，从个人讲，人们对平时接触不到的暴力会产生兴趣，举个例子我，我有一个朋友非常喜欢看暴力电影，
这对我来说，我不太喜欢。</p>
<p>逻辑上可能不太通顺，但这个思路是属于可以临时想出来的。</p>
<p>强逻辑性可以用下面的套话</p>
<p>from my point of view, ... ,in the first place..,in the second
place...</p>
<p>Taking account of all these factors, we may draw the conclusion that
...</p>
<p>如果实在没什么办法了，强行扯到解决方案然后套下面的空话</p>
<p>Personally， this phenomenon can be solved by multiple mehods. The
government should strengthen the improvement of relevant policies and
regulations. Such as make rigorous punishment. And It is also very
important to popularize knowledge to the general public, for instance
school teacher can teach student how to ….( So that they can protect
themselves well.) In a word, we should pay more attention to ….</p>
<p>当然如果第三问用到解决措施，也可以套这段。</p>
<h3 id="相互尬聊">3.2 相互尬聊</h3>
<p>我不知道队友水平会不会影响你的成绩。但这一部分的主要问题在聊满时间，我用中文都和陌生人聊不到三分钟，所以准备套路还是必须的。</p>
<p>先手： I am very delighted to do the pair work with you to discuss on
...</p>
<p>from my point of view ...</p>
<p>what is your idea ?</p>
<p>后手： 表观点，复述对方内容，表达自己观点，反问。</p>
<p>表同意： 1. I second it 2. sure it is 3. definitely</p>
<p>不同意： 1. I have something different to say 2. I may not agree with
you</p>
<p>实在没有就直接反问，还是上面几个角度</p>
<p>What do you think the government should do？ What do you think the
school should do？ what can we do？</p>
<p>然后可以把上面的万能套话拆开充时长</p>
<p>还有就是听不懂对方说什么怎么办。一种方法是要求解释一下，第二种方法就是直接yes，I
agree with you.</p>
<h2 id="part3">4.PART3</h2>
<p>这部分也是一个问题，但要求回答比较长的时间。</p>
<p>会是一个比较难的问题，而且前面说的可能词穷了，这里回答不上来。不过在对话题理解加深的情况下，可以借鉴一下队友的观点。</p>
<h2 id="后话">5.后话</h2>
<p>口语考试随机性还是比较大的。我今天的考题是friend。人物题，上面的都是看待事物的。好在雅思口语我准备过人物题，要是换个地点题啥的就gg了。</p>
<p>整个考试流程还是比较快的，先候考，然后进考场测试耳机，随后匹配队友，和队友有一段交流的时间，可以沟通一下策略啥的。考试的问题也不是那么简短，第一个问题我就没听明白，强行答了一段。自我陈述也是蒙蔽的一批，一分钟过的太快了，都没有准备好。交流部分是我自我感觉最好的，队友虽然有点菜，他可能都没听懂我的发言，我疯狂救他，给他抛问题。最后一个问题也非常难答，随便扯了两句就出来了。</p>
<p>整体来说还是挺好玩的。虽然准备的都没用上多少。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>记博客第一次崩溃</title>
    <url>/2022/05/24/2022-5/%E8%AE%B0%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B4%A9%E6%BA%83/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>记博客第一次崩溃，修了一天，曲折。</p>
<p>直接重装换个版本吧。 <span id="more"></span></p>
<h2 id="正文">正文</h2>
<p>原来的next突然出了问题，打开是空白，如下图</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201036.png"
alt="空白页面" />
<figcaption aria-hidden="true">空白页面</figcaption>
</figure>
<p>然后我粗略一排查，发现是主题的问题。</p>
<p>我就想着既然如此，我不如乘这个机会换一个主题。然后就换为Aurora主题，别说这个主题还听炫酷的，科技风。</p>
<p>但很可惜的是弄了一下午，发现公式渲染出了问题。无奈，不写公式是不可能的，再好看的主题都不能用了。</p>
<p>然后还是重新下了一个next主题，从头又美化了一边，发现安装左下角的切换黑夜模式就会出bug，只能又舍弃了这个功能，随后又发现点击图片放大功能也会导致页面崩溃。又砍了，现在只剩这只猫了。</p>
<p><strong>5月28日更新，居然还有遗留bug！</strong></p>
<p>干脆从hexo开始重装！把这些功能都拉回来。</p>
<h2 id="重装需要的包">重装需要的包</h2>
<p>备注：</p>
<p>站点配置指修改站点文件夹的<code>_config.yml</code>文件</p>
<p>主题配置文件指<code>\themes\next\_config.yml</code>文件</p>
<h3 id="看板娘小黑猫">1. 看板娘小黑猫</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br><span class="line">npm install live2d-widget-model-hijiki</span><br></pre></td></tr></table></figure>
<p>添加站点配置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># live2d</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  tagMode: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-hijiki  #选择哪种模型</span><br><span class="line">  display: #放置位置和大小</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: false #是否在手机端显示</span><br></pre></td></tr></table></figure></p>
<h3 id="计数君">2. 计数君</h3>
<p>这个在next8.12.1版本不支持了。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time</span><br></pre></td></tr></table></figure> 添加站点配置
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置博客单词统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  # 文章字数统计</span><br><span class="line">  symbols: true</span><br><span class="line">  # 文章阅读时间统计</span><br><span class="line">  time: true</span><br><span class="line">  # 站点总字数统计</span><br><span class="line">  total_symbols: false</span><br><span class="line">  # 站点总阅读时间统计</span><br><span class="line">  total_time: false</span><br><span class="line">  exclude_codeblock: false</span><br></pre></td></tr></table></figure></p>
<p>修改NexT主题配置文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span><br><span class="line"># 设置博客单词统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  # 是否另起一行（true的话不和发表时间等同一行）</span><br><span class="line">  separated_meta: true</span><br><span class="line">  # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span><br><span class="line">  item_text_post: true</span><br><span class="line">  # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span><br><span class="line">  item_text_total: false</span><br><span class="line">  # 平均字长</span><br><span class="line">  awl: 4</span><br><span class="line">  # 每分钟阅读字数</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure></p>
<h3 id="搜索功能">3. 搜索功能</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>修改主题配置文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local Search</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure></p>
<h3 id="公式问题">4. 公式问题</h3>
<p>见<a
href="https://splendidwave.github.io/2022/04/28/2022-4/%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E5%92%8C%E6%8E%92%E7%89%88%E9%97%AE%E9%A2%98/#more">使用hexo写博客的公式渲染和排版问题</a></p>
<h3 id="修改标签">5.修改标签</h3>
<p>在<code>\themes\next\layout\_macro\post.swig</code>文件中</p>
<p>把<code>#</code>改为<code>&lt;i class="fa fa-tag&gt;&lt;/i&gt;</code>如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;footer class=&quot;post-footer&quot;&gt;</span><br><span class="line">  &#123;%- if post.tags and post.tags.length %&#125;</span><br><span class="line">    &#123;%- if theme.tag_icon %&#125;</span><br><span class="line">      &#123;%- set tag_indicate = &#x27;&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;&#x27; %&#125;</span><br><span class="line">    &#123;% else %&#125;</span><br><span class="line">      &#123;%- set tag_indicate = &#x27;&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;&#x27; %&#125;</span><br><span class="line">    &#123;%- endif %&#125;</span><br><span class="line">    &lt;div class=&quot;post-tags&quot;&gt;</span><br><span class="line">      &#123;%- for tag in post.tags.toArray() %&#125;</span><br><span class="line">        &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;&#123;&#123; tag_indicate &#125;&#125; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br><span class="line">      &#123;%- endfor %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切换夜间模式">6. 切换夜间模式</h3>
<p>这个也可能有bug</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-next-darkmode --save</span><br></pre></td></tr></table></figure>
<p>主题文件添加 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Darkmode JS</span><br><span class="line"># For more information: https://github.com/rqh656418510/hexo-next-darkmode, https://github.com/sandoche/Darkmode.js</span><br><span class="line">darkmode_js:</span><br><span class="line">  enable: true</span><br><span class="line">  bottom: &#x27;64px&#x27; # default: &#x27;32px&#x27;</span><br><span class="line">  right: &#x27;unset&#x27; # default: &#x27;32px&#x27;</span><br><span class="line">  left: &#x27;32px&#x27; # default: &#x27;unset&#x27;</span><br><span class="line">  time: &#x27;0.5s&#x27; # default: &#x27;0.3s&#x27;</span><br><span class="line">  mixColor: &#x27;transparent&#x27; # default: &#x27;#fff&#x27;</span><br><span class="line">  backgroundColor: &#x27;transparent&#x27; # default: &#x27;#fff&#x27;</span><br><span class="line">  buttonColorDark: &#x27;#100f2c&#x27; # default: &#x27;#100f2c&#x27;</span><br><span class="line">  buttonColorLight: &#x27;#fff&#x27; # default: &#x27;#fff&#x27;</span><br><span class="line">  isActivated: false # default false</span><br><span class="line">  saveInCookies: true # default: true</span><br><span class="line">  label: &#x27;🌓&#x27; # default: &#x27;&#x27;</span><br><span class="line">  autoMatchOsTheme: true # default: true</span><br><span class="line">  libUrl: # Set custom library cdn url for Darkmode.js</span><br></pre></td></tr></table></figure></p>
<h3 id="图片放大">7. 图片放大</h3>
<p>到<code>next/source/lib</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-fancybox3 fancybox</span><br></pre></td></tr></table></figure></p>
<p>更改主题配置文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fancybox: true</span><br></pre></td></tr></table></figure></p>
<h3 id="装个deployer">8. 装个deployer</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h3 id="rss">9. RSS</h3>
<p>https://blog.csdn.net/qq_36537546/article/details/90730068</p>
<h3 id="公式渲染">10.公式渲染</h3>
<p>pandoc</p>
<p>https://pandoc.org/installing.html</p>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>随笔与记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>《如何高效学习》读书笔记</title>
    <url>/2022/04/12/2022-4/%E3%80%8A%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>思维导图</p>
<span id="more"></span>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210201958.png"
alt="思维导图" />
<figcaption aria-hidden="true">思维导图</figcaption>
</figure>
<h2 id="前言">1.前言</h2>
<p>最近参加了一个读书的活动。手头正好有本斯科特·杨的《如何高效学习》，就抓过来看了，慢慢看了8天看完了，就把读书笔记的内容整理一下，水一篇博客。</p>
<h2 id="正文">2.正文</h2>
<p>本书的作者是斯科特·杨，他使用自己发明的学习方法十天学完线性代数，12个月学了4年的MIT课程。有许多人对此书推崇备至，个人认为看完此书即便不能大幅度提高学习效率，也必然有些可取之处。</p>
<p>书中首章以玻尔的小故事入手，引出学习不应该是机械式记忆，而是应该是整体性学习，随后介绍了一下整体性学习的基本观点（结构、模型、高速路）。这个观点并不出奇，以前也零碎地接触过一些，但是不够系统，至于模型的概念让我想起物理学笑话中的“真空球形鸡”模型，这种方法确实也广泛应用于物理学。关于机械式记忆，好像本科前接受的教育确实是这样，老师只会强调这个考试重点。但仔细想想，按这本书的逻辑，在没有掌握一些结构和模型情况下，也无法进行整体性学习。所以整本书可能更适合本科的学生阅读。</p>
<p>随后作者阐述了整体性学习的顺序。做事情分步骤这个方法让我想起了本科的一个同学，一起考研时他和我分享了一个英语学习的方法，说只要针对不同题型总结一套做题流程，然后按这个步骤来做就不会在做题时感觉无从下手，我隐约觉得这种方法老师以前也有讲述过，于是尝试了一下，发现确实有效。虽然他最后考研成绩没有过国家线，但我倒是习惯于在处理问题时套用这个方法了。</p>
<p>接下来的这部分内容举例了学习步骤中可能存在的薄弱环节，随后介绍了信息结构。找出问题并解决，这一过程听着非常简单，但就我个人经历来看，有这个意识去做这件事的人往往都是学习成绩非常优异的人。这不是说简单地使用纠错本，而是一种能发现自我问题所在，然后针对性改正的能力。很多人埋头苦学但是水平却不见提升很有可能就是不具备这种能力，但大多数人或许都没有去找问题的意识。</p>
<p>在分类完信息后，作者提出了观点如果能掌控自己的学习，学习任何学科都会变得生动有趣。我认为关键点在于反馈，魂类游戏也有受众，正是因为他们在翻滚躲技能后获得了偷刀的快感。在高中时我根本不想学英语，到现在通过刷题过了六级，想来也是因为获得了英语学习过程中的反馈。学会做小项目恰好是一个非常好的学习目标，期间过程可以收获许多，完成后又能得到正面的反馈。</p>
<p>在文中的第二部分，作者开始介绍了整体学习的技术，首先是如何阅读和做笔记。部分内容在我过去的学习生涯中已经潜移默化地在使用了，像指读法和混合型笔记。笔记非常有用，以前上课时我通常时不做笔记的，但后来渐渐发现自己的记忆力已经不能支撑这种任性的行为了，更后来课程密度变的愈发大了，我发现回看笔记也想不去来这是啥。一直到了现在我开始写博客，做思维导图，希望能有点用吧。</p>
<p>随后的部分虽然介绍的是拓展的方法技术，但作为记忆的方法也未尝不可，正如同比喻法，前面也有好多内容用了比喻，比喻这一手法在理解和记忆方面都具有优势。至于后面的内在化和图表法，更像是利用人类的天性来辅助学习。表情包比单纯的文字更能传达信息，看图像能比看文字获得信息更为高效。文中还提到了一些具体的操作细节，但大概不会有多少人愿意花两三周去练习这个方法，包括我也是。</p>
<p>对于随意信息的处理，作者首先介绍了联想法，这种方法存在很多年了，小时候见过电视上有英语类节目，推销着自己背单词的方法，现在想想其实就是这个联想法。大概是受了其他电视广告骗局的影响，我对这个方法也不感冒。平心而论这个方法有效，但是低效，想象一个夸张荒诞的联想要花费不少时间，作者也在文中提到这个方法需要比其他方法花费更多的时间。</p>
<p>另一个是挂钩法，我以前倒是会经常使用，但是这是第一次听到名字。文中提到和数字挂钩，我认为倒是大可不必，字母星期或者其他事物都是可以挂钩的。挂钩法也算是联想法的一个分支吧。信息压缩技术对应了先把一本书读薄这个步骤，但我始终把握不好这个度，在压缩过程中会失真。</p>
<p>费曼学习法成名已久，不过对目前目的性学习的我来说略显鸡肋。倒是高效率秘籍帮我扫清了一些疑惑，饮食运动睡眠方面只能说尽力而为，我的作息在身边人眼里已经算是“离经叛道”了，但还远远达不到书中的要求。循环作息计划解释我本科隔壁宿舍大佬为什么每天晚上都打游戏却能考上苏大研究生。有种说法是一天不要安排太多的工作，但做不完就会产生挫败感，但我发现当一天安排了100个单位的工作我能完成70，而一天安排70个单位的工作我却只能完成50.直到减到一个我不能接收的效率才能恰好完成。</p>
<p>Don‘t
study这部分我深有体会，虽然感觉我的学习和作者的“学习”不是一个概念，我想学的东西太多，但真正能开展起来的几乎没有，而且对自己手头的工作也难以完成，还是得合理安排。拖延这事我一直是深恶痛绝的，除非时间比较赶，不然宁愿选择慢慢做。批量处理是第一次接触到，回头可以尝试一下。组织化也是我一贯采取的做法，但随着内容的增多始终会有一些无法被归到前面分好类的内容，还需要提高归类能力。</p>
<p>这本书到今天就看完了。整体来说有好些内容是之前就有耳闻或者是已经在使用的，不过正是这样这本书的内容才显得可信。主要的收获在于最后这两天看的内容，里面的步骤比较详尽，为我扫清了一些困惑。养成习惯、克服障碍、设立目标这三个部分确实是自我学习的难点，很多人到了大学后就开始放纵自己，然后又觉得这样做不太好，于是坚持学习了一段时间，随后便泄气了，大概问题就出在这里。</p>
<p>这本书确实短，英文版是一个小册子。手头刚好有中文版的书我就随手抓来看了。书中前面的内容我认为更适合接受过本科及以上教育的人学习，后面的内容倒是适合全年龄段的人，更像是一种习惯吧。</p>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>随笔与记录</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo写博客的公式渲染和排版问题</title>
    <url>/2022/04/28/2022-4/%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E5%92%8C%E6%8E%92%E7%89%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>latex公式排版</p>
<p>hexo公式渲染</p>
<span id="more"></span>
<h2 id="markdown基础">markdown基础</h2>
<p>基础语法见<a
href="https://splendidwave.github.io/2021/12/28/2021-12/%E4%BD%BF%E7%94%A8hexo-markdown%E5%BC%80%E5%90%AF%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C/">使用hexo+markdown开启博客写作</a></p>
<h2 id="latex公式排版">latex公式排版</h2>
<p>等号对齐 &amp;=</p>
<p>加tag </p>
<p>不使用编号 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;align&#125;</span><br><span class="line">u\left(r+R_&#123;m&#125;\right) &amp; = e^&#123;-i \bar&#123;k&#125; \cdot\left(r+R_&#123;m&#125;\right)&#125; \psi\left(r+R_&#123;m&#125;\right) \nonumber\\</span><br><span class="line">&amp; = e^&#123;-i \bar&#123;k&#125; \cdot\left(r+R_&#123;m&#125;\right)&#125; e^&#123;i \bar&#123;k&#125; \cdot R_&#123;m&#125;&#125; \psi(r)\nonumber \\</span><br><span class="line">&amp; = e^&#123;-i \bar&#123;k&#125; \cdot r&#125; \psi(r) \nonumber\\</span><br><span class="line">&amp; = u(r)\nonumber</span><br><span class="line">\end&#123;align&#125;\tag&#123;2.9&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{align}
u\left(r+R_{m}\right) &amp; = e^{-i \bar{k} \cdot\left(r+R_{m}\right)}
\psi\left(r+R_{m}\right) \nonumber\\
&amp; = e^{-i \bar{k} \cdot\left(r+R_{m}\right)} e^{i \bar{k} \cdot
R_{m}} \psi(r)\nonumber \\
&amp; = e^{-i \bar{k} \cdot r} \psi(r) \nonumber\\
&amp; = u(r)\nonumber
\end{align}\tag{2.9}
\]</span></p>
<h2 id="公式渲染">公式渲染</h2>
<p>参考下列方法</p>
<p><a
href="https://www.zhangwei.press/2021/03/03/%E5%B7%A5%E5%85%B7/Hexo/%E5%9C%A8Hexo%E4%B8%AD%E6%B8%B2%E6%9F%93MathJax%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/">在Hexo中使用Mathjax渲染数学公式</a></p>
<p><a href="https://www.jianshu.com/p/16b7ef2653de">hexo latex 换行
多行公式 终极解决方案</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/476601594">Hexo
发布博客的图片和公式问题</a></p>
<p><a
href="https://blog.csdn.net/ssjdoudou/article/details/103318019">Hexo-next主题支持数学公式</a></p>
<p><a
href="https://www.jianshu.com/p/a9f26f4cd4e6">Hexo中的LaTex公式渲染问题</a></p>
<hr />
<p>最后选择使用pandoc渲染，多行也不需要添加<code>nonumber</code></p>
<p>补充参考文献文内超链接方法，使用h5语言</p>
<p>代码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;sup&gt;[1]&lt;/sup&gt;](#refer-anchor-1)</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;refer-anchor-1&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>创建锚值对</p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>基于python的拉曼光谱多峰拟合程序开发笔记3</title>
    <url>/2022/04/11/2022-4/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E6%8B%89%E6%9B%BC%E5%85%89%E8%B0%B1%E5%A4%9A%E5%B3%B0%E6%8B%9F%E5%90%88%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>吐槽</p>
<p><strong>注意：本文是类似于草稿和日记的笔记，不用作解释代码和介绍程序功能。使用说明会另开文章。</strong>
<span id="more"></span></p>
<h2 id="正文">正文</h2>
<p>一贯采取放养政策的我导终于想起来我寒假提交上去的论文了，然后四月开始的这几天在花时间改论文，已经投稿了。</p>
<p>所以我腾出手先把雅思大作文给整理出来，现在准备把之前的程序的最后一个功能给加上。然后我开始嫌弃shell太丑，就顺手把vscode的python环境给配上了。现在C++和python双环境。虽然不刷PAT后C++也不用哈哈哈。</p>
<p>等弄完这个我就得考虑计算能带，不过没有量子力学和固体物理基础感觉好难啊，如果能成功的话我也一并发上来。</p>
<p>版本2.1更新内容 1. 新增了一个选择文件按钮 2. 开发了绘图设置窗口</p>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>随笔与记录</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>拉曼光谱多峰拟合程序2.1版本使用说明</title>
    <url>/2022/04/11/2022-4/%E6%8B%89%E6%9B%BC%E5%85%89%E8%B0%B1%E5%A4%9A%E5%B3%B0%E6%8B%9F%E5%90%88%E7%A8%8B%E5%BA%8F2.1%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="摘要">摘要</h1>
<p>基于python的拉曼光谱多峰拟合程序2.1版本使用说明</p>
<span id="more"></span>
<h1
id="基于python的拉曼多峰拟合画图程序">基于python的拉曼多峰拟合画图程序</h1>
<h2 id="主界面介绍">0.主界面介绍</h2>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203342.png"
alt="界面" />
<figcaption aria-hidden="true">界面</figcaption>
</figure>
<p>主界面一共有6个可调节参数： 1. 文件名 2. gauss峰数量 3. lorentz峰数量
4. voigt峰数量 5. 波数所在列 6. 待处理数据列</p>
<p>8个功能按钮： 1. 载入参数 2. 拟合峰参数 3. 绘图参数 4. 保存参数 5.
查看数据 6. 拟合 7. 记录 8. 绘制总览</p>
<p>3个其他按钮 1. 选择文件 2. 帮助 3. 退出</p>
<h2 id="六个可调节参数">1.六个可调节参数</h2>
<h3 id="文件名">1.1 文件名</h3>
<p>文件要求utf-8格式保存的csv文件，内容样式可以参加下图。</p>
<p>使用excel另存为一下就可以满足条件。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203400.png"
alt="输入文件样式" />
<figcaption aria-hidden="true">输入文件样式</figcaption>
</figure>
<p>输入的名称不需要加后缀，同路径下文件只需输入名称，非同路径下文件需要输入绝对路径。也可以使用后面的按键直接选择文件。</p>
<h3 id="三个峰数量">1.2 三个峰数量</h3>
<p>多峰拟合程序可以拟合多个峰，光谱的峰一般为这三种更多内容可见<a
href="https://splendidwave.github.io/2022/01/26/2022-1/%E8%B0%B1%E7%BA%BF%E5%B1%95%E5%AE%BD%E5%92%8C%E7%BA%BF%E5%9E%8B%E5%87%BD%E6%95%B0/">谱线展宽和线型函数</a></p>
<p>通过滑块可以分别选择这三个峰的数量，最终拟合函数为这些峰的和。</p>
<h3 id="波数所在列">1.3 波数所在列</h3>
<p>即横坐标所在列，拉曼光谱图像横坐标为拉曼频移，单位为波数</p>
<h3 id="待处理数据列">1.4 待处理数据列</h3>
<p>即纵坐标所在列，拉曼光谱图像纵坐标为强度，通常无单位，绘制散点图和单幅拟合时，需要选中待处理数据。</p>
<h2 id="八个按钮">2.八个按钮</h2>
<h3 id="载入参数按钮">2.1 “载入参数”按钮</h3>
<p>点击该按钮会弹出当前路径的窗口。</p>
<p>所有参数保存为.npz格式。</p>
<p>在该窗口中可以选择.npz后缀的文件进行参数读取。</p>
<h3 id="拟合峰参数按钮">2.2 “拟合峰参数”按钮</h3>
<p>点击该按钮会弹出一个子窗口，如下</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203417.png"
alt="拟合参数设置窗口" />
<figcaption aria-hidden="true">拟合参数设置窗口</figcaption>
</figure>
<p>该窗口左侧显示3个峰的数量。注意参数不要超出该数目。</p>
<p>每个峰会有4个参数（偏置，幅值，中心位置，半高宽）
在该窗口可以设置每个峰的拟合范围（最大值和最小值）</p>
<p>可以先通过点击“绘制散点图”按钮大致观察峰存在的范围然后依次输入。</p>
<p>如果拟合曲线有多个相同峰，如4个高斯峰，则在Gauss输入框中按顺序写下4个峰的参数，中间用英文逗号分割。</p>
<p>点击帮助会在控制台输出上述文字。</p>
<p>点击确认会记录输入的参数。</p>
<h3 id="绘图参数按钮">2.3 “绘图参数”按钮</h3>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203430.png"
alt="绘图参数设置窗口" />
<figcaption aria-hidden="true">绘图参数设置窗口</figcaption>
</figure>
<p>主要按照python绘图规则输入参数。子峰前面的复选框取消勾选就不会绘制子峰。具体配置参看<a
href="https://splendidwave.github.io/2022/01/30/2022-1/%E4%BD%BF%E7%94%A8python%E8%BF%9B%E8%A1%8C%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE/">使用python进行科研绘图</a>.</p>
<p>点击帮助没什么用。</p>
<p>点击确认会记录输入的参数。</p>
<h3 id="保存参数按钮">2.4 “保存参数”按钮</h3>
<p>点击该按钮会弹出当前路径的窗口。您可以保存您当前设定的参数包括主界面参数和拟合峰参数，自定义名字，可以是中文，不需要加后缀。</p>
<h3 id="查看数据按钮">2.5 “查看数据”按钮</h3>
<p>点击该按钮会尝试读取文件。输出共有多少列，并输出前5行，可以用于检测是否读取到了正确的数据文件。</p>
<p>最后会根据参数5、6绘制散点图。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203447.png"
alt="查看数据" />
<figcaption aria-hidden="true">查看数据</figcaption>
</figure>
<h3 id="拟合按钮">2.6 “拟合”按钮</h3>
<p>点击该按钮会根据所有参数进行数据拟合并显示图片。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203500.png"
alt="拟合" />
<figcaption aria-hidden="true">拟合</figcaption>
</figure>
<h3 id="记录按钮">2.7 “记录”按钮</h3>
<p>点击该按钮会临时记录本次拟合的结果参数，并有相关提示。</p>
<p>关闭程序数据会清空。</p>
<h3 id="绘制总览按钮">2.8 “绘制总览”按钮</h3>
<p>点击该按钮会将临时记录的数据绘制在一张图中。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210203513.png"
alt="绘制总览（只记录了两个数据）" />
<figcaption aria-hidden="true">绘制总览（只记录了两个数据）</figcaption>
</figure>
<h2 id="三个其他按钮">3.三个其他按钮</h2>
<h3 id="选择文件">3.1 选择文件</h3>
<p>输入文件可以通过在框内输入文件名和点击选择文件按钮两种方式输入。</p>
<h3 id="帮助">3.2 帮助</h3>
<p>点击该按钮会给出一些帮助，可能也没啥用。</p>
<h3 id="退出">3.3 退出</h3>
<p>点击该按钮会退出程序，在这之前会先询问一下你是否需要保存参数。选择是在你下次打开该程序后还是会显示当前设置过的参数。</p>
<h2 id="附件">4.附件</h2>
<p>程序下载地址：https://github.com/splendidwave/Raman_fit</p>
]]></content>
      <categories>
        <category>科研项目</category>
        <category>工具项目</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>科研</tag>
        <tag>光谱</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习实战1</title>
    <url>/2022/04/22/2022-4/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%981/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>《机器学习实战：基于Scikit-Learn和TensorFlow》学习笔记</p>
<p>加州房价 <span id="more"></span></p>
<h2 id="机器学习概览">1.机器学习概览</h2>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210202119.png"
alt="机器学习概览" />
<figcaption aria-hidden="true">机器学习概览</figcaption>
</figure>
<h2 id="机器学习项目--加州房价预测">2.机器学习项目--加州房价预测</h2>
<p>假设你是一个房地产公司最近新雇佣的数据科学家，你需要根据加州房价数据集建立一个房价模型，使其能预测任意区域的房价中位数。</p>
<p>以下是你可能需要经历的步骤流程</p>
<ol type="1">
<li>观察大局</li>
<li>获得数据</li>
<li>从数据探索和可视化中获得洞见</li>
<li>机器学习算法的数据准备</li>
<li>选择和训练模型</li>
<li>微调模型</li>
<li>展示解决方案</li>
<li>启动、监控和维护系统</li>
</ol>
<h3 id="观察大局">2.1 观察大局</h3>
<p>首先我们需要明确目标，输入和输出是什么？数据是否包含结果？数据是否会更新？</p>
<p>这些问题会决定你的机器学习模型应该是什么样的。输入是人口收入中位数等信息，显然这应该设定为监督式学习，房价数据肯定会更新，但变化不快，批量学习也能接受。</p>
<p>对于房价预测问题，有接触过机器学习的应该都能看出这就是一个典型的多元回归任务。</p>
<p>接下来应该选取一个合适的性能指标，回归问题的典型衡量指标是均方根误差（RMSE），计算公式如下</p>
<p><span class="math display">\[
RMSE(\mathbf{X},h) =
\sqrt[]{\frac{1}{m}\sum_{i=1}^{m}(h(\mathbf{x}^{\left ( i \right )
})-y^{(i)} )^2  }  
\]</span></p>
<p>其中h()是预测函数，<span
class="math inline">\(\mathbf{x}^{(i)}\)</span>是指数据集中第i个实例的所有特征值向量。<span
class="math inline">\(y^{(i)}\)</span>是标签值。</p>
<p>所以<span class="math inline">\(h(\mathbf{x}^{\left ( i \right )
})\)</span>是预测值，它和标签值的差的平方可以被当作偏离误差。也是机器学习中常用的标准。如果不开根号就叫做均方根误差（MSE）</p>
<p>另一个常用的是平均绝对误差（MAE）公式如下：</p>
<p><span class="math display">\[
MAE(\mathbf{X},h) = \frac{1}{m}\sum_{i=1}^{m}\left |
(h(\mathbf{x}^{\left ( i \right ) })-y^{(i)} )   \right |
\]</span></p>
<h3 id="获取数据">2.2 获取数据</h3>
<p>数据文件<a
href="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/non-image/housing.csv">点击下载</a></p>
<p>我这里直接用的jupyter</p>
<p>使用pandas库加载数据，使用head()方法快速参看前5行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">def loading_housing_data():</span><br><span class="line">    csv_data = pd.read_csv(r&#x27;datasets\housing\housing.csv&#x27;)</span><br><span class="line">    return csv_data</span><br><span class="line"></span><br><span class="line">housing = loading_housing_data()</span><br><span class="line">housing.head()</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210202326.png"
alt="查看数据" />
<figcaption aria-hidden="true">查看数据</figcaption>
</figure>
<p>可以看出数据共有10个属性，使用info()方法可以查看属性类型及数量,describe()方法可以显示属性值摘要。</p>
<p>使用value_counts()方法可以查看该列又多少种分类。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;housing[&#x27;ocean_proximity&#x27;].value_counts()</span><br><span class="line">output:</span><br><span class="line">&lt;1H OCEAN     9136</span><br><span class="line">INLAND        6551</span><br><span class="line">NEAR OCEAN    2658</span><br><span class="line">NEAR BAY      2290</span><br><span class="line">ISLAND           5</span><br><span class="line">Name: ocean_proximity, dtype: int64</span><br></pre></td></tr></table></figure></p>
<p>使用matplotlib库可以快速绘制直方图 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">housing.hist(bins = 50,figsize=(20,15))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
bin是指每张图的柱子个数，figsize是图片大小。</p>
<h4 id="快速查看数据的方法">快速查看数据的方法</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">housing.head() # 前5行</span><br><span class="line">housing.info() # 查看属性类型及数量</span><br><span class="line">housing.describe() # 显示属性值摘要</span><br><span class="line">housing[&#x27;ocean_proximity&#x27;].value_counts() # 查看分类</span><br><span class="line">housing.hist(bins = 50,figsize=(20,15)) # 绘制直方图</span><br></pre></td></tr></table></figure>
<hr />
<p>在浏览完数据后，就需要划分训练集和测试集。在数量庞大的情况下可以选择随机划分，为保证每次运行的训练集和测试集相同，最好是分完就保存或者设定一个随机数种子。</p>
<p>另一个方法是更具标识符来划分，这样新增的数据可以通过打标识来解决，而前面的不需要变化。常用的标识符是哈希值。</p>
<p>以上讨论的都是随机划分，但有时候这样做选出来的数据不够典型。以房价为例，房价和人居收入必然是紧密联系的，我们应当在各个收入阶层都选出按照原数据比例选出。</p>
<p>为此我们不妨新增一个属性，起名叫“income_cat”，将人群按收入高低划分为5类
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">housing[&quot;income_cat&quot;] = np.ceil(housing[&quot;median_income&quot;]/1.5)</span><br><span class="line">housing[&quot;income_cat&quot;].where(housing[&quot;income_cat&quot;]&lt;5,5.0,inplace=True)</span><br></pre></td></tr></table></figure> 现在使用Scikit-learn的StratifiedShuffle
Split类进行分层抽样。</p>
<h4 id="使用split类进行分层抽样">使用Split类进行分层抽样</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.model_selection import StratifiedShuffleSplit</span><br><span class="line"></span><br><span class="line">split = StratifiedShuffleSplit(n_splits=1,test_size=0.2,random_state=42)</span><br><span class="line">for train_index,test_index in split.split(housing,housing[&quot;income_cat&quot;]):</span><br><span class="line">    strat_train_set = housing.loc[train_index]</span><br><span class="line">    strat_test_set = housing.loc[test_index]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参数n_splits 是将训练数据分成train/test对的组数。</p>
<p>参数test_size和train_size是用来设置train/test对中train和test所占的比例。</p>
<p>参数random_state控制随机。</p>
<p>使用下面命令查看是否根据收入比例分配 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">housing[&quot;income_cat&quot;].value_counts()/len(housing)</span><br><span class="line">strat_train_set[&quot;income_cat&quot;].value_counts()/len(strat_train_set)</span><br></pre></td></tr></table></figure>
完成后删去"income_cat"恢复原始数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for set in (strat_train_set,strat_test_set):</span><br><span class="line">    set.drop([&quot;income_cat&quot;],axis=1,inplace=True)</span><br></pre></td></tr></table></figure></p>
<h3 id="从数据探索和可视化中获得洞见">2.3
从数据探索和可视化中获得洞见</h3>
<p>分配好训练集和测试集后，我们需要对数据有更深入的洞察，先创建一个训练集副本
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">housing = strat_train_set.copy()</span><br></pre></td></tr></table></figure> 在房价问题中，不妨先用热力图看下地图信息 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">housing.plot(kind=&quot;scatter&quot;,x=&quot;longitude&quot;,y=&quot;latitude&quot;,alpha=0.4,</span><br><span class="line">            s=housing[&quot;population&quot;]/100,label=&quot;population&quot;,</span><br><span class="line">            c=&quot;median_house_value&quot;,cmap=plt.get_cmap(&quot;jet&quot;),colorbar=True,</span><br><span class="line">            )</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure>
上面参数s指size，c指color，cmap是配色方案。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210202343.png"
alt="高密度区域可视化" />
<figcaption aria-hidden="true">高密度区域可视化</figcaption>
</figure>
<p>可以看出，靠近西海岸的房价会比较高。</p>
<p>由于数据集不大，可以使用corr()方法计算出属性间的相关性 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">corr_matrix = housing.corr()</span><br><span class="line">corr_matrix[&quot;median_house_value&quot;].sort_values(ascending=False)</span><br><span class="line">coutput:</span><br><span class="line">median_house_value    1.000000</span><br><span class="line">median_income         0.687151</span><br><span class="line">total_rooms           0.135140</span><br><span class="line">housing_median_age    0.114146</span><br><span class="line">households            0.064590</span><br><span class="line">total_bedrooms        0.047781</span><br><span class="line">population           -0.026882</span><br><span class="line">longitude            -0.047466</span><br><span class="line">latitude             -0.142673</span><br><span class="line">Name: median_house_value, dtype: float64</span><br></pre></td></tr></table></figure>
相关系数是-1到1之间的值，越接近1说明有越强的正相关性；越接近-1有越强的负相关性；越接近0说明越不相关。</p>
<p>试验不同属性的组合。在获得数据的相关性后，我们也可以自行构建数据，比如“房间总数”没什么用，但它除以“家庭户数”就可以得到平均一家有多少房间，同样“卧室总数”也可以这么处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">housing[&quot;rooms_per_household&quot;] = housing[&quot;total_rooms&quot;]/housing[&quot;households&quot;]</span><br><span class="line">housing[&quot;bedrooms_per_room&quot;] = housing[&quot;total_bedrooms&quot;]/housing[&quot;total_rooms&quot;]</span><br><span class="line">housing[&quot;population_per_household&quot;] = housing[&quot;population&quot;]/housing[&quot;households&quot;]</span><br></pre></td></tr></table></figure>
<p>再处理完后可以再参看一次相关性 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output:</span><br><span class="line">median_house_value          1.000000</span><br><span class="line">median_income               0.687151</span><br><span class="line">rooms_per_household         0.146255</span><br><span class="line">total_rooms                 0.135140</span><br><span class="line">housing_median_age          0.114146</span><br><span class="line">households                  0.064590</span><br><span class="line">total_bedrooms              0.047781</span><br><span class="line">population_per_household   -0.021991</span><br><span class="line">population                 -0.026882</span><br><span class="line">longitude                  -0.047466</span><br><span class="line">latitude                   -0.142673</span><br><span class="line">bedrooms_per_room          -0.259952</span><br><span class="line">Name: median_house_value, dtype: float64</span><br></pre></td></tr></table></figure></p>
<p>看起来结果还可以，到了这一步我希望能将我的工作保存一下，当后面对数据进行一些处理后，我还能把这个自己组合出来的数据算出来。为此我应该建立一个函数或者是类。恰好scikit-learn已经提供了一些基础类型，只需要调用TransformerMixin和BaseEstimator作为基类，然后创建fit和transform方法。就可以将这一过程变为自定义转换器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.base import BaseEstimator,TransformerMixin</span><br><span class="line">rooms_ix,bedrooms_ix,population_ix,household_ix = 3,4,5,6</span><br><span class="line">class CombinedAttributesAdder(BaseEstimator,TransformerMixin):</span><br><span class="line">    def __init__(self, add_bedrooms_per_room = True):#no *args or **kargs</span><br><span class="line">        self.add_bedrooms_per_room = add_bedrooms_per_room</span><br><span class="line">    def fit(self, X, y=None):</span><br><span class="line">        return self  # nothing else to do</span><br><span class="line">    def transform(self, X, y=None):</span><br><span class="line">        rooms_per_household = X[:, rooms_ix] / X[:, household_ix]</span><br><span class="line">        population_per_household = X[:, population_ix] / X[:, household_ix]</span><br><span class="line">        if self.add_bedrooms_per_room:</span><br><span class="line">            bedrooms_per_room = X[:, bedrooms_ix] / X[:, rooms_ix]</span><br><span class="line">            return np.c_[X, rooms_per_household, population_per_household,</span><br><span class="line">                         bedrooms_per_room]</span><br><span class="line">        else:</span><br><span class="line">            return np.c_[X, rooms_per_household, population_per_household]</span><br></pre></td></tr></table></figure>
<p>其中np.c_是按列合并array</p>
<h3 id="机器学习算法的数据准备">2.4 机器学习算法的数据准备</h3>
<p>这一步需要我们对数据开始正式处理，前面的都只是在观察，先回到一个干净的数据集,drop()方法会创建一个副本，不会影响到训练集。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">housing = strat_train_set.drop(&quot;median_house_value&quot;,axis=1)</span><br><span class="line">housing_labels = strat_train_set[&quot;median_house_value&quot;].copy()</span><br></pre></td></tr></table></figure></p>
<h4 id="数值处理">2.4.1 数值处理</h4>
<p>下一步就是数据清理，因为有限属性存在部分数据缺失，解决方法有三种 1.
放弃该行数据 2. 放弃该列数据 3. 补全该数据</p>
<p>放弃改行可以使用<code>housing.dropna(subset=["total_bedrooms"])</code></p>
<p>放弃该列可以使用<code>housing.drop("toatl_bedrooms",axis=1)</code></p>
<p>补全可以使用中位数、平均值、或直接用0进行补全
<code>housing["total_bedrooms"].fillna(median)</code></p>
<p>对于补全scikit-learn还提供了imputer类来辅助处理。
这里版本问题，代码和书上略有不同 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.impute import SimpleImputer</span><br><span class="line">imputer = SimpleImputer(strategy=&quot;median&quot;)</span><br><span class="line">housing_num = housing.drop(&quot;ocean_proximity&quot;,axis=1) # 把文本属性的先去除</span><br><span class="line">imputer.fit(housing_num) # 计算出所有拟补全数据</span><br></pre></td></tr></table></figure>
可以使用<code>imputer.statistics_</code>参看各列的拟补全数据。</p>
<p>现在可以补全数据并加回文本属性数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X = imputer.transform(housing_num)</span><br><span class="line">housing_tr = pd.DataFrame(X,columns=housing_num.columns)</span><br></pre></td></tr></table></figure></p>
<h4 id="文本处理">2.4.2 文本处理</h4>
<p>现在完成了数据的补全，但对于文本信息我们还没进行处理，计算机对于数字更敏感，所以我们最好把文本信息转换为数字。</p>
<p>scikit-learn中的LabelEncoder刚好可以处理这个问题： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.preprocessing import LabelEncoder</span><br><span class="line">encoder = LabelEncoder()</span><br><span class="line">housing_cat = housing[&quot;ocean_proximity&quot;]</span><br><span class="line">housing_cat_encoded = encoder.fit_transform(housing_cat)</span><br></pre></td></tr></table></figure></p>
<p>使用<code>encoder.classes_</code>查看映射</p>
<p>但这种直接的编码方法不是很好，比如海岛和近海的属性比较像，但数值却一个为0一个为4，为解决这个方法，我们可以使用OneHotEncoder进行独热编码，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.preprocessing import OneHotEncoder</span><br><span class="line">encoder = OneHotEncoder()</span><br><span class="line">housing_cat_1hot = encoder.fit_transform(housing_cat_encoded.reshape(-1,1))</span><br><span class="line">housing_cat_1hot</span><br></pre></td></tr></table></figure>
<p>reshape(-1,1)中的-1指未设定行数，程序自动分配。</p>
<p>使用LabelBinarizer可以直接一步到位 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.preprocessing import LabelBinarizer</span><br><span class="line">encoder = LabelBinarizer(sparse_output=True)</span><br><span class="line">housing_cat_1hot= encoder.fit_transform(housing_cat)</span><br><span class="line">housing_cat_1hot</span><br></pre></td></tr></table></figure></p>
<p>清洗好数据之后，我们可以利用之前编写的类将自定义的属性添加进来。</p>
<h4 id="特征缩放">2.4.3 特征缩放</h4>
<p>特征缩放也是数据处理中的重要一环，如果有部分数据数值过大，很有可能会影响到结果，最好是参数范围差不多。</p>
<p>常用缩放方法有两种： 1. 最小-最大放缩</p>
<pre><code>这种方法又称为归一化，是将数据映射为0-1之间。实现方法是（目标值-最小值）/（最大值-最小值）</code></pre>
<ol start="2" type="1">
<li><p>标准化</p>
<p>标准化的均值总是为0，计算方法是（m-mean）/方差，它受异常值的影响会笔记小。</p></li>
</ol>
<h4 id="转换流水线">2.4.4 转换流水线</h4>
<p>在数据清洗和处理的过程都是按照一个顺序进行的，很像工厂里的流水线，scikit-learn正好提供了Pipeline来支持这样的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.pipeline import Pipeline</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line"> </span><br><span class="line">num_pipeline = Pipeline([</span><br><span class="line">        (&#x27;imputer&#x27;, SimpleImputer(strategy=&quot;median&quot;)),</span><br><span class="line">        (&#x27;attribs_adder&#x27;, CombinedAttributesAdder()),</span><br><span class="line">        (&#x27;std_scaler&#x27;, StandardScaler()),#标准化转换器</span><br><span class="line">    ])</span><br><span class="line"> </span><br><span class="line">housing_num_tr = num_pipeline.fit_transform(housing_num)</span><br></pre></td></tr></table></figure>
<p>这时候不妨回头看一下这些过程，第一个是补全，使用的SimpleImputer类，第二个是自定义的CombinedAttributesAdder类，第三个是标准化缩放类StandardScaler</p>
<p>它们都被要求有fit_transform()方法。考虑到scikit-learn不支持DataFrame，为此我们可能会需要用到一个df转ndarray的类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.base import BaseEstimator, TransformerMixin</span><br><span class="line"></span><br><span class="line">class DataFrameSelector(BaseEstimator, TransformerMixin):</span><br><span class="line">    def __init__(self, attribute_names):</span><br><span class="line">        self.attribute_names=attribute_names</span><br><span class="line">    def fit(self, X, y=None):</span><br><span class="line">        return self</span><br><span class="line">    def transform(self, X):</span><br><span class="line">        return X[self.attribute_names].values</span><br></pre></td></tr></table></figure>
<p>然后把处理文本的流水线也加进来，额外的使用一个ColumnTransformer类来并行处理这些数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.compose import ColumnTransformer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_attribs = list(housing_num)</span><br><span class="line">cat_attribs = [&quot;ocean_proximity&quot;]</span><br><span class="line"></span><br><span class="line">num_pipeline = Pipeline([</span><br><span class="line">    (&#x27;selector&#x27;,DataFrameSelector(num_attribs)),</span><br><span class="line">    (&#x27;imputer&#x27;, SimpleImputer(strategy=&quot;median&quot;)),</span><br><span class="line">    (&#x27;attribs_adder&#x27;, CombinedAttributesAdder()),</span><br><span class="line">    (&#x27;std_scaler&#x27;, StandardScaler()),#标准化转换器</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">cat_pipeline = Pipeline([</span><br><span class="line">    (&#x27;selector&#x27;,DataFrameSelector(cat_attribs)),</span><br><span class="line">    (&#x27;label_binarizer&#x27;,LabelBinarizer()),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">full_pipeline = ColumnTransformer([</span><br><span class="line">        (&quot;num&quot;, num_pipeline, num_attribs),</span><br><span class="line">        (&quot;cat&quot;, OneHotEncoder(), cat_attribs),</span><br><span class="line">    ])</span><br><span class="line"> </span><br><span class="line">housing_prepared = full_pipeline.fit_transform(housing)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="选择和训练模型">2.5 选择和训练模型</h3>
<h4 id="建立模型">2.5.1 建立模型</h4>
<p>目前我们已经可以自动化洗数据了，接下来我们应该整一个回归模型！</p>
<p>先来个线性回归看看 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line"></span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line">lin_reg.fit(housing_prepared, housing_labels)</span><br></pre></td></tr></table></figure>
训练好了，使用均方根误差看看效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.metrics import mean_squared_error</span><br><span class="line">housing_predictions = lin_reg.predict(housing_prepared)</span><br><span class="line">lin_mse = mean_squared_error(housing_labels, housing_predictions)</span><br><span class="line">lin_rmse=np.sqrt(lin_mse)</span><br><span class="line">lin_rmse</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">68627.87390018745</span><br></pre></td></tr></table></figure>
<p>emmm,貌似效果不太行，要不换成决策树？ <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.tree import DecisionTreeRegressor</span><br><span class="line">tree_reg = DecisionTreeRegressor()</span><br><span class="line">tree_reg.fit(housing_prepared, housing_labels)</span><br><span class="line">housing_predictions = tree_reg.predict(housing_prepared)</span><br><span class="line">tree_mse = mean_squared_error(housing_labels, housing_predictions)</span><br><span class="line">tree_rmse = np.sqrt(tree_mse)</span><br><span class="line">tree_rmse</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">0.0</span><br></pre></td></tr></table></figure>
emmm,没有误差也太假了，看来是过拟合了。</p>
<h4 id="交叉验证">2.5.2 交叉验证</h4>
<p>注意，这时候我们还没有动测试集，我们也不应该动。评估决策树模型还可以使用交叉验证，以下是k-折交叉验证的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.model_selection import cross_val_score</span><br><span class="line">scores = cross_val_score(tree_reg, housing_prepared, housing_labels, scoring = &#x27;neg_mean_squared_error&#x27;,cv=10)</span><br><span class="line">tree_rmse_scores = np.sqrt(-scores)</span><br><span class="line"></span><br><span class="line">def display_scrores(scores):</span><br><span class="line">    print(&quot;scores:&quot;,scores)</span><br><span class="line">    print(&quot;Mean:&quot;,scores.mean())</span><br><span class="line">    print(&quot;standard dviation:&quot;,scores.std())</span><br><span class="line"></span><br><span class="line">display_scrores(tree_rmse_scores)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">scores: [73138.67517572 71506.36370902 68525.17513869 71289.0410928</span><br><span class="line"> 68730.16014932 78124.19174839 70826.82238157 75178.21352962</span><br><span class="line"> 68631.28499359 70483.13744005]</span><br><span class="line">Mean: 71643.30653587906</span><br><span class="line">standard dviation: 2935.505119383448</span><br></pre></td></tr></table></figure>
<p>和线性回归做个对比</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lin_scores = cross_val_score(lin_reg,housing_prepared,housing_labels,scoring=&#x27;neg_mean_squared_error&#x27;,cv=10)</span><br><span class="line">lin_rmse_scores = np.sqrt(-lin_scores)</span><br><span class="line"></span><br><span class="line">display_scrores(lin_rmse_scores)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">scores: [71762.76364394 64114.99166359 67771.17124356 68635.19072082</span><br><span class="line"> 66846.14089488 72528.03725385 73997.08050233 68802.33629334</span><br><span class="line"> 66443.28836884 70139.79923956]</span><br><span class="line">Mean: 69104.07998247063</span><br><span class="line">standard dviation: 2880.3282098180666</span><br></pre></td></tr></table></figure>
<p>两者半斤八两。</p>
<p>再来试试随机森林 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.ensemble import RandomForestRegressor</span><br><span class="line">forest_reg = RandomForestRegressor()</span><br><span class="line"></span><br><span class="line">forest_reg.fit(housing_prepared, housing_labels)</span><br><span class="line">housing_predictions = forest_reg.predict(housing_prepared)</span><br><span class="line">forest_rmse = np.sqrt(mean_squared_error(housing_labels, housing_predictions))</span><br><span class="line">forest_rmse</span><br><span class="line"></span><br><span class="line">forest_rmse_scores = cross_val_score(forest_reg,housing_prepared,housing_labels,scoring=&#x27;neg_mean_squared_error&#x27;,cv=10)</span><br><span class="line">forest_rmse_scores = np.sqrt(-forest_rmse_scores)</span><br><span class="line">display_scrores(forest_rmse_scores)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">scores: [51437.73602527 49070.23768941 46719.25099192 52092.63291424</span><br><span class="line"> 47390.46029858 51348.37861955 52067.85418266 49650.99947482</span><br><span class="line"> 48476.17361121 54240.18337563]</span><br><span class="line">Mean: 50249.39071832983</span><br><span class="line">standard dviation: 2253.416487488719</span><br></pre></td></tr></table></figure></p>
<p>略好一筹。</p>
<h4 id="保存模型">2.5.2 保存模型</h4>
<p>尝试过的模型应该好好保存，因为你永远不知道哪个模型是最好的。记得还得保存一下训练参数，joblib就用来是保存的库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import joblib</span><br><span class="line"></span><br><span class="line">joblib.dump(forest_reg,&quot;随机森林.pkl&quot;) # 保存</span><br><span class="line"></span><br><span class="line">my_model_loaded = joblib.load(&quot;随机森林.pkl&quot;) # 读取</span><br></pre></td></tr></table></figure>
<h3 id="微调模型">2.6 微调模型</h3>
<p>微调的一种方法是网格搜索，它会尝试多个超参数的值来找到最佳的组合，这里简单看一下即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.model_selection import GridSearchCV</span><br><span class="line">param_grid = [</span><br><span class="line">    &#123;&#x27;n_estimators&#x27;:[3,10,30], &#x27;max_features&#x27;:[2,4,6,8]&#125;,</span><br><span class="line">    &#123;&#x27;bootstrap&#x27;:[False],&#x27;n_estimators&#x27;:[3,10],&#x27;max_features&#x27;:[2,3,4]&#125;,</span><br><span class="line">]</span><br><span class="line">forest_reg = RandomForestRegressor()</span><br><span class="line">grid_search = GridSearchCV(forest_reg, param_grid, cv=5,scoring=&#x27;neg_mean_squared_error&#x27;)</span><br><span class="line">grid_search.fit(housing_prepared, housing_labels)</span><br></pre></td></tr></table></figure>
<p>neg_mean_squared_error 是负均方根</p>
<hr />
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次分类整理</title>
    <url>/2022/04/21/2022-4/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E7%B1%BB%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>记录一下博客第一次分类整理。 <span id="more"></span></p>
<h2 id="正文">正文</h2>
<p>今日心血来潮，感觉我这博客分类不太行，写多了要崩。</p>
<p>本来的分类是这样的</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210202028.png"
alt="分类" />
<figcaption aria-hidden="true">分类</figcaption>
</figure>
<p>我感觉雅思也不算科普，光谱学和光学又有些重复，考虑到我最近在写的紧束缚模型计算黑磷能带内容也没分类着落，于是准备重构一次。一级分类改动方案拟定如下：</p>
<ol type="1">
<li>解决方案</li>
<li>日记随笔</li>
<li>学习笔记</li>
<li>科普知识</li>
<li>科研项目</li>
<li>文化娱乐</li>
</ol>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>随笔与记录</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>能带理论-布洛赫和瓦尼尔</title>
    <url>/2022/04/22/2022-4/%E8%83%BD%E5%B8%A6%E7%90%86%E8%AE%BA-%E5%B8%83%E6%B4%9B%E8%B5%AB%E5%92%8C%E7%93%A6%E5%B0%BC%E5%B0%94/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>能带理论是研究固体中电子运动的主要理论基础，本文主要介绍了能带论中的布洛赫函数和瓦尼尔函数。</p>
<span id="more"></span>
<h2 id="正格矢和倒格矢">1.正格矢和倒格矢</h2>
<p>在三维晶体中，任一格点可以用正格矢来表示</p>
<p><span class="math display">\[
\mathbf{R}_l=l_1 \mathbf{a}_1+l_2 \mathbf{a}_2+l_3
\mathbf{a}_3=\sum_{i=1}^{3} l_i \mathbf{a}_i \tag{1.1}
\]</span></p>
<p>其中<span class="math inline">\(l_1\)</span>、<span
class="math inline">\(l_2\)</span>、<span
class="math inline">\(l_3\)</span>取所有整数，<span
class="math inline">\(\mathbf{a}_1\)</span>、<span
class="math inline">\(\mathbf{a}_2\)</span>、<span
class="math inline">\(\mathbf{a}_3\)</span>为点阵的基矢，题目构成的平行六面体叫元胞。</p>
<p>在实空间正格矢固然足以表示晶体的性质，但未免有些效率低下。因为晶体呈现出的是一个周期性结构，假设实空间中某点的势场可以用<span
class="math inline">\(f(r)\)</span>来描述，那我们有 <span
class="math display">\[
f(r) = f(r+R_l)\tag{1.2}
\]</span></p>
<p>当晶体中周期性结构数以万万计的时候，这种表示方法就太啰嗦了，物理学家总是喜欢偷懒的，能少写绝不多写，处理周期性函数的方法第一个想到的肯定是傅里叶变换，但时域的傅里叶变换是频域，空域的傅里叶变换是什么？答案是波矢k，时间t变到频域f实际上是取了个倒数，而空间(长度)的倒数就是波数k，因为<span
class="math inline">\(k=\frac{2\pi}{\lambda}\)</span></p>
<p>用波矢k来表示那可真是太好不过了，因为晶体中的电子、声子等元激发都是用波矢量来描述的，既然是倒数，那我们不妨称这个空间为倒空间。</p>
<p>物理学上是这样定义倒格矢的 <span class="math display">\[
\begin{aligned}
\mathbf{b}_{1} &amp;=2 \pi \frac{\mathbf{a_{2}} \times
\mathbf{a_{3}}}{\mathbf{a_{1}}\cdot \left[\mathbf{a_{2}}\times
\mathbf{a_{3}}\right]} \\
\mathbf{b}_{2} &amp;=2 \pi \frac{\mathbf{a_{3}} \times
\mathbf{a_{1}}}{\mathbf{a_{1}} \cdot \left[\mathbf{a_{2}} \times
\mathbf{a_{3}}\right]} \\
\mathbf{b}_{3} &amp;=2 \pi \frac{\mathbf{a_{1}}
\times\mathbf{a_{2}}}{\mathbf{a_{1}} \cdot \left[\mathbf{a_{2}} \times
\mathbf{a_{3}}\right]}
\end{aligned}\tag{1.3}
\]</span></p>
<p><span class="math inline">\(\Omega  = a_1 \bullet [a_2 \times
a_3]\)</span>是元胞的体积， <span class="math inline">\(a_2 \times
a_3\)</span>是面积，相除刚好是长度的倒数。
于是倒空间的任一格点可以表示为</p>
<p><span class="math display">\[
\mathbf{G}=m_{1} \mathbf{b}_{1}+m_{2} \mathbf{b}_{2}+m_{3}
\mathbf{b}_{3}=\sum_{i=1}^{3} l_{i} \mathbf{b}_{i} \tag{1.4}
\]</span></p>
<p>另外正反格矢之间的关系为 <span class="math display">\[
\mathbf{a_{i}} \cdot \mathbf{b_{i}}=2 \pi \delta_{i
j}\left\{\begin{array}{l}
=2 \pi, i=j \\
=0, i \neq j
\end{array}, \quad(i, j=1,2,3)\right.\tag{1.5}
\]</span></p>
<h2 id="布洛赫函数">2.布洛赫函数</h2>
<p>布洛赫定理指出，当势场具有晶格周期性结构时，波动方程的解具有如下形势：
<span class="math display">\[
\psi\left(r+R_{n}\right)=e^{i \bar{k} \cdot R_{n}} \psi(r)\tag{2.1}
\]</span></p>
<p>其中<span class="math inline">\(\bar{k}\)</span>是简约波矢。</p>
<p><strong>下面给出证明：</strong></p>
<p>对于一个任意的函数<span
class="math inline">\(f(r)\)</span>,我们可以对其进行平移操作，平移算符为<span
class="math inline">\(T_\alpha\)</span> <span class="math display">\[
T_\alpha f(r) = f(r+\mathbf{a}_{\alpha}),\alpha = 1,2,3. \tag{2.2}
\]</span></p>
<p>显然对于三个正格矢方向的平移算符是相互对易的。现证明单电子的哈密顿量<span
class="math inline">\(H=
-\frac{\hbar^2}{2m}\nabla^2+V(r)\)</span>与平移算符对易</p>
<p><span class="math display">\[
\begin{align}
T_\alpha H f &amp;=
[-\frac{\hbar^2}{2m}\nabla^2_{r+\alpha_\alpha}+V(r+\alpha_\alpha)]f(r+\alpha_\alpha)\nonumber
\\
&amp;= [-\frac{\hbar^2}{2m}\nabla^2_r+V(r)]f(r+\alpha_\alpha)\nonumber
\\
&amp;= HT_\alpha f(r)\nonumber
\end{align}\tag{2.3}
\]</span></p>
<p>由量子力学的对易关系可知，哈密顿量和平移算符有着相同的本征态<span
class="math inline">\(\psi\)</span>。</p>
<p>又可根据波恩-卡曼条件有<span class="math inline">\(\psi\left(r+N_i
a_i\right)=\psi(r),(i=1,2,3)\)</span>.这里原胞总数<span
class="math inline">\(N= N_1N_2N_3\)</span>，<span
class="math inline">\(N_i\)</span>即沿基矢<span
class="math inline">\(a_i\)</span>方向数得的晶体中原胞个数。</p>
<p>假设<span class="math inline">\(T_1\)</span>算符的本征值为<span
class="math inline">\(\lambda_1\)</span>,那么<span
class="math inline">\(\lambda_1\)</span>需要满足 <span
class="math display">\[
\psi\left(r+N_{1} a_{1}\right)=T_{1}^{N_{1}} \psi(r)=\lambda_{1}^{N_{1}}
\psi(r)=\psi(r)\tag{2.4}
\]</span></p>
<p>即 <span class="math display">\[
\lambda _1^{N_1}=1
\]</span> 可得 <span class="math display">\[
\lambda_1=e^{2 i \pi \frac{l_1}{N_1}}
\]</span> 同理 <span class="math display">\[
\lambda_2=e^{2 i \pi \frac{l_2}{N_2}}
\]</span> <span class="math display">\[
\lambda_3=e^{2 i \pi \frac{l_3}{N_3} }
\]</span></p>
<p>记矢量<span class="math inline">\(\bar{k}\)</span>为 <span
class="math display">\[
\bar{k}=\frac{l_1}{N_1} \mathbf{b_1}+\frac{l_2}{N_2}
\mathbf{b_2}+\frac{l_3}{N_3} \mathbf{b_3}\tag{2.5}
\]</span> 其中<span
class="math inline">\(\mathbf{b_1}、\mathbf{b_2}、\mathbf{b_3}\)</span>为倒格矢，根据式（1.5）可以更加简洁得写出平移算符的本征值
<span class="math display">\[
\begin{align}
\lambda_1 = e^{i\mathbf{k}\cdot \mathbf{a_1}}\nonumber \\
\lambda_2 = e^{i\mathbf{k}\cdot \mathbf{a_2}}\nonumber \\
\lambda_3 = e^{i\mathbf{k}\cdot \mathbf{a_3}}\nonumber
\end{align} \tag{2.7}
\]</span>
因为H和T是对易的，所以式（2.7）也是哈密顿量的本征值，对于任意的晶格矢量<span
class="math inline">\(\mathbf{R}_m=m_1\mathbf{a_1}+m_2\mathbf{A_2}+m_3\mathbf{a_3}\)</span>有
<span class="math display">\[
\begin{align}
\psi\left(r+R_{m}\right) &amp; = T_1^{m_1} T_2^{m_2} T_3^{m_3}
\psi\left(r\right)\nonumber \\
&amp; =
\lambda_1^{m_1}\lambda_2^{m_2}\lambda_3^{m_3}\psi\left(r\right)\nonumber
\\
&amp; = e^{i \bar{k} \cdot R_{m}} \psi(r)\nonumber
\end{align}\tag{2.8}
\]</span> Q.E.D</p>
<p>我们现在定义一个新的函数<span class="math inline">\(u(r)\)</span>
<span class="math display">\[
u(r) = e^{-i \bar{k} \cdot r} \psi (r)\tag{2.9}
\]</span></p>
<p>对其进行任意的晶格平移操作有 <span class="math display">\[
\begin{align}
u\left(r+R_{m}\right) &amp; = e^{-i \bar{k} \cdot\left(r+R_{m}\right)}
\psi\left(r+R_{m}\right) \nonumber\\
&amp; = e^{-i \bar{k} \cdot\left(r+R_{m}\right)} e^{i \bar{k} \cdot
R_{m}} \psi(r)\nonumber \\
&amp; = e^{-i \bar{k} \cdot r} \psi(r) \nonumber\\
&amp; = u(r)\nonumber
\end{align}\tag{2.10}
\]</span></p>
<p>可见u(r)也是周期函数，周期与晶格周期一致。根据式（2.10）最后两行的等式，晶体中波函数应具有<span
class="math inline">\(\psi(r) =u(r)e^{i \bar{k} \cdot
r}\)</span>的形式。</p>
<p>该函数被称作布洛赫函数，它是平面波和周期函数的乘积。以布洛赫函数作为基函数来表示波函数称为布洛赫表象。</p>
<h2 id="瓦尼尔函数">3.瓦尼尔函数</h2>
<p>布洛赫函数在倒空间中具有周期性 <span class="math display">\[
\psi _k(\mathbf{r})=\psi _{ k+K }(\mathbf{r})\tag{3.1}
\]</span></p>
<p>瓦尼尔函数<span
class="math inline">\(a_n(\mathbf{r},\mathbf{l})\)</span>和布洛赫函数为实倒空间的傅里叶变换对：
<span class="math display">\[
a_n(\mathbf{r},\mathbf{l}) = N^{-1 / 2} \sum_{k \in B Z} e^{-i k \cdot
l} \psi_{n k}(\mathbf{r})\tag{3.2}
\]</span> <span class="math display">\[
\psi_{n k}(\mathbf{r})=N^{-1 / 2} \sum_{l} e^{i k \cdot l}
a_n(\mathbf{r},\mathbf{l})\tag{3.3}
\]</span> 其中l是正格矢。</p>
<p>对式（3.1）利用布洛赫定理有</p>
<p><span class="math display">\[
e^{-i k \cdot l} \psi_{n k}(\mathbf{r}) = \psi_{n
k}(\mathbf{r}-\mathbf{l})\tag{3.4}
\]</span> 又因为 <span class="math display">\[
a_{n}(r-l) \equiv N^{-1 / 2} \sum_{k \in B Z} \psi_{k}(r-l)\tag{3.5}
\]</span> 所以有 <span class="math display">\[
a_n(\mathbf{r},\mathbf{l}) = a_{n}(\mathbf{r}-\mathbf{l})
\]</span>
即瓦尼尔函数是一个矢量差(r-l)的函数。利用瓦尼尔函数作基函数表示波函数就构成了瓦尼尔表象。</p>
<h2 id="参考资料">4.参考资料</h2>
<p>[1] 李国旺. 傅里叶分析与正,倒格子的互易性[J]. 大学物理, 1993,
12(9):3.</p>
<p>[2] 知乎文章 <a
href="https://zhuanlan.zhihu.com/p/157273292">布洛赫定理和平面波展开</a></p>
<p>[3] 固体物理学 黄昆</p>
<p>[4] 固体理论 第二版 李正中</p>
<p>[5] 量子力学 曾谨言</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>物理</category>
      </categories>
      <tags>
        <tag>固体物理</tag>
        <tag>能带</tag>
      </tags>
  </entry>
  <entry>
    <title>能带理论-紧束缚近似与二次量子化表示</title>
    <url>/2022/04/28/2022-4/%E8%83%BD%E5%B8%A6%E7%90%86%E8%AE%BA-%E7%B4%A7%E6%9D%9F%E7%BC%9A%E8%BF%91%E4%BC%BC%E4%B8%8E%E4%BA%8C%E6%AC%A1%E9%87%8F%E5%AD%90%E5%8C%96%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>紧束缚近似的二次量子化哈密顿量表示</p>
<span id="more"></span>
<h2 id="近自由电子近似和紧束缚近似">1.近自由电子近似和紧束缚近似</h2>
<p>对于固体这样的多粒子体系，严格求解每个粒子的运动在目前的算力下是不可能的。</p>
<p>为此物理学家必须通过近似来简化问题，如近自由电子近似，它忽略了电子和电子、电子和晶格离子之间的相互作用，并认为电子是独立和自由的。这样周期性势场的起伏就会比较小，进而先计算零级近似的稳定场，再将周期起伏当作微扰来处理。</p>
<p>这种近似方法对金属来说效果不错，因为金属本身最外层电子的运动就比较自由，但对于其他固体，甚至是对金属内部的电子，来说近自由电子近似不是很合理。</p>
<p>而紧束缚近似的出发点是晶体中的原子间距较大，电子受到原子实的紧紧束缚，电子的运动不受到其他势场的影响。所以电子的行为会和孤立原子中电子的行为相似，这也是紧束缚近似也被称为原子轨道线性组合(LCAO)法的原因。</p>
<p><strong>近自由电子近似和紧束缚近似其实就是考虑了两种极端的近似。</strong></p>
<p>近自由电子近似有着原子核扰动(perturbation)，紧束缚近似有着原子间的跃迁(hopping).所以都会产生禁带和导带。近自由电子近似使用的是布洛赫表象，紧束缚近似使用的是瓦尼尔表象。</p>
<p>定量计算绝缘体、化合物、半导体等能带方面，紧束缚近似使用会较多。</p>
<h2 id="二次量子化">2.二次量子化</h2>
<p>一次量子化是将物理量变为了算符。</p>
<p>但对于全同粒子体系，使用坐标表象来表达和计算还是相当繁琐。因为数量比较多了，要给粒子编号。</p>
<p>实际上我们并不关心每一个粒子的状态，要计算的是体系的状态，所以只需要标记出一单粒子态上有多少粒子数就足够了。</p>
<p>所以物理学家给量子力学打了个补丁叫二次量子化，引入了产生算符和湮灭算符。</p>
<p><span class="math display">\[
产生算符: c^{\dagger}\\
湮灭算符: c
\]</span></p>
<p>对于产生和湮灭算符，他们也可在实空间和倒空间进行傅里叶级数展开：</p>
<p><span class="math display">\[
\begin{aligned}
c_{r} &amp;=\frac{1}{\sqrt{N}} \sum_{k} c_{k} e^{i k r} \\
c_{k} &amp;=\frac{1}{\sqrt{N}} \sum_{r} c_{i} e^{-i k r}
\end{aligned} \tag{1}
\]</span></p>
<p>根据傅里叶级数基底的正交性，又有</p>
<p><span class="math display">\[
\begin{aligned}
\frac{1}{N} \sum_{k} e^{i k r} e^{-i k r^{\prime}}=\delta_{r r^{\prime}}
\\
\frac{1}{N} \sum_{r} e^{i k r} e^{-i k^{\prime} r}=\delta_{k k^{\prime}}
\end{aligned} \tag{2}
\]</span></p>
<h2
id="紧束缚近似下的二次量子化方法表示晶体哈密顿量">3.紧束缚近似下的二次量子化方法表示晶体哈密顿量</h2>
<p>晶体的哈密顿量通常由动能势能和晶格间的相互作用能表示，在紧束缚近似下，晶格间相互作用和动能统一考虑为运动项，即跳跃能（hopping），而势能项（在位能
on site
energy）没有太大意义，单纯只是增加一个常数。所以可以将哈密顿量写成如下形式。</p>
<p><span class="math display">\[
H=\sum_{\langle i, j\rangle} t_{i j} c_{i}^{\dagger} c_{j} \tag{3}
\]</span></p>
<p>其中i和j表示不同的晶格，t是跳变参数，&lt;&gt;表示近邻项,虽然远距离跃迁是可以的，但概率比较低，可以选择忽略。两个原子间的相互跃迁在数值上是共轭对，实际上写出一半即可。</p>
<p>下面用紧束缚模型下的二次量子化的方法来计算一下一维双原子链模型：</p>
<p>先写出哈密顿量的表达式</p>
<p><span class="math display">\[
H=-t \sum_{n}\left(a_{n}^\dagger b_{n} + b_{n}^\dagger a_{n+1} + h . c
.\right)+V_{a} \sum_{n} a_{n}^\dagger a_{n}+V_{b} \sum_{n} b_{n}^\dagger
b_{n}\tag{4}
\]</span></p>
<p>第一项是动能项，电子在a，b位置间的跳跃，其中t是常数。后两项是在a或b点的势能，也是常数。h.c.是厄米共轭项。</p>
<p>现计算第一项：</p>
<p><span class="math display">\[
\begin{aligned}
-t \sum_{n} a_{n}^\dagger b_{n} &amp;=-t \frac{1}{N}
\sum_{n}\left(\sum_{k} a_{k}^\dagger e^{-i k
r_{a}}\right)\left(\sum_{k^{\prime}} b_{k^{\prime}} e^{i k^{\prime}
r_{b}}\right) \\
&amp;=-t \frac{1}{N} \sum_{n} \sum_{k} \sum_{k^{\prime}} a_{k}^\dagger
b_{k^{\prime}} e^{-i k r_{a}} e^{i k^{\prime} r_a }e^{i
k^{\prime}(r_b-r_a)}\\
&amp;=-t \sum_{k} \sum_{k^{\prime}} a_{k}^\dagger b_{k^{\prime}}
e^{ik^{\prime} (r_{b}-r_{a})} \delta_{k k^{\prime}} \\
&amp;=-t \sum_{k} a_{k}^\dagger b_{k} e^{i k\left(r_{b}-r_{a}\right)}
\end{aligned}\tag{5}
\]</span></p>
<p>同理可得 <span class="math display">\[
-t \sum_{n} b_{n}^\dagger a_{n+1} = -t \sum_{k} b_{k}^\dagger a_{k} e^{i
k\left(r_{a}-r_{b}\right)}\tag{6}
\]</span></p>
<p>假设晶格常数为a，则其中<span class="math inline">\(r_b-r_a =
\frac{a}{2}\)</span></p>
<p>对势能项有：</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{n} a_{n}^\dagger a_{n} &amp;=\frac{1}{N}\sum_{n}\left(\sum_{k}
a_{k}^\dagger e^{-i k r_{a}}\right)\left(\sum_{k^{\prime}}
a_{k^{\prime}} e^{i k^{\prime} r_{a}}\right) \\
&amp;=\frac{1}{N}\sum_{n} \sum_{k} \sum_{k^{\prime}} a_{k}^\dagger
a_{k^{\prime}} e^{i r_{a}\left(k^{\prime}-k\right)} \\
&amp;=\sum_{k} a_{k}^\dagger a_{k}
\end{aligned}\tag{7}
\]</span></p>
<p>将所有项代入式(4)</p>
<p><span class="math display">\[
\begin{aligned}
H &amp;=-t \sum_{n}\left(a_{n}^\dagger b_{n}+b_{n}^\dagger a_{n+1}+h . c
.\right)+V_{a} \sum_{n} a_{n}^\dagger a_{n}+V_{b} \sum_{n} b_{n}^\dagger
b_{n} \\
&amp;=\sum_{k}\left(\left(-2 t \cos \left(\frac{k a}{2}\right)\right)
a_{k}^\dagger b_{k}+\left(-2 t \cos \left(\frac{k a}{2}\right)\right)
b_{k}^\dagger a_{k}+V_{a} a_{k}^\dagger a_{k}+V_{b} b_{k}^\dagger
b_{k}\right) \\
&amp;=\sum_{k}\left[a_{k}^\dagger
b_{k}^\dagger\right]\left[\begin{array}{cc}
V_{a} &amp; -2 t \cos \left(\frac{k a}{2}\right) \\
-2 t \cos \left(\frac{k a}{2}\right) &amp; V_{b}
\end{array}\right]\left[\begin{array}{l}
a_{k} \\
b_{k}
\end{array}\right]
\end{aligned}\tag{8}
\]</span></p>
<p>其中 <span class="math display">\[
\left[\begin{array}{cc}
V_{a} &amp; -2 t \cos \left(\frac{k a}{2}\right) \\
-2 t \cos \left(\frac{k a}{2}\right) &amp; V_{b}
\end{array}\right]\tag{9}
\]</span></p>
<p>即为一维双原子链的哈密顿量的核，该矩阵的大小由选取的量子态数量决定，该矩阵的特征值求出该矩阵的特征值就可以得到一维双原子链的色散关系。</p>
<p>使用python求出矩阵的特征值并绘制色散曲线如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">def h(k):</span><br><span class="line">    h0 = np.zeros((2, 2), dtype=complex)</span><br><span class="line"></span><br><span class="line">    h0[0,0] = 1</span><br><span class="line">    h0[1,1] = 2</span><br><span class="line">   </span><br><span class="line">    h0[0,1] = -2*t*np.cos(k/2)</span><br><span class="line">    h0[1,0] = h0[0,1]</span><br><span class="line"></span><br><span class="line">    return h0</span><br><span class="line"></span><br><span class="line">t = 1.5</span><br><span class="line">la = 1</span><br><span class="line">n_step = 100</span><br><span class="line">k = np.linspace(-np.pi/la, np.pi/la, n_step)</span><br><span class="line">eig = np.zeros((n_step, 2))</span><br><span class="line">for x in range(n_step):</span><br><span class="line">    kx = k[x]</span><br><span class="line">    ham = h(kx)</span><br><span class="line">    eig[x,:], vet = np.linalg.eigh(ham)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.plot(k, eig[:,0], &#x27;-b&#x27;)</span><br><span class="line">plt.plot(k, eig[:,1], &#x27;-r&#x27;)</span><br><span class="line">plt.xlim([-np.pi/la, np.pi/la])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210202525.png"
alt="一维双原子链色散关系" />
<figcaption aria-hidden="true">一维双原子链色散关系</figcaption>
</figure>
<h2 id="参考资料">4.参考资料</h2>
<p>[1] 知乎问题 <a
href="https://www.zhihu.com/question/65367733">固体物理中，紧束缚近似与近自由近似的区别是什么？</a></p>
<p>[2] 知乎文章 <a
href="https://zhuanlan.zhihu.com/p/115039117">利用傅里叶变换求解能带</a></p>
<p>[3] 知乎文章 <a
href="https://zhuanlan.zhihu.com/p/115039117">固体物理相关的小计算</a></p>
<p>[3] 固体物理学 黄昆</p>
<p>[4] 固体理论 第二版 李正中</p>
<p>[5] 量子力学 曾谨言</p>
<p>[6] <a
href="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/non-image/chapter5.pdf">Phys620
Topological insulators Part III: tight-binding models</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>物理</category>
      </categories>
      <tags>
        <tag>固体物理</tag>
        <tag>能带</tag>
        <tag>量子力学</tag>
      </tags>
  </entry>
  <entry>
    <title>雅思考试大作文</title>
    <url>/2022/04/11/2022-4/%E9%9B%85%E6%80%9D%E8%80%83%E8%AF%95%E5%A4%A7%E4%BD%9C%E6%96%87/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>学习笔记</p>
<span id="more"></span>
<p>趁着论文刚投完的空隙，把大作文也总结了。再过几天指不定就忘光了。</p>
<h2 id="介绍">1.介绍</h2>
<p>雅思考试的写作模块要求在1个小时内完成2篇作文(Task1和Task2)，分别要求150字以上和250字以上。时间分配大概是20分钟和40分钟。</p>
<p>其中大作文即task2，题目一般会给出一个有讨论意义的话题，需要考生就这个话题发表自己的观点，并给予合理的解释或解决方案。</p>
<p>大作文可以分为3个大类型，Argue类、Report类和混合类。接下来按顺序依次次总结。</p>
<h2 id="argue类">2.Argue类</h2>
<h3 id="细分介绍">2.1 细分介绍</h3>
<p>Argue类题目可以分为三个小类： 1. 同意与否题 -- agree &amp; disagree
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标志性语句</span><br><span class="line">To what extent do you agree or disagree with this opinion/statement?</span><br><span class="line">To what extent do you think ...?</span><br></pre></td></tr></table></figure> 2. 优缺点题 -- advantage &amp; disadvantage <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标志性语句</span><br><span class="line">Do you think the advantages of .. outweigh the disadvantages?</span><br><span class="line">Do you think it is a positive or negative ..?</span><br></pre></td></tr></table></figure>
3. 讨论题 -- dicuss <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标志性语句</span><br><span class="line">Discuss both these views</span><br></pre></td></tr></table></figure>
其中讨论题要求两个观点字数要达到平衡，其他两类不做要求。</p>
<h3 id="段落划分">2.3 段落划分</h3>
<p>针对Argue类题目，这里给出一个通用段落划分方法，假设我支持观点A，全文共四段内容可按照如下来写：</p>
<ol type="1">
<li>第一段：开头段，背景介绍引出观点（50字）</li>
<li>第二段：观点A +（论点+展开+对比/举例）*1/2（80字）</li>
<li>第三段：观点B +（论点+展开+对比/举例+反驳）*1/2（80字）</li>
<li>第四段：结尾段，重申支持的论点论据 （50字）</li>
</ol>
<p>划分完成后按逐段介绍该如何写。</p>
<h3 id="写作细节">2.4 写作细节</h3>
<h4 id="第一段开头段">2.4.1 第一段：开头段</h4>
<p>开头段主要是做背景铺垫字数要求也不高，通常高手不会在第一段展示自己的观点，对于四段式因为第二段、第三段开头需要有一句观点句，所以在开头段也不表示观点，避免重复表达。</p>
<p>俗话说的好，万事开头难。所以在开头这里给出几个写第一句话的诀窍。可以从四个角度来写
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下定义；表因果；举例子；做比较</span><br></pre></td></tr></table></figure> 以如下题目为例展示一下如何使用这四个方法 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sample task:</span><br><span class="line">The typical teaching situation of a teacher and students</span><br><span class="line">in a classroom will not exist by the year 2050.</span><br><span class="line">To what extent do you agree or disagree with the statement?</span><br></pre></td></tr></table></figure>
这是一道同意与否题，开头段可以按如下方法写：</p>
<p>1.下定义</p>
<p>对题中的主题名词作一个解释。</p>
<p>Traditional education is that teachers and students are in the same
classroom,and teachers give knowledge to students by telling or
demonstration.They can see and even touch each other, and of course
teacher can name the students.However, some people believe that under
the impact of the Internet, traditional education will no longer exist
by the 2050.</p>
<p>2.表因果</p>
<p>顺着题目思路展示因果关系</p>
<p>With the development of Internet, a rising number of distance
learning courses are impacting traditional education. This can not help
but make people doubt whether typical education is still necessary. Some
people hold the idea that traditional education will no longer exist by
the 2050.</p>
<p>3.举例子</p>
<p>举出题目中抽象事物的列子</p>
<p>这里可以举出网络教育的出现，介绍一下什么是网络教育。就不写成英语了。</p>
<p>4.做比较</p>
<p>对比主要有古今对比，男女对比之类的。</p>
<p>我个人比较擅长写对比，但前面两段写的我已经有点词穷了，写出的内容大概率和前面的重复，这里给出中文思路供参考。</p>
<p>在过去，人们都是接受的老师学生在一个教室里的传统教育，但是在当今社会，有各种新事物改变着教育行业。互联网的发展让网课走进人们的视野，凭着许多优势，网课被人们寄予了取代传统课程的厚望。甚至有部分人认为到2050年传统课程就会不复存在。</p>
<h4 id="中间段">2.4.2 中间段</h4>
<h5 id="论点提纲">2.4.2.1 论点/提纲</h5>
<p>中间段需要进行论点分析，为此我们应当在写之前列好一个提纲，这里还涉及到一个跑题问题，但本文不做重点。</p>
<p>以样题为例，同意与否题的提纲分为同意和不同意两个观点，传统教育会消失这一观点可以引申为网络教育会取代传统教育。</p>
<p>样式可以参考下方表格。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">传统教育</th>
<th style="text-align: center;">展开</th>
<th style="text-align: center;">网络教育</th>
<th style="text-align: center;">展开</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">直接交流</td>
<td style="text-align: center;">面对面/友谊/社交</td>
<td style="text-align: center;">方便</td>
<td style="text-align: center;">随时随地</td>
</tr>
<tr class="even">
<td style="text-align: center;">竞争</td>
<td style="text-align: center;">学习动力</td>
<td style="text-align: center;">便宜</td>
<td style="text-align: center;">电子资料/一对多</td>
</tr>
<tr class="odd">
<td style="text-align: center;">设施</td>
<td style="text-align: center;">图书馆/操场</td>
<td style="text-align: center;">安全</td>
<td style="text-align: center;">不用出门/校园暴力</td>
</tr>
<tr class="even">
<td style="text-align: center;">习惯</td>
<td style="text-align: center;">约束力/自律</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>对于论点的积累，需要平时的时候多攒点素材。二三段是可以交换顺序的，所以放在一起讲。</p>
<h5 id="展开">2.4.2.2 展开</h5>
<p>有了论点后再看展开。展开论点需要写一到两句话，是对论点的进一步描述，这里也是一个很好的长难句展示机会。</p>
<p>展开思路可以分为四个方面思考 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">why 为什么会有这个好处</span><br><span class="line">how </span><br><span class="line">what</span><br><span class="line">so what</span><br></pre></td></tr></table></figure></p>
<h5 id="举例对比">2.4.2.3 举例/对比</h5>
<p>这里的写法是越具体越准确越好。这样更有说服力，举例最好能提到名字，像环境类的题，说环境问题会引起健康，然后可以举几个常见的慢性病。</p>
<p>对比也是，比如男女谁更适合照护孩子话题，说女生更适合，女生小时候就玩过家家有这方面的天赋，相比而言男生只会打仗之类的游戏。</p>
<h5 id="反驳">2.4.2.4 反驳</h5>
<p>这是比较关键的点，有了反驳才能体现出你支持的观点。不然就感觉是骑墙派。不是说无观点不行，但一般人hold不住。</p>
<p>反驳基本上一到两句话放在段末就可以了，不需要太多。</p>
<p>反驳好处的方法 1. 缩小范围 1. 表示好处影响范围有限 2.
如网课虽好，但它只是适合有自律能力的人 2. 过犹不及 1. 表示太好了也不好
2. 如女生来带娃，照护的太好会宠坏孩子 3. 取而代之 1.
有其他东西可以取代这个好处 2. 如电子书可以代替学校图书馆</p>
<p>反驳坏处的方法</p>
<p>一般优缺点问题才有说坏处的，为了一贯性我仍然以传统教育为例子，题目为分析传统教育的优缺点。</p>
<ol type="1">
<li>解决
<ol type="1">
<li>直接提出解决这个缺点的方法</li>
<li>如传统教育成本高，可以用政府义务教育解决</li>
</ol></li>
<li>不重要
<ol type="1">
<li>强行表示这一论点不重要，不建议使用</li>
<li>如传统教育不能随时随地，反驳只不过多了去学校的步骤罢了</li>
</ol></li>
</ol>
<h4 id="结尾段">2.4.3 结尾段</h4>
<p>结尾段重申一下支持的立场和论点。可以参考如下格式。</p>
<p>To sum up,立场,especially when 论点一 and 论点2 are taken into
consideration.</p>
<p>例</p>
<p>To sum up, conventional education can never be replaced and it is the
best choice for most student, especially when commuication and
additional facilities are taken into consideration.</p>
<h2 id="report类">3.Report类</h2>
<h3 id="细分介绍-1">3.1 细分介绍</h3>
<p>Report类可以分为三个小问分别为： 1. reason 1. What do you think are
the resons for this? 2. why is the case? 2. result 1. What are the
effects ..? 3. solution 1. What can we do to ..? 2. Should the ... do
...? 3. measures</p>
<p>然后有<span class="math inline">\(C_3^2 =
3\)</span>个组合,一般问result比较少，都是问原因+解决方案。</p>
<h3 id="段落分配">3.2 段落分配</h3>
<p>和上面的基本一致</p>
<p>中间两段改为题目问题的内容即可，写的方法不变。</p>
<p>第一段：开头段 第二段：问题一 第三段：问题二 第四段：结尾段</p>
<p>下面给出几句过渡句 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">引出原因：Personally, multiple factors contribute to this phenomenon.</span><br><span class="line">引出结果：Personally, this phenomenon can contribute to multiple results.</span><br><span class="line">引出解决：Personally, this phenomenon can be solved by mutiple methods.</span><br></pre></td></tr></table></figure></p>
<p>下面给出结尾段模板</p>
<p>To sum up, there are definitely many problems about + 问题.
Fortunately, these problems canbe addressed through
...(老师/政府/工厂/媒体) 的努力.</p>
<h2 id="混合类">4.混合类</h2>
<p>混合类即为argue和report问题混合着问，比如现在许多年轻人频繁更换工作，你认为是什么原因导致的？这样做是否坏处大于好处？</p>
<p>属于换汤不换药问法，直接问什么答什么。然后argue捏成一段不需要写反驳。</p>
<h2 id="结束语">5.结束语</h2>
<p>文章内容大部分出自考虫雅思王瑗老师的课程，本文仅作为学习笔记，并不能系统学习雅思写作。</p>
<p>本来考虑加点范文或者是长难句写法进去，但一想我的垃圾英语水平还是别拿出来丢人了，我感觉写个大纲都不能写的好。这个疫情形势估计这个季度都报不上雅思了，只能希望以后自己如果需要考雅思看见这个还能回忆起点内容。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>雅思</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统命令(备忘录)</title>
    <url>/2022/06/13/2022-6/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4(%E5%A4%87%E5%BF%98%E5%BD%95)/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>Linux系统命令备忘录</p>
<span id="more"></span>
<h2 id="展示目录内容">1.展示目录内容</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -a：显示所有文件（包括隐藏文件）；</span><br><span class="line">Linux中以.开头的文件是隐藏文件；</span><br><span class="line">ls -l：显示详细信息；</span><br><span class="line">ls -R：递归显示子目录结构；</span><br><span class="line">pwd:显示当前目录</span><br></pre></td></tr></table></figure>
<h2 id="创建工作区和虚拟环境">2.创建工作区和虚拟环境</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export MY_PATH=&quot;$HOME/ml&quot; </span><br></pre></td></tr></table></figure>
<p>将路径HOME/ml取名为MY_PATH</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p MY_PATH</span><br></pre></td></tr></table></figure>
<p>建立多级文件目录，当前目录下创建可以不加p</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install --user --upgrade virtualenv</span><br></pre></td></tr></table></figure>
<p>安装虚拟环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virtualenv env --python=3.6</span><br></pre></td></tr></table></figure>
<p>在当前目录下创建虚拟环境名字为env,python版本为3.6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source env/bin/activate</span><br></pre></td></tr></table></figure>
<p>启动虚拟环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>
<p>退出虚拟环境</p>
<h2 id="创建编辑文本">3.创建编辑文本</h2>
<h3 id="文件夹与文件">3.1 文件夹与文件</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir 文件夹名称：创建文件夹；</span><br><span class="line">rmdir 文件夹名称：删除文件；</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch 文件名：创建文件（要加后缀）</span><br><span class="line">rm 文件名：删除文件</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv a.txt b.txt ：重命名</span><br><span class="line">mv a.txt ../ ：移动到上层</span><br><span class="line">cp 源文件路径  目标文件路径：复制到 </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim 文件名：如果目标文件存在，则vim打开目标文件，如果目标文件不存在，则vim新建并打开该文件。</span><br></pre></td></tr></table></figure>
<h3 id="vim模式">3.2 VIM模式</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim拥有三种模式</span><br><span class="line">（1）命令模式（常规模式）</span><br><span class="line">vim启动后，默认进入命令模式，任何模式都可以通过esc键回到命令模式（可以多按几次），命令模式下可以键入不同的命令完成选择、复制、粘贴、撤销等操作。</span><br><span class="line">命名模式常用命令如下：</span><br><span class="line">i : 在光标前插入文本；</span><br><span class="line">o:在当前行的下面插入新行；</span><br><span class="line">dd:删除整行；</span><br><span class="line">yy：将当前行的内容放入缓冲区（复制当前行）</span><br><span class="line">n+yy :将n行的内容放入缓冲区（复制n行）</span><br><span class="line">p:将缓冲区中的文本放入光标后（粘贴）</span><br><span class="line">u：撤销上一个操作</span><br><span class="line">r:替换当前字符</span><br><span class="line">/ 查找关键字</span><br><span class="line"></span><br><span class="line">（2）插入模式</span><br><span class="line">在命令模式下按 &quot; i &quot;键，即可进入插入模式，在插入模式可以输入编辑文本内容，使用esc键可以返回命令模式。</span><br><span class="line"></span><br><span class="line">（3）底部输入模式</span><br><span class="line">在命令模式中按&quot; : &quot;键可以进入底部输入模式，光标会移动到底部。</span><br><span class="line">底部输入模式常用命令如下：</span><br><span class="line">:w          ：保存当前的修改</span><br><span class="line">:q          ：退出</span><br><span class="line">:q!         ：强制退出，保存修改</span><br><span class="line">:x          : 保存并退出，相当于:wq</span><br><span class="line">:set number : 显示行号</span><br><span class="line">:!          : 系统命令  执行一个系统命令并显示结果</span><br><span class="line">:sh         ：切换到命令行，使用ctrl+d切换回vim</span><br></pre></td></tr></table></figure>
<h2 id="wsl-ubuntu相关">4.WSL ubuntu相关</h2>
<h3 id="文件管理">4.1 文件管理</h3>
<p>如果使用的是WSL，文件位置可以在资源管理器中输入<code>\\wsl$</code>获知。</p>
<h3 id="重置密码">4.2 重置密码</h3>
<ol type="1">
<li>关闭Ubuntu窗口</li>
<li>打开Powershell 或 cmd， 以root默认登陆
<code>wsl -u root</code>。</li>
<li>输入 <code>passwd your_username</code></li>
<li>重新修改并确认密码。</li>
<li>exit退出</li>
<li>重启Ubuntu窗口</li>
</ol>
<h2 id="不中断运行">5.不中断运行</h2>
<p>通常会使用ssh连接Linux系统，而且运行时间会很长，所以想要让服务器在退出远程后继续跑任务就可以选择下面两种方法。</p>
<h3 id="nohup">5.1 nohup</h3>
<p>nohup意思是no hang up，不挂断运行</p>
<p>主要命令如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jobs   查看任务的状态、任务号和进程pid</span><br><span class="line">kill %num  杀死对应任务</span><br><span class="line">nohup mpirun -np 6 vasp_std &amp; 不挂断运行vasp</span><br><span class="line">tail -f nohup.out 查看输出文件</span><br></pre></td></tr></table></figure>
<h3 id="screen">5.2 screen</h3>
<p>screen相当于多开了一个窗口，有点新建一个终端会话。</p>
<p>使用前需要安装 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># centos</span><br><span class="line">yum install -y screen</span><br><span class="line"># ubuntu</span><br><span class="line">apt install -y screen</span><br></pre></td></tr></table></figure></p>
<p>使用方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个名为MinecraftServer的screen</span><br><span class="line">screen -S MinecraftServer</span><br><span class="line"></span><br><span class="line"># 查看当前的screen列表</span><br><span class="line">screen -ls</span><br><span class="line"></span><br><span class="line"># 挂起当前screen</span><br><span class="line">Ctrl + A + D</span><br><span class="line"></span><br><span class="line"># 将number编号的screen放到前台</span><br><span class="line">screen -r number</span><br><span class="line"></span><br><span class="line"># 杀死当前screen</span><br><span class="line">Ctrl + A + K</span><br><span class="line">或</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<p>[1] <a
href="https://blog.csdn.net/l1028386804/article/details/117917710">全网最全Linux命令总结！！（史上最全，建议收藏）</a></p>
<p>[2] <a
href="https://zhuanlan.zhihu.com/p/57725724">Linux下的nohup和screen</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>密度泛函理论-Hatree-Fock方法</title>
    <url>/2022/06/13/2022-6/%E5%AF%86%E5%BA%A6%E6%B3%9B%E5%87%BD%E7%90%86%E8%AE%BA_Hatree_Fock%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>Hatree-Fock方法的导出</p>
<span id="more"></span>
<h2 id="薛定谔方程">1. 薛定谔方程</h2>
<p>量子力学这门课其实就干了一件事情--解薛定谔方程。</p>
<p>通过求解薛定谔方程我们就可以知道微观粒子的运动，起码是运动概率。就相当于我们求解牛顿方程就可以在经典世界得到物体的运动规律。</p>
<p>下面简单复习下薛定谔方程的推导。</p>
<p>按照德布罗意物质波理论，粒子可以写成波函数的形式，简化起见，先来看一个能量为E动量为p自由粒子，按照德布罗意关系，角频率<span
class="math inline">\(\omega\)</span>和波矢<span
class="math inline">\(\boldsymbol{k}\)</span>由下式给出</p>
<p><span class="math display">\[
\omega=E / \hbar, \quad \boldsymbol{k}=\boldsymbol{p} / \hbar
\]</span></p>
<p>我们先看一个简单的平面单色波，因为复杂的波函数也是许多平面波的叠加,作为一个线性系统其结果应该满足和单色波结果一致。</p>
<p><span class="math display">\[
\begin{align}
\psi (\mathbf{r},t ) &amp; = exp[i(\mathbf{k\cdot r} -\omega
t)]\nonumber\\
&amp;= exp[i(\mathbf{p \cdot r}-Et )/\hbar ]\nonumber
\end{align}\tag{1}
\]</span></p>
<p>将上式分别对时间和空间求导有</p>
<p><span class="math display">\[
i\hbar \frac{\partial }{\partial t} \psi = E \psi  \tag{2}
\]</span></p>
<p><span class="math display">\[
-i\hbar \nabla  \psi = \mathbf{p}  \psi \tag{3}
\]</span></p>
<p><span class="math display">\[
-\hbar ^2 \nabla ^2 \psi = \mathbf{p}^2  \psi \tag{4}
\]</span></p>
<p>对自由粒子来说<span
class="math inline">\(E=\frac{1}{2}mc^2=\mathbf{p}^2/2m\)</span>
再结合式(2)(3)所以有 <span class="math display">\[
i\hbar \frac{\partial }{\partial t} \psi = -\frac{\hbar ^2 \nabla
^2}{2m} \psi \tag{5}
\]</span></p>
<p>如果加上势场，能量为<span
class="math inline">\(E=\mathbf{p}^2/2m+V\)</span>就可以得到薛定谔提出的薛定谔方程
<span class="math display">\[
i \hbar \frac{\partial }{\partial t}\psi(\mathbf{r},t
)=\left[-\frac{\hbar^{2}}{2 m} \nabla^{2}+V\right] \psi(\mathbf{r},t
)\tag{6}
\]</span></p>
<h2 id="多粒子系统的简化">2. 多粒子系统的简化</h2>
<p>薛定谔方程确实很好用，但人类是有极限的。只有少数体系能求解出解析解，就算是数值解，目前计算机也无法实现计算。</p>
<p>究其原因，作为一个多粒子体系，电子和电子之间，电子和原子核之间，原子核和原子核之间都存在相互作用，又两者又分别有动能和势能。哈密顿量写出来就是老长一串。看着就头大，根本不好计算。</p>
<p>为此物理学家得先进行<del>偷懒</del>化简。</p>
<h3 id="玻恩-奥本海默近似bo近似">2.1 玻恩-奥本海默近似（BO近似）</h3>
<p>由于原子核比电子重得多，电子运动速度比核快得多，因此我们可以假设电子运动时，原子核是固定的，从而将核与电子的运动分开考虑。多粒子系统的哈密顿量可以写为
<span class="math display">\[
\hat{H} = \hat{T} + \hat{V}_{ne}+\hat{V}_{ee}  \tag{7}
\]</span>
第一项为电子的动能，下标ne和ee分别表示核-电子和电子-电子相互作用。这样波函数就简化了不少。</p>
<h3 id="hatree近似">2.2 Hatree近似</h3>
<p>上面的多粒子体系的哈密顿量最复杂的项是第三项，电子间的相互作用。正是因为有了这一项，我们不能把方程分离成一系列独立的单粒子方程。</p>
<p>起初哈特里将电子对某一电子i的库伦作用用平均场方法来处理，即用平均场代替电子与电子间的相互作用。这样式(7)第三项可以和第二项合并其薛定谔方程和单粒子薛定谔方程一致，大大简化了计算。</p>
<p>同时Hatree提出电子系统的波函数可以看作多个单电子波函数的连续乘积。并且其中涉及到单电子波函数全用迭代自洽的方法解决，所以被叫做自洽场方法(SCF)。</p>
<p>该方法在概率论方面也容易理解，相当于把电子的出现概率看作是独立的事件。</p>
<h3 id="斯莱特行列式slater行列式">2.3 斯莱特行列式（Slater行列式）</h3>
<p>哈特里的方法简单但是缺乏准确性。多电子体系是全同的费米子体系，量子力学要求其波函数具有交换反对称性，即如果两电子交换坐标，波函数应该反号。下面以氦原子为例给出推导证明。</p>
<p>氦原子是双电子体系，其哈密顿量为</p>
<p><span class="math display">\[
H = \mathbf{p}_1^2/2m +  \mathbf{p}_2^2/2m-\frac{2e^2}{r_1}
-\frac{2e^2}{r_2} +\frac{e^2}{\left | \mathbf{r_1} -\mathbf{r_2}  \right
| } \tag{8}
\]</span></p>
<p>易得当两个电子交换时，哈密顿量不变，可见哈密顿量算符和交换算符具有对易关系：</p>
<p><span class="math display">\[
[H,P_{12}] = 0 \tag{9}
\]</span></p>
<p>所以将交换算符作用在电子波函数<span
class="math inline">\(\psi\)</span>上有</p>
<p><span class="math display">\[
P_{12} \psi = \lambda \psi \tag{10}
\]</span></p>
<p>再作用一次有</p>
<p><span class="math display">\[
P^2_{12} \psi = \lambda^2 \psi \tag{11}
\]</span></p>
<p>对易算符作用两次等于本身，所以有<span
class="math inline">\(\lambda=\pm 1\)</span></p>
<p>这表明两个粒子进行交换，波函数必须是对称或者是反对称的。恰巧实验证明，交换对称的粒子符合Bose统计，所以称为玻色子，反对称的粒子符合fermi统计，所以称为费米子。</p>
<p>对于费米子（如电子，质子，中子，这里是氦的两个电子）归一化对称波函数可以构建如下</p>
<p><span class="math display">\[
\begin{align}
\psi ^A_{k_1k_2}(q_1,q_2) &amp; =
\frac{1}{\sqrt[]{2}}(1-P_{12})\varphi_{k_1}(q_1)\varphi_{k_2}(q_2)\nonumber\\
&amp;=
\frac{1}{\sqrt[]{2}}[\varphi_{k_1}(q_1)\varphi_{k_2}(q_2)-\varphi_{k_1}(q_2)\varphi_{k_2}(q_1)]\nonumber\\
&amp;= \frac{1}{\sqrt{2}} \begin{vmatrix}
\varphi_{k_1}(q_1) &amp; \varphi_{k_2}(q_1)\\
\varphi_{k_1}(q_2) &amp; \varphi_{k_2}(q_2)
\end{vmatrix}\nonumber
\end{align}\tag{12}
\]</span></p>
<p>可以看出利用行列式的方法很好的处理了反对称问题，一旦两个电子交换坐标，相当于行列式的交换了两行，行列式的值取个负号。如果有两个电子坐标相同，行列式值为0，表明状态不存在，这就是泡利不相容原理。（不能有两个全同费米子处于同一个单粒子态）</p>
<p>将这个行列式推广到N个粒子就是斯莱特行列式</p>
<p><span class="math display">\[
\psi=\frac{1}{\sqrt{N !}}\left|\begin{array}{cccc}
\varphi_{1}\left(q_{1}\right) &amp; \varphi_{2}\left(q_{1}\right) &amp;
\ldots &amp; \varphi_{N}\left(q_{1}\right) \\
\varphi_{1}\left(q_{2}\right) &amp; \varphi_{2}\left(q_{2}\right) &amp;
\ldots &amp; \varphi_{N}\left(q_{2}\right) \\
\ldots &amp; \ldots &amp; \ldots &amp; \ldots \\
\varphi_{1}\left(q_{N}\right) &amp; \varphi_{2}\left(q_{N}\right) &amp;
\ldots &amp; \varphi_{N}\left(q_{N}\right)
\end{array}\right|\tag{13}
\]</span></p>
<h3 id="hatree-fork方法">2.4 Hatree-Fork方法</h3>
<p>针对Hatree近似的不准确性，福克就采用了斯莱特行列式来表示整个电子体系的波函数。这和Hatree近似一样，将多粒子体系变成了单电子系统。</p>
<p>下面给出哈特里-福克方程的推导。</p>
<p>首先能量E的平均值<span class="math inline">\(\left \langle E \right
\rangle\)</span>计算公式如下 <span class="math display">\[
E = \left \langle E \right \rangle =\int \psi  ^* \hat{H} \psi d \tau
=   \left \langle \psi \left | \hat{H} \right | \psi  \right \rangle
\tag{14}
\]</span></p>
<p>其中波函数<span
class="math inline">\(\psi\)</span>可以用斯莱特行列式表示，哈密顿量与式(7)相同，对于有N个电子和M个核的系统展开为</p>
<p><span class="math display">\[
\hat{H} = -\sum_{i=1}^{N}  \frac{1}{2} \nabla ^2_i - \sum_{i=1}^{N}
\sum_{A=1}^{M} \frac{Z_A}{ r_{iA} }+\sum_{i=1}^{N} \sum_{j&gt;i}^{N}
\frac{1}{ r_{ij} } \tag{15}
\]</span></p>
<p>其中<span
class="math inline">\(\nabla\)</span>是拉普拉斯算符，r为粒子间的距离。</p>
<p>将式(13)(15)代入(14)就可以得到N电子系统的能量<span
class="math inline">\(E_{HF}\)</span></p>
<p>为了有更直观的体验，我们还是以二电子系统为例推导一下。</p>
<p><span class="math display">\[
E=\left\langle\psi\left|H_{1}\right|
\psi\right\rangle+\left\langle\psi\left|H_{2}\right|
\psi\right\rangle+\left\langle\psi\left|H_{12}\right| \psi\right\rangle
\tag{16}
\]</span></p>
<p>前两项分别是单电子的哈密顿量，即包含单电子的动能和势能的哈密顿量。最后一项代表了两个电子相互作用项，展开如下：</p>
<p><span class="math display">\[
\begin{align}
\left\langle\psi\left|H_{12}\right| \psi\right\rangle &amp; = \iint d
r_{1} d r _{2} \frac{1}{\sqrt{2}}\left[\varphi_{1}^{*}\left(q_{1}\right)
\varphi_{2}^{*}\left(q_{2}\right)-\varphi_{1}^{*}\left(q_{2}\right)
\varphi_{2}^{*}\left(q_{1}\right)\right]\nonumber\\
&amp;\frac{1}{r_{12}}
\frac{1}{\sqrt{2}}\left[\varphi_{1}\left(q_{1}\right)
\varphi_{2}\left(q_{2}\right)-\varphi_{1}\left(q_{2}\right)
\varphi_{2}\left(q_{1}\right)\right] \nonumber\\
&amp; = \iint d r_{1} d r _{2} \frac{1}{2}[ \frac{\left |
\varphi_{1}(q_1) \right |^2
\left|\varphi_{2}\left(q_{2}\right)\right|^{2}+\left|\varphi_{2}\left(q_{1}\right)\right|^{2}\left|\varphi_{1}\left(q_{2}\right)\right|^{2}
}{r_{12}}\nonumber\\
&amp; - \frac{\varphi_{1}^{*}\left(q_{1}\right)
\varphi_{2}^{*}\left(q_{2}\right)
\varphi_{1}\left(q_{2}\right)\varphi_{2}\left(q_{1}\right) +
\varphi_{1}^{*}\left(q_{2}\right)
\varphi_{2}^{*}\left(q_{1}\right)\varphi_{1}\left(q_{1}\right)  \varphi_{2}\left(q_{2}\right)  }{r_{12}}
]\nonumber
\end{align} \tag{17}
\]</span></p>
<p>推广到N电子系统</p>
<p><span class="math display">\[
H_{HF} = \left \langle \psi \left | \hat{H}  \right | \psi  \right
\rangle = \sum _{i=1}^{N} H_i + \frac{1}{2}
\sum_{i,j=1}^{N}(J_{ij}-K_{ij}) \tag{18}
\]</span> 其中</p>
<p><span class="math display">\[
\begin{array}{c}
H_{i}=\int \varphi_{i}^{*}\left(q_{i}\right)\left(-\frac{1}{2}
\nabla_{i}^{2}- \sum _{A=1}^{M} Z_{A} / r_{i A}\right)
\varphi_{i}\left(q_{i}\right) \mathrm{d} r_{i} \\
J_{i j}=\iint \varphi_{i}\left(q_{1}\right)
\varphi_{i}^{*}\left(q_{1}\right)\left(1 / r_{12}\right)
\varphi_{j}^{*}\left(q_{2}\right) \varphi_{j}\left(q_{2}\right)
\mathrm{d} r_{1} \mathrm{~d} r_{2} \\
K_{i j}=\iint \varphi_{i}^{*}\left(q_{1}\right)
\varphi_{j}^{*}\left(q_{2}\right)\left(1 / r_{12}\right)
\varphi_{i}\left(q_{2}\right) \varphi_{j}\left(q_{1}\right) \mathrm{d}
r_{1} \mathrm{~d} r_{2}
\end{array}
\]</span></p>
<p>当i，j相同时，J和K也相同。我们将J称为<strong>库伦积分</strong>，将K称为<strong>交换积分</strong>，它们都属于电子-电子间相互作用。</p>
<p>波函数有正交归一条件限制，所以需要利用拉格朗日未定乘数法构建泛函如下：</p>
<p><span class="math display">\[
W = E +\sum_{i} \varepsilon _i \left ( \int d r \varphi_{i}^{*}
\varphi_{i} - 1 \right )\tag{19}
\]</span></p>
<p>还是以双电子系统为例，对其取变分有：</p>
<p><span class="math display">\[
\begin{align}
\delta E &amp; = \sum _{i} \int \delta
\varphi_{i}^{*}\left(r\right)\left(-\frac{1}{2} \nabla_{i}^{2}- \sum _{A
= 1}^{M} Z_{A} / r_{i A}\right) \varphi_{i}\left(r\right) \mathrm{d}
r_{i}\nonumber \\
&amp; +\sum_{ij} \iint \delta \varphi_{i}^{*}\left(r\right)
\varphi_{i}\left(r\right) \left(1 / r_{12}\right)
\varphi_{j}^{*}\left(r^{\prime}\right)
\varphi_{j}\left(r^{\prime}\right) \mathrm{d} r_{1} \mathrm{~d} r_{2}
\nonumber \\
&amp; - \sum_{ij} \iint \delta \varphi_{i}^{*}\left(r\right)
\varphi_{j}^{*}\left(r^{\prime}\right)\left(1 / r_{12}\right)
\varphi_{i}\left(r^{\prime}\right) \varphi_{j}\left(r\right) \mathrm{d}
r_{1} \mathrm{~d} r_{2} \nonumber
\end{align} \tag{20}
\]</span></p>
<p>后面一项</p>
<p><span class="math display">\[
\delta \sum_{i} \varepsilon _i \left ( \int d r \varphi_{i}^{*}
\varphi_{i} - 1 \right ) = \sum_{i} \int dr \delta \varphi_{i}^{*}
\varepsilon _i \varphi_{i} \tag{21}
\]</span></p>
<p>两式相加后提取公因式。</p>
<p><span class="math display">\[
\begin{align}
\sum_{i} \int d r \delta \varphi_{i}^{*} [H_{i}
\varphi_{i}(r)+\sum_{j(\neq i)} \int d r^{\prime}
\frac{\left|\varphi_{j}\left(r^{\prime}\right)\right|^{2}}{\left|r-r^{\prime}\right|}
\varphi_{i}(r)\nonumber\\
-\sum_{j(\neq i)} \int d r^{\prime}
\frac{\varphi_{j}^{*}\left(r^{\prime}\right)
\varphi_{i}\left(r^{\prime}\right)}{\left|r-r^{\prime}\right|}
\varphi_{j}(r)-\varepsilon_{i} \varphi_{i}(r)] = 0\nonumber
\end{align}\tag{22}
\]</span></p>
<p>变分为零即要求括号内的部分为零 <span class="math display">\[
H_{i} \varphi_{i}+\sum_{j(\neq i)} \int d r^{\prime}
\frac{\left|\varphi_{j}\left(r^{\prime}\right)\right|^{2}}{\left|r-r^{\prime}\right|}
\varphi_{i}-\sum_{j(\neq i)} \int d r^{\prime}
\frac{\varphi_{j}^{*}\left(r^{\prime}\right)
\varphi_{i}\left(r^{\prime}\right)}{\left|r-r^{\prime}\right|}
\varphi_{j}=\varepsilon_{i} \varphi_{i} \tag{23}
\]</span></p>
<p>该式即为单电子波函数<span
class="math inline">\(\psi\)</span>的Hatree-Fork方程，简记为</p>
<p><span class="math display">\[
\hat{F}_i \psi(q_i) = \varepsilon _i \psi(q_i)\tag{24}
\]</span></p>
<p>其中<span
class="math inline">\(\hat{F}_i\)</span>被称为福克算符，表示单电子的哈密顿量算符。</p>
<h2 id="参考资料">参考资料</h2>
<p>[1] 量子力学 曾谨言</p>
<p>[2] 知乎文章 <a
href="https://zhuanlan.zhihu.com/p/40527652">密度泛函理论简介：A brief
summary</a></p>
<p>[3] 知乎文章 <a
href="https://zhuanlan.zhihu.com/p/487866148">固体物理：4.0 能带论
波恩奥本海默近似 Hatree-Fock近似 单电子近似</a></p>
<p>[4] 密度泛函理论 胡英 刘洪来</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>物理</category>
      </categories>
      <tags>
        <tag>能带</tag>
        <tag>密度泛函理论</tag>
      </tags>
  </entry>
  <entry>
    <title>英语六级作文</title>
    <url>/2022/06/02/2022-6/%E8%8B%B1%E8%AF%AD%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>应Viking的要求给出一个英语六级作文模板</p>
<span id="more"></span>
<h2 id="题目解析">1. 题目解析</h2>
<p>目前常见的题型有</p>
<ol type="1">
<li>现象解释/解决</li>
<li>某某品质的重要性<br />
</li>
<li>谚语</li>
</ol>
<p>不过在21年六月出了个图表类的题目，确实令人猝不及防。</p>
<p>图表题写法可以参考<a
href="https://splendidwave.github.io/2022/03/26/2022-3/%E9%9B%85%E6%80%9D%E8%80%83%E8%AF%95%E5%B0%8F%E4%BD%9C%E6%96%87/">雅思小作文第四部分图表题写法</a>这里不展开。</p>
<p>作文是在六级考试最先写的，时间为30分钟，要求大于150字小于200字。</p>
<h2 id="开头">2. 开头</h2>
<p>其实常见的题型大多可以归类为the importantance of Y(某品质) of
X(某领域)</p>
<h3 id="开头模板1-古今对比">2.1 开头模板1 古今对比</h3>
<p>所以如果写作文比较愁字数的，可以用下面这个古今对比的大水版：</p>
<p>Wheter in history society or in contemporary society, it is common
phenomenon for people to expect pleasant interpersonal relationships in
life, work, and X. but what is the key to building them? I deem that the
answer is Y.</p>
<h3 id="开头模板2-假设建议">2.2 开头模板2 假设建议</h3>
<p>如果不愁字数，怕被看出背板的，还有一个比较简短的:</p>
<p>provided that X intends to acquire and enjoy long-time
名词(prosperity/success), it is advisable for X to maintain their Y.</p>
<h3 id="开头模板3-两者抉择">2.3 开头模板3 两者抉择</h3>
<p>如果对通用模板不满意，还有针对性的，针对二者抉择问题：</p>
<p>in contemporary society, a rising numbers of people find it is hard
to decide whether tehy should ...</p>
<p>或者</p>
<p>it is universally acknowledged that a host of individuals find it
increasingly challenging to decide whether ...</p>
<h3 id="开头模板4-原因现象">2.4 开头模板4 原因现象</h3>
<p>with the development of Internet and digital technology, there is a
tendency among people that…</p>
<p>或者</p>
<p>As the income increases，there was a surge of interest in...</p>
<p>或者</p>
<p>with the development of science and technology, many formerly
unimaginable things come into reality.some of them have positive effects
on our life, but some are distasteful.</p>
<p>The phenomenon of ___ is an example.</p>
<h3 id="开头模板5-谚语">2.5 开头模板5 谚语</h3>
<p>This is simple but enlightening remark on _ _ by _ _</p>
<p>The profound meaning lying in this saying persuades us that _ _</p>
<h2 id="中间">3. 中间</h2>
<p>中间使用简单句掺杂比喻排比等句子。</p>
<h3 id="排比1">3.1 排比1</h3>
<p><strong>Without</strong> innovation, our social industries can never
be modernized; <strong>without</strong> innovation, our medical science
can never cure so many diseases; and <strong>without</strong>
innovation, there would be no electronic products we use today.</p>
<h3 id="排比比喻">3.2 排比+比喻</h3>
<p>curiosity towards knowledge, without a doubt, <strong>is the stepping
stone</strong> which <strong>enriches</strong> learners’ minds,
<strong>enhances</strong> their learning efficiency,
<strong>ensures</strong> more fruitful results, and
<strong>enables</strong> them to go further on the way of education.</p>
<h3 id="举例子">3.3 举例子</h3>
<p>A typical example is my friend, who is lazy and always ... Thus, such
a habit leads him nowhere</p>
<h3 id="排比2">3.4 排比2</h3>
<p>Some people are <strong>too subordinate to</strong> others' opinions,
<strong>too focused on</strong> decision consensus, <strong>too silent
about</strong> their own point of view, <strong>too agreeable
to</strong> take things on when they don't have time or energy</p>
<h3 id="一些短语">3.5 一些短语</h3>
<h4 id="应该">应该</h4>
<ol type="1">
<li>We should bear in mind that</li>
<li>It is advisable for us to</li>
<li>should be encouraged to do</li>
</ol>
<h4 id="首先">首先</h4>
<ol type="1">
<li>To begin with</li>
<li>First and foremost</li>
</ol>
<h4 id="总而言之">总而言之</h4>
<ol type="1">
<li>in a word</li>
<li>to sum up</li>
<li>in a nutshell</li>
<li>by and large</li>
</ol>
<h2 id="结尾">4. 结尾</h2>
<p>In a nutshell, _ _ _ lays a solid foundation for _ _ as well as for
them to be qualified competitors in the future.</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML标签速查</title>
    <url>/2022/07/31/2022-7/HTML%E6%A0%87%E7%AD%BE%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<h2 id="开头">开头</h2>
<p><code>!</code>快速添加模板</p>
<p>charset="UTF-8"</p>
<p>lang="zh-CN"</p>
<span id="more"></span>
<h2 id="参考">参考</h2>
<p><a
href="https://blog.csdn.net/qq_52341981/article/details/119863488">HTML基本结构标签以及常用标签</a></p>
<p><a
href="https://blog.csdn.net/qq_57587705/article/details/124215974">HTML
语法规范及其基本结构标签</a></p>
<p><a
href="https://b23.tv/6hTWJu4">黑马程序员前端Web全套教程，会打字就能学会的Web前端课程</a></p>
<h2 id="基本结构标签">基本结构标签</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;&lt;/html&gt;作为页面中一个最大的标签，包裹住其他小标签，称其为根标签</span><br><span class="line">&lt;head&gt;&lt;/head&gt;文档的头部，在这其中必须包含tilte标签</span><br><span class="line">&lt;title&gt;&lt;/title&gt;文档的标题，给页面设置标题</span><br><span class="line">&lt;body&gt;&lt;/body&gt;文档发主体，页面中的内容基本都放在改标签里。</span><br></pre></td></tr></table></figure>
<h2 id="常用标签">常用标签</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标题标签：&lt;h1&gt;~&lt;h6&gt;一共六级选</span><br><span class="line">段落标签：&lt;p&gt;我是一个段落标签&lt;/p&gt;</span><br><span class="line">换行标签：&lt;/br&gt;——这是一个单标签</span><br><span class="line">文本格式化标签：将字体设置粗体、斜体、删除线或下划线效果</span><br><span class="line">加粗	&lt;strong&gt;&lt;/strong&gt;或&lt;b&gt;&lt;/b&gt;	常用&lt;strong&gt;&lt;/strong&gt;</span><br><span class="line">斜体	&lt;em&gt;&lt;/em&gt;或&lt;i&gt;&lt;/i&gt;	常用&lt;em&gt;&lt;/em&gt;</span><br><span class="line">删除线	&lt;del&gt;&lt;/del&gt;或&lt;s&gt;&lt;/s&gt;	常用&lt;del&gt;&lt;/del&gt;</span><br><span class="line">下划线	&lt;ins&gt;&lt;/ins&gt;或&lt;u&gt;&lt;/u&gt;	常用&lt;ins&gt;&lt;/ins&gt;</span><br></pre></td></tr></table></figure>
<h2 id="布局标签和链接">布局标签和链接</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;一行只能放一个&lt;/div&gt;</span><br><span class="line">&lt;span&gt;一行能放多个&lt;/span&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">图片</span><br><span class="line">&lt;img src=&quot;此处写图像路径&quot;/&gt;</span><br><span class="line"></span><br><span class="line">超链接</span><br><span class="line">&lt;a href=&quot;跳转目标&quot;target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;</span><br><span class="line">其中_self为默认值，_blank为新窗口打开方式</span><br><span class="line"></span><br><span class="line">锚点</span><br><span class="line">&lt;h3 id = &quot;z&quot;&gt;&lt;/h3&gt;</span><br><span class="line">&lt;a href=&quot;#z&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<h2 id="特殊字符">特殊字符</h2>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200905.png"
alt="特殊字符对照表" />
<figcaption aria-hidden="true">特殊字符对照表</figcaption>
</figure>
<h2 id="表格标签">表格标签</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">	&lt;thead&gt;</span><br><span class="line">		&lt;tr&gt; &lt;th&gt;表头单元格&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt;</span><br><span class="line">	&lt;/thead&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;tbody&gt;</span><br><span class="line">		&lt;tr&gt; &lt;td&gt;单元格文字&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;</span><br><span class="line">		&lt;tr&gt;&lt;/tr&gt;</span><br><span class="line">	&lt;/tobdy&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<p>以下属性要写入table里<code>&lt;table align = "center"&gt;</code>
都可以用CSS控制 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">align = &quot;left&quot;/&quot;center&quot;/&quot;right&quot;</span><br><span class="line">border = &quot;1&quot;</span><br><span class="line">cellpadding = &quot;像素值&quot; 单元格边框和内容的边距 默认1</span><br><span class="line">cellspacing = &quot;像素值&quot; 单元格之间的空白 默认2 通常为0</span><br><span class="line">width = &quot;像素值&quot; 单元格宽度</span><br><span class="line">height = &quot;像素值&quot; 单元格高度</span><br></pre></td></tr></table></figure></p>
<p>合并单元格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">跨行合并：rowspan = &quot;合并单元格的个数&quot; 写在最上侧单元格</span><br><span class="line">跨列合并：colspan = &quot;合并单元格的个数&quot; 写在最左侧单元格</span><br></pre></td></tr></table></figure>
<h2 id="列表标签">列表标签</h2>
<h3 id="无序列表">无序列表</h3>
<p>ul 里只能放 li 标签 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="有序列表">有序列表</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure>
<h3 id="自定义列表">自定义列表</h3>
<p>dt和dd数量没有限制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">	&lt;dt&gt;&lt;/dt&gt;</span><br><span class="line">	&lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">	&lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure>
<h2 id="表单">表单</h2>
<h3 id="表单域">表单域</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单域名称&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h3 id="表单控件表单元素">表单控件（表单元素）</h3>
<h4 id="input">input</h4>
<p>单标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;属性值&quot; &gt; &lt;br&gt;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>button</td>
<td>按钮，通过JavaScript启动脚本</td>
</tr>
<tr class="even">
<td>checkbox</td>
<td>复选框</td>
</tr>
<tr class="odd">
<td>text</td>
<td>可以输入文本</td>
</tr>
<tr class="even">
<td>color</td>
<td>定义拾色器</td>
</tr>
<tr class="odd">
<td>radio</td>
<td>单选框</td>
</tr>
<tr class="even">
<td>date</td>
<td>选择日期</td>
</tr>
<tr class="odd">
<td>file</td>
<td>选择本地文件</td>
</tr>
<tr class="even">
<td>number</td>
<td>数字</td>
</tr>
<tr class="odd">
<td>password</td>
<td>密码</td>
</tr>
<tr class="even">
<td>range</td>
<td>定义用于精确值不重要的输入数字的控件</td>
</tr>
<tr class="odd">
<td>reset</td>
<td>重置</td>
</tr>
<tr class="even">
<td>search</td>
<td>搜索</td>
</tr>
<tr class="odd">
<td>submit</td>
<td>提交</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;xxx.php&quot; method=&quot;get&quot;&gt;</span><br><span class="line">	用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;请输入用户名&quot; maxlength=&quot;8&quot;&gt; &lt;br&gt;</span><br><span class="line">	密码：&lt;input type=&quot;passsword&quot; name=&quot;pwd&quot;&gt; &lt;br&gt;</span><br><span class="line">	性别：男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; checked=&quot;checked&quot;&gt; 女 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt; 中性 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;中性&quot;&gt; &lt;br&gt;</span><br><span class="line">	爱好：吃饭 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;吃饭&quot;&gt; 睡觉&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;睡觉&quot;&gt; 打豆豆 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;打豆豆&quot;&gt; &lt;br&gt;</span><br><span class="line">	&lt;br&gt;</span><br><span class="line">	上传头像：&lt;input type=&quot;file&quot;&gt; </span><br><span class="line">	&lt;br&gt;</span><br><span class="line">	&lt;br&gt;</span><br><span class="line">	&lt;input type=&quot;submit&quot; value=&quot;免费注册&quot;&gt;</span><br><span class="line">	&lt;input type=&quot;reset&quot; name=&quot;重新填写&quot;&gt;</span><br><span class="line">	&lt;input type=&quot;button&quot; value=&quot;获取短信验证码&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h3 id="label标签">label标签</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;label for=&quot;text1&quot;&gt; 用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;text1&quot;&gt; &lt;br&gt;</span><br><span class="line">  &lt;label for=&quot;nan&quot;&gt; 男 &lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;nan&quot; name=&quot;sex&quot;&gt;&lt;label for=&quot;nv&quot;&gt; 女 &lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;nv&quot; name=&quot;sex&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;第一个单选按钮在表单之外,但它仍属于该表单的一部分。尝试点击文本标签切换单选按钮。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=&quot;demo_form.php&quot; id=&quot;form1&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;male&quot;&gt;&lt;br&gt;</span><br><span class="line">  &lt;label for=&quot;female&quot;&gt;Female&lt;/label&gt;</span><br><span class="line">  &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot; value=&quot;female&quot;&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;label for=&quot;male&quot; form=&quot;form1&quot;&gt;Male&lt;/label&gt;</span><br></pre></td></tr></table></figure>
<h3 id="select">select</h3>
<p>多选项选择，节省空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">	籍贯：  </span><br><span class="line">	&lt;select&gt;</span><br><span class="line">	  &lt;option&gt;山东&lt;/option&gt;</span><br><span class="line">	  &lt;option&gt;北京&lt;/option&gt;</span><br><span class="line">	  &lt;option&gt;浙江&lt;/option&gt;</span><br><span class="line">	  &lt;option&gt;天津&lt;/option&gt;</span><br><span class="line">	  &lt;option selected=&quot;selected&quot;&gt;其他&lt;/option&gt;</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h3 id="textarea">textarea</h3>
<p>文本域</p>
<p>cols 是列数 rows是行数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">	今日反馈：</span><br><span class="line">	&lt;textarea rows=&quot;3&quot; cols=&quot;10&quot;&gt;欢迎留言呀&lt;/textarea&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>VASP计算单层黑磷能带(HSE06)</title>
    <url>/2022/07/19/2022-7/VASP%E8%AE%A1%E7%AE%97%E5%8D%95%E5%B1%82%E9%BB%91%E7%A3%B7%E8%83%BD%E5%B8%A6(HSE06)/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>vasp使用HSE06计算单层黑磷能带的方法</p>
<span id="more"></span>
<h2 id="前处理">前处理</h2>
<p>为加速计算结构优化和自洽仍采用PBE，同上一篇文章<a
href="https://splendidwave.github.io/2022/07/17/2022-7/VASP%E8%AE%A1%E7%AE%97%E5%8D%95%E5%B1%82%E9%BB%91%E7%A3%B7%E8%83%BD%E5%B8%A6(PBE)/#more">VASP计算单层黑磷能带(PBE)</a></p>
<h2 id="能带计算">能带计算</h2>
<p>将文件复制到一个band_hse文件夹，修改INCAR</p>
<figure class="highlight plaintext"><figcaption><span>INCAR</span></figcaption><table><tr><td class="code"><pre><span class="line"># Global Parameters</span><br><span class="line">SYSTEM = BP_AB_hse06</span><br><span class="line">ISTART = 1 </span><br><span class="line">ISPIN =  1 							</span><br><span class="line">ICHARG = 1</span><br><span class="line">LWAVE  = .F.</span><br><span class="line">LCHARG = .F.</span><br><span class="line">ENCUT = 500</span><br><span class="line">LORBIT = 11</span><br><span class="line"></span><br><span class="line"># Electronic Relaxation</span><br><span class="line">ISMEAR =  0</span><br><span class="line">SIGMA  =  0.05</span><br><span class="line">NELM =  300</span><br><span class="line">NELMIN =  6</span><br><span class="line">EDIFF = 1E-06</span><br><span class="line"></span><br><span class="line"># Ionic Relaxation</span><br><span class="line">NSW =  0</span><br><span class="line">IBRION =  -1</span><br><span class="line">ISIF =  3</span><br><span class="line">EDIFFG = -1E-03</span><br><span class="line">ISYM =  0</span><br><span class="line">POTIM = 0.2</span><br><span class="line"></span><br><span class="line">#HSE</span><br><span class="line">ALGO = Damped</span><br><span class="line">HFSCREEN = 0.2</span><br><span class="line">GGA = PE</span><br><span class="line">LHFCALC = .True.</span><br><span class="line">LMAXFOCK = 4</span><br><span class="line">PRECFOCK = Fast</span><br><span class="line">TIME = 0.4</span><br></pre></td></tr></table></figure>
<p>使用vaspkit的302生成新的k路径(KPATH)，251生成KPOINTS,</p>
<p>提交运行，HSE的运行时间会比较长</p>
<p>运行完成后使用252获得能带数据和带隙</p>
<h2 id="记一下运行指令">记一下运行指令</h2>
<h3 id="不挂断运行vasp">不挂断运行vasp</h3>
<p>nohup mpirun -np 6 vasp_std &amp;</p>
<p>6是核数，我自己的电脑是6核的</p>
<h3 id="查看运行文件">查看运行文件</h3>
<p>tail -f nohup.out</p>
<h2 id="参考资料">参考资料</h2>
<p>[1] <a
href="https://zhuanlan.zhihu.com/p/82078425">VASP之HSE06能带计算</a></p>
<p>[2] <a
href="https://zhuanlan.zhihu.com/p/446453016">HSE06计算带隙</a></p>
]]></content>
      <categories>
        <category>科研项目</category>
        <category>黑磷的拉曼光谱</category>
      </categories>
      <tags>
        <tag>固体物理</tag>
        <tag>VASP</tag>
      </tags>
  </entry>
  <entry>
    <title>VASP计算单层黑磷能带(PBE)</title>
    <url>/2022/07/17/2022-7/VASP%E8%AE%A1%E7%AE%97%E5%8D%95%E5%B1%82%E9%BB%91%E7%A3%B7%E8%83%BD%E5%B8%A6(PBE)/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>以单层黑磷为例记录一下用vasp使用PBE计算二维材料的方法</p>
<span id="more"></span>
<h2 id="预备工具">预备工具</h2>
<ol type="1">
<li>装有Linux系统的的电脑（本文使用wsl2下的ubuntu1804版本，使用vscode编辑）</li>
<li>VASP 5.4.4</li>
<li>vaspkit 1.3.5</li>
</ol>
<h2 id="结构优化">结构优化</h2>
<p>这一步是为了得到原子的最优位置，所以POSCAR给的稍微有些偏差问题是不大的，因为后面VASP会优化。</p>
<p>新建文件夹<code>BP_1L</code>，在当前目录创建名为<code>opt</code>的文件夹。</p>
<h3 id="poscar">POSCAR</h3>
<p>POSCAR可以去下载cif通过VESTA转换，也可以通过MS或VESTA画出来</p>
<p>导入写好的POSCAR，这里为了实现单层y方向给了20埃的长度</p>
<figure class="highlight plaintext"><figcaption><span>POSCAR</span></figcaption><table><tr><td class="code"><pre><span class="line">BP_1L</span><br><span class="line">1.0</span><br><span class="line">        3.3159999847         0.0000000000         0.0000000000</span><br><span class="line">        0.0000000000        20.0000000000         0.0000000000</span><br><span class="line">        0.0000000000         0.0000000000         4.3889999390</span><br><span class="line">    P</span><br><span class="line">    4</span><br><span class="line">Direct</span><br><span class="line">     0.809849977         0.456869990         0.580680013</span><br><span class="line">     0.809849977         0.559960008         0.400680006</span><br><span class="line">     0.309850007         0.559960008         0.080679998</span><br><span class="line">     0.309850007         0.456869990         0.900680006</span><br></pre></td></tr></table></figure>
<h3 id="incar">INCAR</h3>
<figure class="highlight plaintext"><figcaption><span>INCAR</span></figcaption><table><tr><td class="code"><pre><span class="line"># Global Parameters</span><br><span class="line">SYSTEM = BP_1L</span><br><span class="line">ISTART = 0</span><br><span class="line">ISPIN =  1</span><br><span class="line">ICHARG = 2 </span><br><span class="line">LWAVE  = .F.</span><br><span class="line">LCHARG = .F.</span><br><span class="line">ENCUT = 500</span><br><span class="line"># LORBIT = 11</span><br><span class="line"></span><br><span class="line"># Electronic Relaxation</span><br><span class="line">ISMEAR =  0</span><br><span class="line">SIGMA  =  0.05</span><br><span class="line">NELM =  300</span><br><span class="line">NELMIN =  6</span><br><span class="line">EDIFF = 1E-06</span><br><span class="line"></span><br><span class="line"># Ionic Relaxation</span><br><span class="line">NSW =  100</span><br><span class="line">IBRION =  2</span><br><span class="line">ISIF =  3</span><br><span class="line">EDIFFG = -1E-03</span><br><span class="line">ISYM =  0</span><br><span class="line">POTIM = 0.2</span><br></pre></td></tr></table></figure>
<h3 id="potcar和kpoint">POTCAR和KPOINT</h3>
<p>使用vaspkit生成</p>
<p>输入vaspkit</p>
<ol type="1">
<li>选 1) VASP Input-Files Kit<br />
</li>
<li>选 103) Generate POTCAR File with Default Setting</li>
</ol>
<p>即可生成POTCAR</p>
<p>输入vaspkit</p>
<ol type="1">
<li>选 1) VASP Input-Files Kit<br />
</li>
<li>选 102) Generate KPOINTS File for SCF Calculation</li>
<li>选 1) Monkhorst-Pack Scheme</li>
<li>输入0.01</li>
<li>在生成的KPOINTS中第四行修改为<code>14   1  10</code></li>
</ol>
<p>得到KPOINTS</p>
<h3 id="optcell">OPTCELL</h3>
<p>二维材料还需要一个optcell文件来让VASP不要优化真空层方向</p>
<p>里面写<code>101</code>即可，0表示不优化第二个方向</p>
<p>运行vasp</p>
<h2 id="自洽">自洽</h2>
<p>将上一步骤完成的文件复制一份并重命名为scf</p>
<p>在该目录下输入<code>cp CONTCAR POSCAR</code>将上一步优化好的结果赋给POSCAR</p>
<p>修改INCARD</p>
<figure class="highlight plaintext"><figcaption><span>INCAR</span></figcaption><table><tr><td class="code"><pre><span class="line"># Global Parameters</span><br><span class="line">SYSTEM = BP_1L</span><br><span class="line">ISTART = 0</span><br><span class="line">ISPIN =  1</span><br><span class="line">ICHARG = 2 </span><br><span class="line">LWAVE  = .T.</span><br><span class="line">LCHARG = .T.</span><br><span class="line">ENCUT = 500</span><br><span class="line">LORBIT = 11</span><br><span class="line"></span><br><span class="line"># Electronic Relaxation</span><br><span class="line">ISMEAR =  0</span><br><span class="line">SIGMA  =  0.05</span><br><span class="line">NELM =  300</span><br><span class="line">NELMIN =  6</span><br><span class="line">EDIFF = 1E-06</span><br><span class="line"></span><br><span class="line"># Ionic Relaxation</span><br><span class="line">NSW =  0</span><br><span class="line">IBRION =  -1</span><br><span class="line">ISIF =  3</span><br><span class="line">EDIFFG = -1E-03</span><br><span class="line">ISYM =  0</span><br><span class="line">POTIM = 0.2</span><br></pre></td></tr></table></figure>
<p>运行vasp</p>
<h2 id="能带计算">能带计算</h2>
<p>将文件复制到一个band文件夹，修改INCAR</p>
<figure class="highlight plaintext"><figcaption><span>INCAR</span></figcaption><table><tr><td class="code"><pre><span class="line"># Global Parameters</span><br><span class="line">SYSTEM = BP_1L</span><br><span class="line">ISTART = 1</span><br><span class="line">ISPIN =  1</span><br><span class="line">ICHARG = 11</span><br><span class="line">LWAVE  = .F.</span><br><span class="line">LCHARG = .F.</span><br><span class="line">ENCUT = 500</span><br><span class="line">LORBIT = 11</span><br><span class="line"></span><br><span class="line"># Electronic Relaxation</span><br><span class="line">ISMEAR =  0</span><br><span class="line">SIGMA  =  0.05</span><br><span class="line">NELM =  300</span><br><span class="line">NELMIN =  6</span><br><span class="line">EDIFF = 1E-06</span><br><span class="line"></span><br><span class="line"># Ionic Relaxation</span><br><span class="line">NSW =  0</span><br><span class="line">IBRION =  -1</span><br><span class="line">ISIF =  3</span><br><span class="line">EDIFFG = -1E-03</span><br><span class="line">ISYM =  0</span><br><span class="line">POTIM = 0.2</span><br></pre></td></tr></table></figure>
<p>使用vaspkit生成新的k路径</p>
<p>输入vaspkit</p>
<ol type="1">
<li>选 3) K-Path for Band-Structure</li>
<li>选 302) 2D Structure</li>
<li><code>cp KPATH.in KPOINTS</code></li>
</ol>
<p>提交运行</p>
<p>输出文件中的DOSCAR内的费米能级是不准确的，所以这里进行一个修改，
使用<code>grep fermi ../scf/OUTCAR</code>从自洽中找到准确的费米能级
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISMEAR =     0;   SIGMA  =   0.05  broadening in eV -4-tet -1-fermi 0-gaus</span><br><span class="line"> E-fermi :  -1.8123     XC(G=0):  -3.0926     alpha+bet : -3.0343</span><br></pre></td></tr></table></figure> 我这里是-1.8123</p>
<p>将该数值复制到band文件夹下输出文件DOSCAR的第六行的第4个数，两个数的值一般会比较接近。</p>
<h2 id="参看数据及绘制能带图">参看数据及绘制能带图</h2>
<p>通过vaspkit计算能带</p>
<p>输入vaspkit</p>
<ol type="1">
<li>选 21) Band-Structure</li>
<li>选 211) Band-Structure</li>
</ol>
<p>输出文件中有<code>BAND_GAP</code>可以看见 Band Gap (eV)</p>
<p>绘制能带图可以使用 python 的 pymatgen 或
origin（把band.dat拖进去）</p>
<p>下面给出pymatgen的绘制能带图代码，代码节选自<a
href="http://blog.wangruixing.cn/2019/05/19/pymatgen-band/">刘锦城老师的文章</a>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from pymatgen.io.vasp.outputs import Vasprun</span><br><span class="line">from pymatgen.electronic_structure.plotter import BSDOSPlotter,BSPlotter,BSPlotterProjected,DosPlotter</span><br><span class="line"></span><br><span class="line">bs_vasprun = Vasprun(&quot;./vasprun.xml&quot;,parse_projected_eigen=True)</span><br><span class="line">bs_data = bs_vasprun.get_band_structure(line_mode=True)</span><br><span class="line"></span><br><span class="line">band_fig = BSPlotter(bs=bs_data)</span><br><span class="line">band_fig.get_plot()</span><br><span class="line">plt.savefig(&#x27;band_fig.png&#x27;, img_format=&#x27;png&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>科研项目</category>
        <category>黑磷的拉曼光谱</category>
      </categories>
      <tags>
        <tag>固体物理</tag>
        <tag>VASP</tag>
      </tags>
  </entry>
  <entry>
    <title>VASP输入文件INCAR速查</title>
    <url>/2022/07/17/2022-7/VASP%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6INCAR%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>VASP一共有4个输入文件，分别为：POSCAR、INCAR、KPOINTS和POTCAR。其中POSCAR为结构文件，KPOINTS为K点文件，POTCAR是赝势文件。<strong>而INCAR决定了做什么计算以及如何做此次计算。</strong></p>
<blockquote>
<p>查询参数功能, 输入网站 + <em>参数名</em>
https://www.vasp.at/wiki/index.php/ + <em>参数名</em></p>
</blockquote>
<span id="more"></span>
<p>下面按第一性原理计算的一般步骤（结构优化、自洽计算、非自洽计算）展示INCAR参数应该如何设置。等于号(=)后面为在该步骤的推荐设置。</p>
<h1 id="结构优化-opt">结构优化 OPT</h1>
<p>主要用来计算体系结构，原子位置。</p>
<h2 id="基础设置">基础设置</h2>
<p><strong>1、ISTART</strong></p>
<p><strong>控制如何生成初始波函数</strong></p>
<ul>
<li>0：随机生成波函数</li>
<li>1 : 从WAVECAR中读取波函数，当读取失败时，会随机生成</li>
</ul>
<p>= 0</p>
<p><strong>2、ISPIN</strong></p>
<p><strong>是否打开自旋</strong></p>
<ul>
<li>1: 非自旋极化计算</li>
<li>2: 打开自旋极化计算</li>
</ul>
<p>=2</p>
<p><strong>3、 ICHAGE</strong></p>
<p><strong>控制如何生成初始电荷密度</strong></p>
<ul>
<li>0：读取WAVECAR生成电荷密度，当读取失败时，通过原子电荷密度叠加生成初始电荷密度</li>
<li>1：从CHGCAR中的设定读取电荷密度</li>
<li>2：通过原子电荷密度的叠加方法，生成初始的猜测电荷密度</li>
<li>11：从CHGCAR读取电荷密度，且在自洽循环中保持不变，适用于非自洽循环计算，如电子态密度的计算</li>
</ul>
<p>=2</p>
<p><strong>4、 LWAVE/LCHARG</strong></p>
<p><strong>控制是否输出波函数(WAVECAR)和电荷密度(CHGCAR)</strong></p>
<ul>
<li>.T.: 写波函数和电荷密度</li>
<li>.F.: 不写波函数和电荷密度</li>
</ul>
<p>=.F.</p>
<h2 id="计算精度设置">计算精度设置</h2>
<p><strong>1、ENCUT</strong></p>
<p><strong>平面波截断能，控制用多少平面波展开波函数</strong></p>
<p>推荐设置为POTCAR（赝势文件）中参数ENMAX值的1.0-1.3倍，从而兼顾计算的精度与效率。</p>
<p>=500</p>
<p><strong>2、PREC</strong></p>
<p><strong>总体计算精度控制</strong></p>
<ul>
<li>Accurate: 准确</li>
<li>Normal: 一般</li>
</ul>
<p>默认为Normal</p>
<p>= Accurate</p>
<p><strong>3、ADDGRID</strong></p>
<p><strong>是否开启网格</strong></p>
<ul>
<li>.TRUE. : 开启</li>
<li>.FALSE. : 关闭</li>
</ul>
<p>=.TRUE.</p>
<p><strong>4、NPAR</strong></p>
<p><strong>核数</strong></p>
<p>别写,用默认的就行</p>
<p><strong>3、LORBIT</strong></p>
<p><strong>总态密度投影</strong></p>
<p>11: 每一个原子对应的轨道的贡献输出到OUTCAR里</p>
<p>=11</p>
<h2 id="宏观设置">宏观设置</h2>
<p><strong>1、ISMEAR</strong></p>
<p><strong>设置展宽方法，决定如何进行电子轨道分数占据</strong></p>
<ul>
<li>0: Gaussian smearing</li>
<li>−1: Fermi smearing</li>
</ul>
<p>金属可以设置为1</p>
<p>=0</p>
<p><strong>2、SIGMA</strong></p>
<p><strong>展宽的宽度，与ISMEAR联用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">半导体 设置为 0.05</span><br><span class="line">金属 设置为 0.02</span><br><span class="line"></span><br><span class="line">小 -&gt; 大</span><br><span class="line">态密度平滑 -&gt; 态密度尖锐</span><br></pre></td></tr></table></figure>
<p>单位为eV，默认值为0.2</p>
<p>=0.05</p>
<p><strong>3、NELM</strong></p>
<p><strong>自洽迭代循环的最大次数</strong></p>
<p>一般在150-300</p>
<p>=300</p>
<p><strong>4、NELMIN</strong></p>
<p><strong>自洽迭代循环的最小次数</strong></p>
<p>一般在4-6</p>
<p>=6</p>
<p><strong>5、EDIFF</strong></p>
<p><strong>自洽迭代循环收敛标准，单位为eV</strong></p>
<p>一般在1E-05 - 1E-06</p>
<p>= 1E-06</p>
<h2 id="离子弛豫相关设置">离子弛豫相关设置</h2>
<p><strong>1、NSW</strong></p>
<p><strong>最大步数</strong></p>
<p>=100</p>
<p><strong>2、IBRION</strong></p>
<p><strong>离子步弛豫（离子位置优化）算法</strong> * 0：分子动力学模拟 *
1：准牛顿法 * 2：共轭梯度法 * 5：振动频率计算 * 6：弹性常数计算</p>
<p>=2</p>
<p><strong>3、ISIF</strong></p>
<p><strong>离子步弛豫控制</strong></p>
<ul>
<li>2： 晶胞大小不变，原子位置动</li>
<li>3： 晶胞大小改变，原子位置动，晶胞体积变</li>
<li>4： 晶胞大小改变，原子位置动，晶胞体积不变（多用于一二维体系）</li>
</ul>
<p>=4</p>
<p><strong>4、EDIFFG</strong></p>
<p><strong>离子弛豫中断</strong></p>
<p>=-1E-03</p>
<p><strong>5、ISYM</strong></p>
<p><strong>对称</strong></p>
<ul>
<li>0: 不打开对称</li>
<li>2: 打开对称</li>
</ul>
<p>=0</p>
<p><strong>6、MAGMOM</strong></p>
<p><strong>对于磁性材料，设置初始原子磁矩</strong>
默认值是每个原子的磁矩均为1
对于含有d、f轨道的原子，需根据原子核外电子排布情况设置相应的数值
可以设置每个原子初始磁矩方向，正值为自旋向上，负值为自旋向下。</p>
<p>根据POSCAR修改</p>
<p><strong>7、IVDW</strong></p>
<p><strong>范德华力计算方法，在DFT能量计算基础上增加范德华力修正</strong>
* 10：DFT-D2方法 * 11：DFT-D3方法</p>
<p>=11</p>
<h2 id="参数汇总">参数汇总</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISTART = 0 </span><br><span class="line">ISPIN =  2 </span><br><span class="line">ICHARG = 2 </span><br><span class="line">LWAVE  = .F.</span><br><span class="line">LCHARG = .F.</span><br><span class="line">ENCUT = 500</span><br><span class="line"># PREC =  Accurate        (Precision level)   Normal / Accurate</span><br><span class="line"># ADDGRID = .TRUE.        (Increase grid; helps GGA convergence) </span><br><span class="line"># NPAR = 4 	</span><br><span class="line">LORBIT = 11</span><br><span class="line"></span><br><span class="line">ISMEAR =  0</span><br><span class="line">SIGMA  =  0.05</span><br><span class="line">NELM =  300</span><br><span class="line">NELMIN =  6</span><br><span class="line">EDIFF = 1E-06</span><br><span class="line"></span><br><span class="line">NSW =  100</span><br><span class="line">IBRION	=  2</span><br><span class="line">ISIF =  4</span><br><span class="line">EDIFFG = -1E-03</span><br><span class="line">ISYM =  0</span><br><span class="line">POTIM = 0.2</span><br><span class="line">IVDW = 11</span><br></pre></td></tr></table></figure>
<h1 id="自洽-scf">自洽 SCF</h1>
<p>电荷密度 波函数</p>
<p>参数基本与上一步骤相同</p>
<p><strong>1、NEDOS</strong></p>
<p><strong>态密度数据点个数</strong> 通常设置1000-3000</p>
<p>=3001</p>
<p><strong>2、NSW</strong></p>
<p>cp CONTCAR POSCAR</p>
<p>不做结构优化</p>
<p>= 0</p>
<h2 id="参数汇总-1">参数汇总</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Global Parameters</span><br><span class="line">ISTART = 0</span><br><span class="line">ISPIN =  2</span><br><span class="line">ICHARG = 2</span><br><span class="line">ENCUT  =  500</span><br><span class="line">PREC =  Accurate</span><br><span class="line">EDIFF  = 1E-08 </span><br><span class="line">ADDGRID = .TRUE. </span><br><span class="line">LWAVE  = .T.        </span><br><span class="line">LCHARG = .T.</span><br><span class="line"># NPAR = 4</span><br><span class="line">LORBIT = 11</span><br><span class="line">NEDOS = 3001</span><br><span class="line"> </span><br><span class="line">ISMEAR =  0 </span><br><span class="line">SIGMA  =  0.05</span><br><span class="line">NELM =  300</span><br><span class="line">NELMIN =  6</span><br><span class="line"> </span><br><span class="line">NSW =  0</span><br><span class="line">IBRION =  -1</span><br><span class="line"># ISIF   =  3</span><br><span class="line"># EDIFFG = -1E-03</span><br><span class="line">ISYM =  0</span><br><span class="line">POTIM = 0.2</span><br><span class="line"> </span><br><span class="line"># LSORBIT = .TRUE.    (Activate SOC)</span><br><span class="line"># GGA_COMPAT = .FALSE.   (Apply spherical cutoff on gradient field)</span><br><span class="line"># LMAXMIX =  4        (For d elements increase LMAXMIX to 4, f: LMAXMIX = 6)</span><br><span class="line"># SAXIS =  0 0 1    (Direction of the magnetic field)</span><br><span class="line"> </span><br><span class="line">IVDW = 11</span><br></pre></td></tr></table></figure>
<h1 id="非自恰运算-nscf">非自恰运算 NSCF</h1>
<p>band dos 磁矩</p>
<h2 id="能带结构运算">能带结构运算</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISTART = 1</span><br><span class="line">ISPIN =  2</span><br><span class="line">ICHARG = 11</span><br><span class="line">ENCUT  =  500</span><br><span class="line">PREC = Accurate</span><br><span class="line">EDIFF  = 1E-08</span><br><span class="line">ADDGRID= .TRUE.</span><br><span class="line">LWAVE  = .F.</span><br><span class="line">LCHARG = .F.</span><br><span class="line">LORBIT = 11</span><br><span class="line"> </span><br><span class="line">ISMEAR =  0</span><br><span class="line">SIGMA  =  0.02</span><br><span class="line">NELM   =  300</span><br><span class="line">NELMIN =  6</span><br><span class="line"> </span><br><span class="line">NSW    =  0</span><br><span class="line">IBRION =  -1</span><br><span class="line"># ISIF   =  3</span><br><span class="line"># EDIFFG = -1E-03        (Ionic convergence; eV/AA)</span><br><span class="line">ISYM =  0</span><br><span class="line">POTIM = 0.2</span><br><span class="line"></span><br><span class="line">IVDW = 11   ##vdw forces</span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<p>[1] 知乎文章 <a
href="https://zhuanlan.zhihu.com/p/151725218">VASP软件
INCAR文件参数含义速查表</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>物理</category>
      </categories>
      <tags>
        <tag>VASP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用树莓派3b搭OpenWrt</title>
    <url>/2022/08/11/2022-8/%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3b%E6%90%ADOpenwrt/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>OpenWRT是一个嵌入式Linux系统，拥有强大的网络组件和扩展性，常用来作为主流路由器固件，使用OpenWrt作为软路由对用户来说意味着拥有个人定制化网络的权利<del>（并没有什么用）</del>。因此对于喜欢折腾的玩家来说，使用一个闲置的树莓派来刷openwrt系统是不错的选择。</p>
<p>本文树莓派型号是3b，OpenWrt固件版本为immortalwrt</p>
<span id="more"></span>
<h2 id="硬件准备">硬件准备</h2>
<ol type="1">
<li>win10系统电脑一台</li>
<li>树莓派3b</li>
<li>网线</li>
<li>sd卡（8G就够了，要玩nas或docker的可以挂载硬盘）</li>
<li>读卡器</li>
</ol>
<h2 id="刷写固件">1.刷写固件</h2>
<p>可以按照该网址给出步骤操作</p>
<p>https://doc.openwrt.cc/1-General/1-Install-Upgrade/</p>
<p>下面给出我的步骤：</p>
<ol type="1">
<li>下载<a
href="https://www.balena.io/etcher/">Etcher</a>这是一个刷写工具</li>
<li>下载储存还原固件</li>
<li>在软件源站下载进入如下目录<code>/releases/targets/bcm27xx/bcm2710/</code>下载<code>immortalwrt-bcm27xx-bcm2710-rpi-3-ext4-factory.img.gz</code>这是树莓派3b对应的固件下载路径。</li>
</ol>
<blockquote>
<p>树莓派3B和3B+都是Broadcom的cpu，3B是BCM2837A0，3B+是BCM2837B0;
树莓派4B的cpu型号是Broadcom BCM2838. OpenWRT里对应型号是bcm27xx
树莓派3B和3B+的Subtarget都是bcm2710 树莓派4B的Subtarget是bcm2711
所以树莓派3b按步骤3的路径选，其他版本的openwrt同理。[1]</p>
</blockquote>
<p>下好后用Etcher洗掉sd卡的东西然后刷写进固件就可以了。</p>
<h2 id="基础配置">2.基础配置</h2>
<p>给树莓派插卡通电，可以看见一个名为openwrt的wifi，连接（也可以直接插网线）</p>
<p>打开浏览器，输入 http://192.168.1.1 进入路由器后台</p>
<p>输入默认用户名，root 和 password</p>
<p>进入luci界面如下</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200829.png"
alt="openwrt luci界面" />
<figcaption aria-hidden="true">openwrt luci界面</figcaption>
</figure>
<h3 id="管理员密码修改">2.1 管理员密码修改</h3>
<p><code>系统</code>-&gt;<code>管理权</code></p>
<p>改完点一下保存</p>
<h3 id="网络接口">2.2 网络接口</h3>
<p>点击<code>网络</code> -&gt; <code>接口</code>
这里可以配置lan口，点击<code>修改</code></p>
<p>我是当作旁路由使用的，主路由的ip是<code>102.168.3.1</code>所以这里设置格式如下。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2022/12/20221210200809.png"
alt="接口配置" />
<figcaption aria-hidden="true">接口配置</figcaption>
</figure>
<p>改WiFi密码在<code>网络</code>-&gt;<code>无线</code>-&gt;<code>无线安全</code>的加密这改。</p>
<h3 id="拓展">2.3 拓展</h3>
<p>在<code>系统</code>-&gt;<code>软件包</code>中可以安装下载需要的插件。</p>
<p>推荐在下载前扩容一下overlay，相关方法可以看B站BraveRu的视频<a
href="https://www.bilibili.com/video/BV1w541157Uo?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">极其详尽的OpenWRT软路由系统安装与设置教程（物理机安装）</a></p>
<p>插件的名字和功能也可以在网上搜到。</p>
<h2 id="结束">3.结束</h2>
<p>折腾了半天，发现刷一个软路由不能说收获满满，只能说毫无用处。。。</p>
<h2 id="参考资料">参考资料</h2>
<p>[1]
https://www.itgeeker.net/raspberry-3b-3buse-openwrt-pure-org-img-to-install-and-config-socks5-agent-1/</p>
<p>[2] 知乎文章：<a
href="https://zhuanlan.zhihu.com/p/463838793">将树莓派3B刷成OpenWrt软路由，成为魔法WiFi上网的强大路由器</a></p>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>折腾与游戏</category>
      </categories>
      <tags>
        <tag>openwrt</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>信息量和信息熵</title>
    <url>/2022/08/20/2022-8/%E4%BF%A1%E6%81%AF%E9%87%8F%E5%92%8C%E4%BF%A1%E6%81%AF%E7%86%B5/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<p>随着计算机和个人手机的普及，人们常说我们现在进入了信息时代。另一方面，在我们日常互联网使用过程中的产生大数据也和我们的生活息息相关。在每天接触的过程中不知道你有没有考虑过为什么信息是可以被度量的？它又是怎么被计算的？</p>
<span id="more"></span>
<h2 id="概率和信息">1.概率和信息</h2>
<blockquote>
<p>“你这句话信息量真大”</p>
</blockquote>
<p>我们日常就会对信息产生一个笼统的概念，能大致判量的大小。具体而言似乎并不和字数成正比，比如说来段营销号文案。</p>
<blockquote>
<p>信息量和文案字数没有关系是怎么一回事呢，信息相信大家都很熟悉，但是信息量和文案字数没有关系是怎么一回事呢？下面就让小编带大家一起了解吧。大家可能会惊讶信息量和文案字数怎么会没有关系呢？但事实就是这样，小编也很惊讶。这就是关于信息量和文案字数没有关系的全部内容了，大家有什么想法可以在评论区告诉小编一起讨论哦！</p>
</blockquote>
<p>香农提出<strong>信息量应该与事件发生的概率相关，事情发生的概率越小，所包含的信息量就越大</strong>，这也非常好理解，有人对你说“太阳明天从东边升起”和“明天太阳要爆炸了”肯定是后者的信息量较大。</p>
<p>既然一个事件发生的概率(<span
class="math inline">\(P\)</span>)越小，它所包含的信息量就越大。那我们是否能通过一个函数<span
class="math inline">\(f(P)\)</span>来定量描述一下信息量呢。</p>
<p>这可得好好考虑一下。首先信息量的函数<span
class="math inline">\(f(P)\)</span>是一个</p>
<ul>
<li>单调递减函数</li>
<li>定义域是[0,1]</li>
<li><span class="math inline">\(f(1)=0\)</span><br />
</li>
<li><span class="math inline">\(f(0)=\infty\)</span></li>
</ul>
<p>还有一点，信息量应该可以相加表示两个独立的事件同时发生所包含的信息量，又根据概率论两个事件同时发生的概率为<span
class="math inline">\(P_1*P_2\)</span>也就是说，<span
class="math inline">\(f(p_1)+f(p_2)=f(P_1*P_2)\)</span></p>
<p>相信看到这个公式，这个信息量的函数的身份就已经呼之欲出了。对数函数可以完美满足了以上所有的条件。其次为了方便2进制计算机的使用和度量，我们通常采用公式<span
class="math inline">\(f(p) =
-\log_{2}{P}\)</span>来计算信息量。单位就记作bit，负号是为了满足递减的性质。</p>
<p>当然也可以使用10作为对数函数的基底，单位为哈莱特(Hartly);还有以e为基地，单位为奈特(nit)</p>
<h2 id="信息熵">2. 信息熵</h2>
<p>熵和量子这种新构名词听起来就很高大上，但解释起来倒是不难理解，信息量是单个事件的度量，而信息熵是用来表示事件集的平均信息量。</p>
<p>先给出公式，对于一个离散的信号源有</p>
<p><span class="math display">\[
\left[\begin{array}{cccc}
x_{1}, &amp; x_{2}, &amp; \cdots, &amp; x_{M} \\
P\left(x_{1}\right), &amp; P\left(x_{2}\right), &amp; \cdots, &amp;
P\left(x_{M}\right)
\end{array}\right] \text {, 且 } \sum_{i=1}^{M} P\left(x_{i}\right)=1
\]</span></p>
<p>其中<span
class="math inline">\(x_i\)</span>是离散消息，对应二进制计算机就是0和1，<span
class="math inline">\(P(x_i)\)</span>是离散消息<span
class="math inline">\(x_i\)</span>发生的概率。</p>
<p>其信息熵<span class="math inline">\(H(x)\)</span>的计算公式如下：</p>
<p><span class="math display">\[
H(x)=-\sum_{i=1}^{M} P\left(x_{i}\right) \log _{2} P\left(x_{i}\right)
\]</span></p>
<p>这个公式就是将各自的信息量乘以发生的概率然后求和，这有什么用呢？首先作为平均信息量，它可以快速计算一段信息的总信息量，比如说该信号源发生了n位信息，那它的总信息量为<span
class="math inline">\(I = n*H(x)\)</span></p>
<p>其次这个值就代表了数据编码的最小值。中文的信息熵是要高于英语，西班牙语，俄语等主流语言，所以在计算机中中文的文件会比其他语言的要大一些。</p>
<h2 id="存储单位和网速">3.存储单位和网速</h2>
<p>比特(bit)前面也介绍过了，这是计算机中最小的存储单位，8个bit为一个字节(Byte)缩写为B</p>
<p>以字节(Byte)为单元，计算机还有KB，MB，GB，TB换算如下</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">单位换算</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1 Byte = 8 bit</td>
</tr>
<tr class="even">
<td style="text-align: center;">1 KB = 1024 B</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1 MB = 1024 KB</td>
</tr>
<tr class="even">
<td style="text-align: center;">1 GB = 1024 MB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1 TB = 1024 GB</td>
</tr>
</tbody>
</table>
<p>1024是2的10次方，这是计算机里常用的换算方法，对于硬盘厂商的换算还是以1000为单位换算</p>
<p>另外网络线路的计量单位是bps，比特每秒(bits per
second),所以对应我们常说的下载速度KB/MB要除以8.</p>
<h2 id="参考资料">参考资料</h2>
<p>[1] 《通信原理》第七版 曹丽娜 樊昌信</p>
<p>[2] 知乎问题 <a
href="https://www.zhihu.com/question/37998688/answer/489871504">世界上信息熵最大的语言是汉语吗？</a></p>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>逻辑与科普</category>
      </categories>
      <tags>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7搭建mc服务器</title>
    <url>/2022/09/01/2022-9/CentOS7%E6%90%AD%E5%BB%BAmc%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>CentOS
7是一个企业级的Linux发行版本，MC是一款著名的是沙盒类游戏，中国区由网易代理，网易版虽然本体免费，但在可拓展性上远远不及java版。在服务器上运行mc可以较为方便得让多人共同游玩，前提是你有好朋友。</p>
<span id="more"></span>
<p>暑假里用阿里云上白嫖的服务器玩了一个月，现在准备转移阵地，顺便写篇备份一下如何操作的。我使用的是阿里云的服务器mc的版本是1.17.1
附带安装Forge。</p>
<h2 id="安装java环境">1.安装JAVA环境</h2>
<p>连接上你的远程服务器</p>
<p>通过下面的命令安装jdk16</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载JDK安装包，也可以自己去官网下载，如果出错就运行命令 yum install wget</span><br><span class="line">wget https://img.zeruns.tech/down/Java/OpenJDK16U-jdk_x64_linux_hotspot_16.0.1_9.tar.gz</span><br><span class="line"></span><br><span class="line"># 创建安装目录</span><br><span class="line">mkdir /usr/local/java/</span><br><span class="line"></span><br><span class="line"># 解压当前目录下的JDK压缩文件</span><br><span class="line">tar -zxvf OpenJDK16U-jdk_x64_linux_hotspot_16.0.1_9.tar.gz -C /usr/local/java/</span><br></pre></td></tr></table></figure>
<p>通过修改<code>/etc/profile</code>文件来配置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用vi编辑器编辑</span><br><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 用方向键滚动光标到末尾</span><br><span class="line"># 按i进入编辑模式</span><br><span class="line"># 将下面内容复制到文件末尾</span><br><span class="line"># 按esc后用:wq保存并退出</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk-16.0.1+9</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br><span class="line"></span><br><span class="line"># 应用修改后的环境变量</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line"># 软链接程序到环境变量中</span><br><span class="line">ln -sf /usr/local/java/jdk-16.0.1+9/bin/java /usr/bin/java</span><br><span class="line"></span><br><span class="line"># 测试是否安装正常，显示 openjdk version &quot;16.0.1&quot; 则为正常</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>
<h2 id="端口开放">2.端口开放</h2>
<p>在服务器的管理端开启mc服务器的端口，一般在<code>网络与安全-&gt;安全组-&gt;配置规则</code>mc的端口号默认是25565</p>
<p>推荐把tcp和udp都开一下，授权对象选全0</p>
<h3 id="下载服务端">3.下载服务端</h3>
<p>这里服务端的选择有许多种,区别可以看看参考资料[2],原版是官方的纯净版，不能装mod和插件。这里说一下mod和插件的区别，两者都是放在mod文件夹下，但是mod需要服务端和客户端都装，插件只需要服务器装。</p>
<p><a
href="https://www.minecraft.net/en-us/download/server">官方服务端</a></p>
<p><a
href="https://files.minecraftforge.net/net/minecraftforge/forge/">forge</a></p>
<p>找到对应的版本，两者务必要一样，forge是用来拓展mod的，如果你只想玩纯净版下第一个就行了。</p>
<p>我这里以1.17.1版本为例，先将两者放在window的同一目录下，双击<code>forge-1.17.1-37.1.1-installer.jar</code>选择install
server,
再点击三个点，选择我们现在服务器要创建的该文件夹，点击确定，开始安装。安装过程可能会比较慢，这里中间过程有问题可以参考资料[3]</p>
<p>完成后在mod文件夹下放入要装的mods，没有mods文件夹的话自己新建一个,先不放也没事，运行服务器后会自动生成这个mod，有需要后面可以自己加。这里要注意mod和版本的匹配。</p>
<p>在自己电脑上配置，这样做一是操作简便一些，另一是到时候换服务器的时候可以节省这一步，直接上传到服务器上。</p>
<p>如果是新版本，如1.17，服务端会放在libraies里，旧版本会出一个<code>.jar</code>文件参考资料[4]</p>
<p>在服务器上新建一个文件夹，把文件上传上去(最开始的两个.jar文件可以不传)。不知道怎么传的推荐搜索一下mobaxterm</p>
<h3 id="运行服务器">4.运行服务器</h3>
<p>cd到对应目录</p>
<p><code>user_jvm_args.txt</code> 可以自己配置一下内存大小。</p>
<p>运行命令 <code>./run.sh</code></p>
<p>如果提示没有权限，输入<code>chmod +x run.sh</code>给予权限</p>
<p>第一次运行会报错，同时会生成一个eula文件，这是许可文件，把这个文件中的false改为true再启动一次就可以了</p>
<p>运行成功后先<code>stop</code>停止服务器</p>
<p>然后<code>vi server.properties</code>修改配置文件，这里可以自己去查找一下各个值的意思</p>
<p><strong>开服！！</strong></p>
<p>为了让服务器能在后台能一直跑，我们需要创建一个<code>screen</code>
参考资料[5]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装screen</span><br><span class="line">yum install screen</span><br><span class="line"></span><br><span class="line"># 创建一个名为MinecraftServer的screen</span><br><span class="line">screen -S MinecraftServer</span><br><span class="line"></span><br><span class="line"># 启动服务器</span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure>
<p>运行成功后按Ctrl + A +D
，将screen挂起运行,下次进入可以使用下面命令回到screen</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">screen -ls	# 查看screen，记下MinecraftServer的编号</span><br><span class="line">screen -r &lt;MinecraftServer的编号&gt;</span><br></pre></td></tr></table></figure>
<p>现在进入我的世界客户端，注意mod也要配置一致，然后选多人游戏，输入服务器ip即可。给予op权限需要在后台输入<code>op &lt;玩家姓名&gt;</code></p>
<h2 id="参考资料">参考资料</h2>
<p>[1] https://blog.zeruns.tech/archives/636.html</p>
<p>[2] https://zhuanlan.zhihu.com/p/369785741</p>
<p>[3]
https://blog.csdn.net/leleprogrammer/article/details/126120111</p>
<p>[4] https://blog.csdn.net/qq_41228599/article/details/123926758</p>
<p>[5] https://www.cnblogs.com/shiraka/p/14532465.html</p>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>折腾与游戏</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>mc</tag>
      </tags>
  </entry>
  <entry>
    <title>信号与系统(1)--信号与系统</title>
    <url>/2023/05/26/2023-5/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F(1)--%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>信号与系统是电子信息类的专业基础课程，本系列将奥本海姆的《信号与系统》一书，系统地复习该课程。本篇将介绍什么是信号，什么是系统。</p>
<span id="more"></span>
<h2 id="信号">1.信号</h2>
<h3 id="什么是信号">1.1 什么是信号？</h3>
<p>我们的大脑无时无刻不在处理神经元传来的电信号，计算机每一秒都在处理数以亿记的01信号。其中的信号是什么？它们是如何被处理的？在数学上，信号可以表示为一个或多个变量的函数，比如我们接收到了一个语音信号波形如下。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/05/20230529190945.png"
alt="语音信号波形" />
<figcaption aria-hidden="true">语音信号波形</figcaption>
</figure>
<p>这是一句“亮灯”的语音信号波形。这类自变量和应变量都是连续的信号被称为<strong>连续信号</strong>，相反如果一个信号的自变量或应变量是离散值，我们记其为<strong>离散信号</strong>，二者差异可见下图。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230601143053.png"
alt="连续信号和离散信号" />
<figcaption aria-hidden="true">连续信号和离散信号</figcaption>
</figure>
<p>为了区分连续信号和离散信号，我们做出如下约定自变量如果是连续时间，我们记为t，信号函数记为<span
class="math inline">\(x(t)\)</span>。如果是离散时间则记为n，信号函数记为<span
class="math inline">\(x[n]\)</span>。</p>
<h3 id="信号的变换">1.2 信号的变换</h3>
<p>借助数学形式，我们可以将很多时间为自变量的信号都函数化，这样一些函数的性质也可以作用于信号上。一种非常简单但同时很重要的变化例子就是<strong>时移</strong>(time
shift)。在不同位置的接收机收到发射机的信号会因距离不等而造成传播时间上的差别，这就可以使用时移变化来描述。</p>
<p>第二种典型的自变量变化就是<strong>时间反转</strong>(time
reversal)，常见的处理过程就是倒放，另一种处理方法是倍速，对应了<strong>时间尺度变化</strong>(time
scaling)。</p>
<p>综合上述几种变化，对应到数学函数上无非就是<span
class="math inline">\(x(t)\)</span>--&gt;<span
class="math inline">\(x(\alpha t +
\beta)\)</span>。这里变化并不复杂，就不给出具体实例了，需要熟练掌握的可以翻看任意教材的信号变化部分习题。</p>
<h3 id="奇偶与周期">1.3 奇偶与周期</h3>
<p>函数具有奇偶性，如果一个信号以原点为轴反转后不变，就称其为<strong>偶</strong>(even)信号。
<span class="math display">\[
x(-t) = x(t)
\]</span> 如果是 <span class="math display">\[
x(-t)=-x(t)
\]</span> 则称其为<strong>奇</strong>(odd)信号。</p>
<p>一个重要的事实是，任何信号都可以看作是一个奇信号和一个偶信号的和。
<span class="math display">\[
\begin{align}
Ev\left \{  x(t) \right \} = \frac{1}{2}[x(t)+x(-t)] \nonumber \\
Od\left \{ x(t) \right \} = \frac{1}{2}[x(t)-x(-t)]\nonumber
\end{align}
\]</span></p>
<p><strong>周期</strong>(periodic)信号也是一种非常常见的信号，对于一个周期连续时间信号有:</p>
<p><span class="math display">\[
x(t) = x(t+T)
\]</span></p>
<p>其周期为T。如果对于任意的t和任意的整数m都有<span
class="math inline">\(x(t)=x(t+mT)\)</span>则使式成立的最小正值T称为<span
class="math inline">\(x(t)\)</span>的<strong>基波周期</strong>(fundamental
period)。</p>
<h3 id="三角函数与指数">1.4 三角函数与指数</h3>
<p><strong>正弦信号</strong>(sinusoidal
signal)是一种非常典型的信号，其数学表达式为: <span
class="math display">\[
x(t)=A\cos{(\omega_0 t + \phi)}
\]</span></p>
<p>其中通常使用秒作为t的单位，则<span
class="math inline">\(\phi\)</span>的单位为弧度(rad),<span
class="math inline">\(\omega_0\)</span>的单位就是rad/s。</p>
<p>根据欧拉公式，正弦信号可以用<strong>复指数信号</strong>(complex
exponential signal)来表示</p>
<p><span class="math display">\[
A \cos{(\omega_0 t + \phi)}=\frac{A}{2}e^{j\phi}e^{j\omega_0t} +
\frac{A}{2}e^{-j\phi}e^{-j\omega_0t}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
A\cos(\omega_0t+\phi) &amp; = ARe\{ e^{j(\omega_0t+\phi)}\} \\
A\sin(\omega_0t+\phi) &amp; = AIm\{ e^{j(\omega_0t+\phi)}\}
\end{aligned}
\]</span> 其中<span class="math inline">\(Re\)</span>和<span
class="math inline">\(Im\)</span>分别是取实部和取虚部。</p>
<h3 id="能量与功率">1.5 能量与功率</h3>
<p>数学函数可以表示信号，但信号只有结合物理才有实际意义，电信号是常见的信号，例如，设<span
class="math inline">\(v(t)\)</span>和<span
class="math inline">\(i(t)\)</span>分别是阻值为R的电阻上的电压和电流信号，那么其瞬时功率就是：</p>
<p><span class="math display">\[
p(t)=v(t)i(t)=\frac{1}{R}v^2(t)
\]</span></p>
<p>在时间<span
class="math inline">\([t_1,t_2]\)</span>间消耗的总能量为<span
class="math inline">\(\int_{t_1}^{t_2}p(t)dt\)</span>,其<strong>平均功率</strong>(average
power)为:</p>
<p><span class="math display">\[
\frac{1}{t_2-t_1}\int_{t_1}^{t_2}p(t)dt
=  \frac{1}{t_2-t_1}\int_{t_1}^{t_2}\frac{1}{R}v^2(t)dt
\]</span></p>
<p>根据平均功率，我们可以将信号分为三类：</p>
<ol type="1">
<li>有限能量信号(<span class="math inline">\(E_\infty &lt;
\infty\)</span>),这类信号的平均功率必须为0，否则积分后能量就会变成无穷大</li>
<li>有限功率信号(<span class="math inline">\(P_\infty &lt;
\infty\)</span>)，这类信号能量是无穷大的，但平均功率不是。</li>
<li>无限功率信号，一个典型的例子是<span class="math inline">\(x(t) =
t\)</span></li>
</ol>
<h3 id="单位阶跃与单位脉冲">1.6 单位阶跃与单位脉冲</h3>
<p>连续时间的单位阶跃函数<span
class="math inline">\(u(t)\)</span>的定义是</p>
<p><span class="math display">\[
u(t) =
\left \{ \begin{matrix}
  0, t &lt; 0\\
1, t&gt;0
\end{matrix}\right.
\]</span></p>
<p>单位阶跃再<span
class="math inline">\(t=0\)</span>点处是不连续的，对其取一次微分就得到了冲激函数<span
class="math inline">\(\delta(t)\)</span>,这个函数在数学中是不存在的，但是在物理学中它很好用于是就被拿来用了。在工学中这个函数也是极具理论价值，但为了能实际应用，冲激函数被近似认为是非常短的时间间隔<span
class="math inline">\(\Delta\)</span>内完成的从0到1的阶跃函数的微分。</p>
<p>离散时间的单位脉冲和单位阶跃序列也是同理，积分和微分分别对应求和和差分。</p>
<h2 id="系统">2.系统</h2>
<h3 id="什么是系统">2.1 什么是系统？</h3>
<p>在实际过程中信号仅仅是作为输入或者输出的一部分内容，信号是如何被处理的还得通过系统。通常使用如下的方式来表示连续时间的输入输出关系：</p>
<p><span class="math display">\[
x(t) \to y(t)
\]</span></p>
<p>同理，离散的表示符号为：</p>
<p><span class="math display">\[
x[n] \to y[n]
\]</span></p>
<p>还是以电路作为例子，下面是一个简单的RC电路：</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230602173436.png"
alt="RC电路" />
<figcaption aria-hidden="true">RC电路</figcaption>
</figure>
<p>这可以看作是一个简单的系统，其中输入电压是<span
class="math inline">\(u_i(t)\)</span>,输出信号是<span
class="math inline">\(u_o(t)\)</span>，根据欧姆定律有，流经电阻的电流<span
class="math inline">\(i(t)\)</span>应当正比于电阻上的电压。</p>
<p><span class="math display">\[
i(t) = \frac{u_i(t)-u_o(t)}{R}
\]</span></p>
<p>同时电流还可以通过电容器上的电压变化率计算得到：</p>
<p><span class="math display">\[
i(t) = C\frac{du_o(t)}{dt}
\]</span></p>
<p>联立两式即可得到输入输出的微分关系方程</p>
<p><span class="math display">\[
\frac{du_o(t)}{dt} +\frac{1}{RC}u_o(t) = \frac{1}{RC} v_i(t)
\]</span></p>
<p>这是一个非常常见的系统，同时也是一个简单的一阶线性微分方程，这样一来系统也数学化了，系统代表了一个方程或者等式。</p>
<h3 id="系统的互联">2.2 系统的互联</h3>
<p>很多实践中的系统其实都是非常简单的系统组合而成，常见的组合方法有<strong>串联</strong>(series
interconnection)或<strong>级联</strong>(cascade
interconnection)、<strong>并联</strong>(parallel
interconnection)、<strong>反馈互联</strong>(feedback
interconnection)。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230607145902.png"
alt="互联" />
<figcaption aria-hidden="true">互联</figcaption>
</figure>
<p>虽然图像表示得已经很清楚了，这里还是需要补充一些。</p>
<p>级联通常发生在对信号连续处理的过程，比如收音机收到信号后进行解调后通过放大器放大信号。反馈也是一个重要的系统类型，比如在定速巡航中，汽车会通过监控车速来控制能量的传递，而车速快慢是由发动机提供的能量决定的。</p>
<p>最后这三种互联方式也可以进行彼此间组合形成更复杂的系统。</p>
<h3 id="系统的性质">2.3 系统的性质</h3>
<h4 id="记忆性">2.3.1 记忆性</h4>
<p>如果系统的输出仅仅取决于该时刻的输入，该系统就被称为<strong>无记忆(memoryless)系统</strong>，一个简单的例子就是<strong>恒等系统(identitiy
system)</strong>,该系统的输出就等于输入。</p>
<p>一个典型的有记忆系统就是积分器，或者对应离散信号的<strong>累加器(accumulator)</strong>。在实际中，使用储能元件，如电容，就可以实现这一系统。又记忆系统不仅包括存储过去信息，存储将来信息也算是有记忆系统。</p>
<h4 id="可逆性">2.3.2 可逆性</h4>
<p>一个系统如果在不同输入下会产生不同输出，该系统就是<strong>可逆的(invertible)</strong>,它就会有一个对应<strong>逆系统(inverse
system)</strong>,当原系统和逆系统进行级联后，输入就会等于输出，系统就变成了一个恒等系统。</p>
<p>不可逆系统的不同输入可能会对应同一种输出，比如说<span
class="math inline">\(y(t)=x^2(t)\)</span>。</p>
<h4 id="因果性">2.3.3 因果性</h4>
<p>如果一个系统在任何时刻的输出只取决于现在的输入和过去的输入，该系统就被称为<strong>因果(causal)</strong>系统。因果系统是无法根据输出预测未来的输入值的，且对于一个因果系统两个输入直到某一时间都是相同的，那其输出必然相同。</p>
<p>时间相关的现实系统几乎都是因果的，但对于一些数据处理系统，它并不局限于因果，比如图像处理中的窗口平滑系统。</p>
<h4 id="稳定性">2.3.4 稳定性</h4>
<p><strong>稳定性(stability)</strong>是指系统在很小的输入下响应不会发散。如单摆、RC电路中，能量会逐渐消耗并趋向于稳定。而对于不稳定系统，其输出会不断增加，想要判别系统是不稳定系统就学要找出一个特定的有界的输入使得输出无界。</p>
<h4 id="线性">2.3.5 线性</h4>
<p>线性系统的一个重要特征就是<strong>叠加性质(superposition
property)</strong>，叠加性说的是：如果系统的输入是几个信号的加权和组成，那么输出信号也是每一个输入信号通过系统后的输出加权和。</p>
<p>用公式表示，简记小写字母为输入，大写字母为系统的对应输出,系统为函数f，输入为a时输出为<span
class="math inline">\(A=f(a)\)</span>。</p>
<p>对于系统有，当<span class="math inline">\(a=b+c+d\)</span>时，<span
class="math inline">\(A=f(b)+f(c)+f(d)=B+C+D\)</span>。这被称为<strong>可加性(additivity)</strong>。还是这个系统，<span
class="math inline">\(k_1\)</span>是一个常数，当输入<span
class="math inline">\(k_1a\)</span>时，输出<span
class="math inline">\(A=k_1f(a)\)</span>。这被称为<strong>齐次性(homogeneity)</strong></p>
<h4 id="时不变性">2.3.6 时不变性</h4>
<p>通俗来说，只要系统的特性和行为不随时间改变，这个系统就是时不变的。今天研发出的系统到了明天性质就变了，那我们就失去了研发的意义，因此时不变性也是非常重要的一个性质。在实际生活中线性时不变系统是最为常用的一种系统。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>电子</category>
      </categories>
      <tags>
        <tag>电子信息</tag>
        <tag>信号与系统</tag>
      </tags>
  </entry>
  <entry>
    <title>像差理论</title>
    <url>/2023/11/24/2023-11/%E5%83%8F%E5%B7%AE%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>像差（Aberration）是光学系统中常见的一个概念，用于描述由于光线在透镜或镜面上折射或反射时引起的偏差或失真。像差理论涉及到光线聚焦时产生的偏离理想图像的情况，本文将针对不同类型的像差做出形成原因的介绍，并提供简单的消除的方法。</p>
<span id="more"></span>
<h2 id="像差分类和多色像差">1.像差分类和多色像差</h2>
<p>对于一个简单的光学系统，假设物是一个垂直于光学系统主轴的平面，完美的像就需要包括以下几个条件</p>
<ol type="1">
<li>上面的每一个发光点应该成一个清晰的像点。</li>
<li>所有的像点必须在同一平面，且该平面也要垂直于光学系统的主轴</li>
<li>各个像点的横向放大率必须都是常数</li>
<li>像的各个部分应该和物有相同的颜色</li>
</ol>
<p>如果条件12不满足，像就会出现模糊不清晰的情况；如果23不满足，像会出现变形；如果4不满足，像会出现<strong>色差</strong>。</p>
<p>色差通常来说是由于光学材料的色散引起的，具体表现为在图片中出现颜色偏差的情况，如下图。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231124141022.png"
alt="色差" />
<figcaption aria-hidden="true">色差</figcaption>
</figure>
<p><a href="https://zhuanlan.zhihu.com/p/486148333">图片来源</a></p>
<p>根据不同平面的波长色散，色差可以分为两种类型：纵向色差（子午色差）和横向色差（弧矢色差）。子午色差可以通过缩小镜头光圈来大幅度减少。使用类似冕玻璃（低折射低色散）和火石玻璃（高折射高色散）组合形成的复合透镜也是消除色差的。</p>
<p>单色像差的分类就比较多了，如近轴物宽光束引起的球差和慧差，远轴物窄光束引起的像散，场曲和畸变。</p>
<h2 id="球差">2.球差</h2>
<p>主轴上的一个物点所发出的宽光束由透镜折射后并不会聚于单独的一个像点，而是成为弥散的圆斑，这种现象被称为球差。球差的形成原因是光线通过光学系统后的射线与主轴的交点不重合。球差也是唯一的轴上像差。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231124152414.png"
alt="球差" />
<figcaption aria-hidden="true">球差</figcaption>
</figure>
<p><a href="https://zhuanlan.zhihu.com/p/73397254">图片来源</a></p>
<p>球差的一种朴素解决方法是缩小光圈，进入的光线越是接近主轴越是趋向于理想成像。其次是使用非球面透镜，这种透镜有复杂的曲率形状，使得光线更均匀的聚焦，但是会给加工带来很大的麻烦。目前较优的解决方案是使用复合透镜，通过将多个透镜组合在一起，使得每个透镜的球差效应相互抵消，从而减少整个系统的球差影响。</p>
<h2 id="慧差">3.慧差</h2>
<p>慧差是光学系统中常见的一种像差，它导致来自非轴向点源的光线在焦点上形成呈彗星状的像。在宽光束大视场的情况下会尤为明显。</p>
<p>校准方式：孔径和视场都会影响慧差，一种方法是缩小孔径和视场，但通常不这么使用。第二是利用对称光学系统，以<span
class="math inline">\(\beta = -1\)</span>成像。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2024/01/20240106154449.png"
alt="慧差" />
<figcaption aria-hidden="true">慧差</figcaption>
</figure>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231124165233.png"
alt="对称系统" />
<figcaption aria-hidden="true">对称系统</figcaption>
</figure>
<p>但这种严格对称系统，不具备放大像的作用，在一些其他场景通常会做相对的取舍。</p>
<h2 id="像散">4.像散</h2>
<p>子午像点和弧矢像点不重合。通常在实际中会被慧差遮盖无法直观看出。主要受到视场影响，处理方法一是控制视场，二是使用柱状镜。像散在眼科中被称为散光，像散对成像质量的影响会比慧差小一些，更像是窄光束下的慧差。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2024/01/20240106154520.png"
alt="像散" />
<figcaption aria-hidden="true">像散</figcaption>
</figure>
<h2 id="场曲">5.场曲</h2>
<p>场曲又被称为像面弯曲。轴外物点对各光线的交点偏离高斯像面的距离被称为场曲，发生场曲后的成像最佳像面是曲面。像散的产生必然导致场曲，但存在场曲不一定有色散。</p>
<p>校准方法：正负光焦度组合（正负透镜组，弯月型厚透镜）</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2024/01/20240106154558.png"
alt="场曲" />
<figcaption aria-hidden="true">场曲</figcaption>
</figure>
<h2 id="畸变">5.畸变</h2>
<p>畸变又被称为失真，不同视场的主光线通过光学系统后与高斯像面的交点高度不等于理想高度，其中的差异就是畸变。场曲是成像是曲面，畸变是指像面上的成像出现弯曲。根据凸出的方向可以分为桶型畸变和枕型畸变。畸变只会影响像形状不会影响清晰度。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231124181015.png"
alt="畸变1" />
<figcaption aria-hidden="true">畸变1</figcaption>
</figure>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2024/01/20240106154632.png"
alt="畸变2" />
<figcaption aria-hidden="true">畸变2</figcaption>
</figure>
<p>校准方法：一是利用对称光学系统，以<span class="math inline">\(\beta =
-1\)</span>成像。二是设置孔径光阑位置</p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li><a
href="https://www.bilibili.com/video/BV1J84y1v7Jy/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">工程光学-光学设计篇-像差-慧差、像散</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>物理</category>
      </categories>
      <tags>
        <tag>光学</tag>
      </tags>
  </entry>
  <entry>
    <title>加速度传感器校准方法分析</title>
    <url>/2023/11/16/2023-11/%E5%8A%A0%E9%80%9F%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%A1%E5%87%86%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>为防止俯仰角、四元数等概念干扰主题，这里以测xy平面角度的水平尺应用为例介绍加速度传感器的误差来源与校准方法，使用两个维度便于理解，扩展到多个维度同理可得。</p>
<span id="more"></span>
<h2 id="加速度传感器原理">加速度传感器原理</h2>
<p>根据牛顿第二定律<span
class="math inline">\(F=ma\)</span>可知测量加速度等价于测量受力，在三维笛卡尔空间中，力又可以分解为三个坐标轴上的分量。因此在一个轴上，传感器可以简化等效为下图模型。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231116092435.png"
alt="加速度传感器原理" />
<figcaption aria-hidden="true">加速度传感器原理</figcaption>
</figure>
<p>传感器芯片通过电容读取到加速度的大小并进行编码，总线上发出指令后它就会将测量到的数据传输出来。三轴应用最广泛的是在手机上，用于检测手机的朝向并进行屏幕的翻转。</p>
<p>测量xy平面的角度需要两个轴，计算方法就是简单的三角函数<span
class="math inline">\(\arctan(\frac{y}{x})\)</span>，示意图如下。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231116092457.png"
alt="角度计算" />
<figcaption aria-hidden="true">角度计算</figcaption>
</figure>
<h2 id="误差分析">误差分析</h2>
<p>实际使用三角函数公式去处理传感器的返回值得到的角度肯定是不准确的，因为传感器的测量值本身存在误差。下面是几个典型的误差。</p>
<h3 id="零点偏移">零点偏移</h3>
<p>零点偏移是指在实际值为0g的时候传感器的输出值，示意图如下。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231116092516.png"
alt="零点偏移" />
<figcaption aria-hidden="true">零点偏移</figcaption>
</figure>
<p>零点偏移产生的原因有很多种，比如出厂时Proof
Mass并没有在中间的位置，温度也会影响零点位置。这里统一视作是零点偏移。这部分误差使用加减差值来处理。</p>
<h3 id="尺度误差">尺度误差</h3>
<p>这部分的误差来自于传感器的数字信号向物理量转换的误差，就和尺子一样，如果其刻度不均匀，量出的值也会不同。在测角度案例中通常体现为不同轴的数值不能等价。</p>
<p>这部分误差可以通过缩放来处理。</p>
<h3 id="正交误差">正交误差</h3>
<p>传感器的三个轴不一定是完全正交的，这个很好理解就不多解释了。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231116092710.png"
alt="正交误差" />
<figcaption aria-hidden="true">正交误差</figcaption>
</figure>
<h3 id="机械误差">机械误差</h3>
<p>这部分误差是指传感器在贴片和组装为成品过程中产生的误差。</p>
<h3 id="随机误差">随机误差</h3>
<p>白噪声和随机游走等干扰也会对测量产生误差，这类随机误差通常需要ALLAN方差校准来处理，也是比较难消除的一类误差。</p>
<h2 id="校准方法">校准方法</h2>
<h3 id="粗略校准法">粗略校准法</h3>
<p>在一个水平面上正向测出数据，如何旋转180°测得第二个值，在90°面上重复这一操作。可以获得4个数据，分别记为:</p>
<p><span class="math display">\[
[x_{max},y_{o1}],
[x_{min},y_{o2}],
[x_{o1},y_{max}],
[x_{o2},y_{min}]
\]</span></p>
<p>可以获得零偏和尺度，<span class="math inline">\(X_{offset} =
\frac{x_{max}+x_{min}}{2}\)</span>,<span
class="math inline">\(Y_{offset} =
\frac{y_{max}+y_{min}}{2}\)</span>,<span class="math inline">\(S_{x} =
\frac{x_{max}-x_{min}}{2}\)</span>,<span class="math inline">\(S_{y} =
\frac{y_{max}-y_{min}}{2}\)</span></p>
<p>当然这是非常简单粗暴的做法。</p>
<h3 id="六面校准法">六面校准法</h3>
<p>结合上述的噪声(Bias and Noise)、尺度因子(Scale errors)和轴偏差(Axis
misalignments)。建立加速度传感器的测量模型如下</p>
<p><span class="math display">\[
a^{B} = R T K (a^S + b + \nu)
\]</span></p>
<p>其中<span
class="math inline">\(a^{B}\)</span>表示正交参考系坐标系下的加速度值，<span
class="math inline">\(a^S\)</span>表示传感器对应的非正交坐标系下的加速度值，R表示机械误差的旋转校正矩阵，T表示轴偏校正的变化矩阵，K表示尺度因子，<span
class="math inline">\(b\)</span>和<span
class="math inline">\(\nu\)</span>分别表示零偏和随机噪声。</p>
<p>以两个轴为例，a是一个<span
class="math inline">\(2\times1\)</span>的矩阵，RTK相乘视作一个<span
class="math inline">\(2\times2\)</span>的矩阵，忽略<span
class="math inline">\(\nu\)</span>，将<span
class="math inline">\(b\)</span>视作常数。可以得到如下方程</p>
<p><span class="math display">\[
\begin{bmatrix}
A_x\\A_y
\end{bmatrix}=\begin{bmatrix}
a &amp; b\\
c &amp; d
\end{bmatrix}\begin{bmatrix}
A_{mx}\\A_{my}
\end{bmatrix}+\begin{bmatrix}
off_x\\off_y
\end{bmatrix}
\]</span></p>
<p>变为齐次方程坐标形式有</p>
<p><span class="math display">\[
\begin{bmatrix}
A_{mx}&amp;A_{my}&amp;1
\end{bmatrix}\begin{bmatrix}
a &amp; c  \\
b &amp; d  \\
off_x &amp; off_y
\end{bmatrix} = \begin{bmatrix}
A_x &amp; A_y
\end{bmatrix}
\]</span></p>
<p>使用最小二乘法求解上述方程，<span class="math inline">\(\beta = (X^T
X)^{-1}X^T Y\)</span>，其中<span
class="math inline">\(\beta\)</span>是参数矩阵，X是测量值，Y是理论值。理论值是将传感器按轴向位置放置测量。这里只给出了2个轴向的方程推导，3轴校准也是同理，参见参考资料<a
href="#refer-anchor-1"><sup>[2]</sup></a></p>
<h3 id="椭圆校准法">椭圆校准法</h3>
<p>理想的xy轴数据在坐标系中的分布应当为圆形，但由于受到误差影响，实际会呈现出椭圆形状，如下图所示</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231116092732.png"
alt="椭圆数据点" />
<figcaption aria-hidden="true">椭圆数据点</figcaption>
</figure>
<p>椭圆的方程为</p>
<p><span class="math display">\[
\left ( \frac{x-x_0}{A} \right )^2 + \left (  \frac{y-y0}{B} \right ) ^2
= 1
\]</span></p>
<p>其中<span class="math inline">\(x_0\)</span>和<span
class="math inline">\(y_0\)</span>为椭圆中心的偏移值即零偏误差，<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>是椭圆的两个轴即尺度因子。所以通过最小二乘法拟合椭圆参数即可得到校准值。将上式展开有</p>
<p><span class="math display">\[
x^2+ay^2+cx+dy+f = 0
\]</span></p>
<p>其中<span class="math inline">\(a = \frac{A^2}{B^2},c =
-2x_0,d=-2Y_0\frac{A^2}{B^2},f = x_0^2 +  \frac{A^2}{B^2}y_0^2 -
A^2\)</span></p>
<p>取误差函数为</p>
<p><span class="math display">\[
e_i(a,c,d,f) = x_i^2+ay_i^2+cx_i+dy_i+f
\]</span></p>
<p>则误差的平方和为</p>
<p><span class="math display">\[
E_i = \sum_{i=1}^{N} e_i^2
\]</span></p>
<p>要求对<span
class="math inline">\(a,c,d,f\)</span>的一阶偏导为零，可得方程组</p>
<p><span class="math display">\[
\left\{\begin{matrix}
\frac{\partial E}{\partial a}=0\\
\frac{\partial E}{\partial c}=0\\
\frac{\partial E}{\partial d}=0\\
\frac{\partial E}{\partial f}=0
\end{matrix}\right.  \Longrightarrow
\left\{\begin{matrix}
\sum_{i=1}^{N}  e_i y_i^2 = 0\\
\sum_{i=1}^{N}  e_i x_i = 0\\
\sum_{i=1}^{N}  e_i y_i = 0\\
\sum_{i=1}^{N}  e_i = 0
\end{matrix}\right.
\]</span></p>
<p>使用<span class="math inline">\(\bar{x}\)</span>代替平均值<span
class="math inline">\(\frac{1}{N}\sum_{i=1}^{N}x_i\)</span>的记法，将上式展开，有</p>
<p><span class="math display">\[
\left\{\begin{matrix}
\overline{x^2y^2} + a \overline{y^4} + c\overline{xy^2} + d
\overline{y^3} + f \overline{y^2} = 0  \\
\overline{x^3} + a \overline{x y^2} + c\overline{x^2} + d \overline{xy}
+ f \overline{x} = 0\\
\overline{x^2y} + a \overline{y^3} + c\overline{xy} + d \overline{y^2} +
f \overline{y} = 0 \\
\overline{x^2} + a \overline{y} + c\overline{x} + d \overline{y} + f  =
0
\end{matrix}\right.
\]</span></p>
<p>写成矩阵形式有</p>
<p><span class="math display">\[
\begin{bmatrix}
\overline{y^4} &amp; \overline{xy^2} &amp; \overline{y^3} &amp;
\overline{y^2}\\
\overline{x y^2} &amp; \overline{x^2} &amp; \overline{xy} &amp;
\overline{x}\\
\overline{y^3} &amp; \overline{xy} &amp; \overline{y^2} &amp;
\overline{y}\\
\overline{y} &amp; \overline{x} &amp; \overline{y} &amp; 1
\end{bmatrix}\begin{bmatrix}
a\\
c\\
d\\
f
\end{bmatrix} = \begin{bmatrix}
-\overline{x^2y^2}\\
-\overline{x^3}\\
-\overline{x^2y} \\
-\overline{x^2}
\end{bmatrix}
\]</span></p>
<p>求解方程即可计算出几个参数的值，使用python进行数据计算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">&quot;data.csv&quot;</span>)</span><br><span class="line">x = np.array(data.loc[:, <span class="string">&quot;x&quot;</span>])</span><br><span class="line">y = np.array(data.loc[:, <span class="string">&quot;y&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_points = <span class="built_in">len</span>(x)</span><br><span class="line"><span class="comment"># 绘制数据点</span></span><br><span class="line">plt.scatter(x, y, label=<span class="string">&#x27;Data Points&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次统计平均</span></span><br><span class="line">x_var = <span class="built_in">sum</span>(x)/num_points</span><br><span class="line">y_var = <span class="built_in">sum</span>(y)/num_points</span><br><span class="line"><span class="comment"># 二次统计平均</span></span><br><span class="line">xx_var = <span class="built_in">sum</span>(x**<span class="number">2</span>)/num_points</span><br><span class="line">yy_var = <span class="built_in">sum</span>(y**<span class="number">2</span>)/num_points</span><br><span class="line">xy_var = <span class="built_in">sum</span>(x*y)/num_points</span><br><span class="line"><span class="comment"># 三次统计平均</span></span><br><span class="line">xxx_var = <span class="built_in">sum</span>(x*x*x)/num_points</span><br><span class="line">yyy_var = <span class="built_in">sum</span>(y*y*y)/num_points</span><br><span class="line">xxy_var = <span class="built_in">sum</span>(x*x*y)/num_points</span><br><span class="line">xyy_var = <span class="built_in">sum</span>(x*y*y)/num_points</span><br><span class="line"><span class="comment"># 四次统计平均</span></span><br><span class="line">xxxx_var = <span class="built_in">sum</span>(x*x*x*x)/num_points</span><br><span class="line">yyyy_var = <span class="built_in">sum</span>(y*y*y*y)/num_points</span><br><span class="line">xxyy_var = <span class="built_in">sum</span>(x*x*y*y)/num_points</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A0 = np.array([[yyyy_var,xyy_var,yyy_var,yy_var],</span><br><span class="line">              [xyy_var,xx_var,xy_var,x_var],</span><br><span class="line">              [yyy_var,xy_var,yy_var,y_var],</span><br><span class="line">              [yy_var,x_var,y_var,<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">b = np.array([-xxyy_var,-xxx_var,-xxy_var,-xx_var]).T</span><br><span class="line"></span><br><span class="line">A1 = np.linalg.inv(A0)</span><br><span class="line">resoult = np.dot(A1,b)</span><br><span class="line"></span><br><span class="line">x0 = -resoult[<span class="number">1</span>]/<span class="number">2</span></span><br><span class="line">y0 = -resoult[<span class="number">2</span>]/(<span class="number">2</span>*resoult[<span class="number">0</span>])</span><br><span class="line">AA = np.sqrt(x0*x0 + resoult[<span class="number">0</span>]*y0*y0 - resoult[<span class="number">3</span>])</span><br><span class="line">BB = AA/np.sqrt(resoult[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x0,y0,AA,BB)</span><br><span class="line"><span class="comment"># 生成角度值</span></span><br><span class="line">theta = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算椭圆上的点坐标</span></span><br><span class="line">x_fit = x0 + AA * np.cos(theta)</span><br><span class="line">y_fit = y0 + BB * np.sin(theta)</span><br><span class="line">plt.plot(x_fit, y_fit, color = <span class="string">&#x27;r&#x27;</span>,label=<span class="string">&#x27;fit ellipse&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Ellipse Fit&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>拟合结果如下：</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/11/20231116092754.png"
alt="椭圆拟合结果" />
<figcaption aria-hidden="true">椭圆拟合结果</figcaption>
</figure>
<p>椭球校准推导和matlab代码见参考资料<a
href="#refer-anchor-1"><sup>[3]</sup></a></p>
<h2 id="参考资料">参考资料</h2>
<div id="refer-anchor-1">

</div>
<ol type="1">
<li><a
href="https://zhuanlan.zhihu.com/p/544296512">IMU原理介绍及误差分析</a></li>
<li><a
href="https://www.cnblogs.com/buxiaoyi/p/7541974.html">IMU误差模型和校准</a></li>
<li><a
href="https://blog.csdn.net/hj199404182515/article/details/59480954">空间二次曲面数据拟合算法推导及仿真分析</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>电子</category>
      </categories>
      <tags>
        <tag>电子信息</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言复习-基础篇</title>
    <url>/2023/04/22/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>简单复习一下C语言。</p>
<p>进阶篇：<a
href="https://splendidwave.github.io/2023/04/23/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E8%BF%9B%E9%98%B6%E7%AF%87/">C语言复习-进阶篇</a></p>
<span id="more"></span>
<h2 id="c程序的构成">1.C程序的构成</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> <span class="comment">//头文件、预处理</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;      <span class="comment">//定义主函数（主函数只能有一个）</span></span><br><span class="line">  <span class="comment">//定义变量（C语言的变量要定义后才能使用）</span></span><br><span class="line">  <span class="comment">//程序主体</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello word\n&quot;</span>); <span class="comment">//输出结果（每一行结束都要有分号）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译过程：源程序(.c)--编译--&gt;目标程序(.obj)--链接--&gt;可执行程序(.exe)</p>
<h2 id="关键字">2.关键字</h2>
<p>大部分内容参考自知乎文章<a
href="https://zhuanlan.zhihu.com/p/37908790">C语言中32个关键字详解</a></p>
<h3 id="基本数据类型5个">2.1 基本数据类型（5个）</h3>
<p>注：括号内字节数指在32位arm处理器下</p>
<ul>
<li>void：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果</li>
<li>char：字符型类型数据，属于整型数据的一种（1个字节）</li>
<li>int：整型数据，通常为编译器指定的机器字长(4个字节)</li>
<li>float：单精度浮点型数据，属于浮点数据的一种(4个字节)</li>
<li>double：双精度浮点型数据，属于浮点数据的一种（8个字节）</li>
</ul>
<p>注：C中没有string类型，要使用需要头文件里定义<code>#include&lt;string.h&gt;</code>,C++里的定义是<code>#include&lt;string&gt;</code>，字符串的结尾为<code>'\0'</code></p>
<p>注：指针都是4个字节</p>
<h3 id="修饰关键字4个">2.2 修饰关键字（4个）</h3>
<ul>
<li>short：修饰int，短整型数据，可省略被修饰的int（2个字节）</li>
<li>long：修饰int，长整形数据，可省略被修饰的int（4个字节 long long
8个字节）</li>
<li>signed：修饰整型数据，有符号数据类型</li>
<li>unsigned：修饰整型数据，无符号数据类型</li>
</ul>
<h3 id="复杂类型关键字5个">2.3 复杂类型关键字（5个）</h3>
<ul>
<li>struct：结构体声明 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义数据类型，一些类型集合组成的一个类型</span></span><br><span class="line"><span class="comment">//语法   struct 类型名称  &#123;成员列表&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//分数</span></span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;s3;</span><br></pre></td></tr></table></figure></li>
<li>union：共用体声明 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个联合变量（共用体）的长度等于各成员中最长的长度</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">StateMachine</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> character;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="type">char</span> *str;</span><br><span class="line"><span class="type">double</span> <span class="built_in">exp</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//StateMachine 的空间大小就是double 数据类型的大小</span></span><br><span class="line"><span class="comment">//在C++里，union 的成员默认属性页为public。</span></span><br><span class="line"><span class="comment">//union 主要用来压缩空间。如果一些数据不可能在同一时间同时被用到，则可以使用union。</span></span><br><span class="line"><span class="comment">//一种常见的手法是使用union判断存储方式是大端还是小端。</span></span><br></pre></td></tr></table></figure></li>
<li>enum：枚举声明 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">season</span> &#123;</span> spring, summer, autumn, winter &#125;;</span><br><span class="line"><span class="comment">//默认情况下spring为0，summer为1，依此类推。也可以自行赋值</span></span><br><span class="line"><span class="comment">//可以默认安排值，主要是阅读方便</span></span><br></pre></td></tr></table></figure></li>
<li>typedef：声明类型别名</li>
<li>sizeof：得到特定类型或特定类型变量的大小</li>
</ul>
<h3 id="存储级别关键字6个">2.4 存储级别关键字（6个）</h3>
<ul>
<li>auto：指定为自动变量，由编译器自动分配及释放。通常在栈上分配</li>
<li>static：指定为静态变量，分配在静态变量区。修饰函数时，指定函数作用域为文件内部。</li>
<li>register：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数</li>
<li>extern：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的对象的一个“引用”</li>
<li>const：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在防御性编程中可以多用const</span><br></pre></td></tr></table></figure></li>
<li>volatile：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//volatile通常用于如下三种情况</span><br><span class="line">//1.程序使用RTOS，多线程中都会读写的全局变量</span><br><span class="line">//2.中断和主函数中都要读写的全局变量</span><br><span class="line">//3.单片机的寄存器定义</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="跳转结构关键字4个">2.5 跳转结构关键字（4个）</h3>
<ul>
<li>return：用在函数体中，返回特定值（或者是void值，即不返回值）</li>
<li>continue：结束当前循环，开始下一轮循环</li>
<li>break：跳出当前循环或switch结构</li>
<li>goto：无条件跳转语句</li>
</ul>
<h3 id="分支结构关键字5个">2.6 分支结构关键字（5个）</h3>
<ul>
<li>if：条件语句</li>
<li>else：条件语句否定分支（与if连用）</li>
<li>switch：开关语句（多重分支语句）</li>
<li>case：开关语句中的分支标记</li>
<li>default：开关语句中的“其他”分治，可选</li>
</ul>
<h3 id="循环结构关键字3个">2.7 循环结构关键字（3个）</h3>
<ul>
<li>for：for(1;2;3)4;的执行顺序为1-&gt;2-&gt;4-&gt;3-&gt;2...循环，其中2为循环条件</li>
<li>do：do 1 while(2);的执行顺序是1-&gt;2-&gt;1...循环，2为循环条件</li>
<li>while：while(1) 2;的执行顺序是1-&gt;2-&gt;1...循环，1为循环条件</li>
</ul>
<h2 id="输入输出">3.输入输出</h2>
<h3 id="转义字符表">3.1 转义字符表</h3>
<table>
<thead>
<tr class="header">
<th>转义字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>\'</code></td>
<td>单引号</td>
</tr>
<tr class="even">
<td><code>\"</code></td>
<td>双引号</td>
</tr>
<tr class="odd">
<td><code>\\</code></td>
<td>反斜杠</td>
</tr>
<tr class="even">
<td><code>\n</code></td>
<td>换行符</td>
</tr>
<tr class="odd">
<td><code>\r</code></td>
<td>回车符</td>
</tr>
<tr class="even">
<td><code>\t</code></td>
<td>制表符</td>
</tr>
<tr class="odd">
<td><code>\b</code></td>
<td>退格符</td>
</tr>
<tr class="even">
<td><code>\f</code></td>
<td>换页符</td>
</tr>
<tr class="odd">
<td><code>\v</code></td>
<td>垂直制表符</td>
</tr>
<tr class="even">
<td><code>\a</code></td>
<td>响铃符</td>
</tr>
<tr class="odd">
<td><code>\0</code></td>
<td>空字符</td>
</tr>
</tbody>
</table>
<h3 id="printf函数">3.2 printf()函数</h3>
<p>这个函数用于将格式化的字符串输出到标准输出流（通常是终端）。printf()函数的常见用法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!&quot;</span>);  <span class="comment">// 输出简单的字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My age is %d&quot;</span>, age);  <span class="comment">// 输出格式化的字符串</span></span><br></pre></td></tr></table></figure>
<p>其中，%d是一个占位符，用于表示将要输出的变量的数据类型。例如，上面的代码中，%d表示将要输出一个整数类型的变量age。</p>
<p>下面是类型符号及其含义 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%d - 整型格式说明符，用于输出整数值。</span><br><span class="line">%f - 浮点型格式说明符，用于输出浮点数值。</span><br><span class="line">%c - 字符型格式说明符，用于输出单个字符。</span><br><span class="line">%s - 字符串格式说明符，用于输出字符串值。</span><br><span class="line">%p - 指针型格式说明符，用于输出内存地址。</span><br><span class="line">%x 或 %X - 十六进制格式说明符，用于以十六进制格式输出整数值。</span><br><span class="line">%o - 八进制格式说明符，用于以八进制格式输出整数值。</span><br><span class="line">%e 或 %E - 科学计数法格式说明符，用于以科学计数法格式输出浮点数值。</span><br><span class="line">%g 或 %G - 自动格式说明符，根据输出变量的大小决定使用 %f 或 %e 格式。</span><br></pre></td></tr></table></figure></p>
<p>通过在百分号后面加指令可以控制固定精度输出，如<code>%.2f</code>指输出小数点后2位的浮点数。
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="type">float</span> pi = <span class="number">3.1415926535</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi = %.3f\n&quot;</span>, pi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi = %.*f\n&quot;</span>, <span class="number">3</span>, pi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi = %g\n&quot;</span>, pi);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">pi = <span class="number">3.142</span></span><br><span class="line">pi = <span class="number">3.142</span></span><br><span class="line">pi = <span class="number">3.14159</span></span><br></pre></td></tr></table></figure></p>
<h3 id="scanf函数">3.3 scanf()函数</h3>
<p>这个函数用于从标准输入流中读取数据。scanf()函数的常见用法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);  <span class="comment">// 读取一个整数类型的变量</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;score);  <span class="comment">// 读取一个浮点数类型的变量</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);  <span class="comment">// 读取一个字符串类型的变量</span></span><br></pre></td></tr></table></figure>
<p>scanf()函数中的%符号也是一个占位符，用于表示将要读取的变量的数据类型。&amp;符号用于表示将要读取的变量的地址。在使用scanf()函数时，需要注意数据类型匹配和错误处理等问题。</p>
<h3 id="getchar函数和putchar函数">3.4 getchar()函数和putchar()函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = getchar();  <span class="comment">// 读取一个字符</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>);  <span class="comment">// 输出一个字符</span></span><br></pre></td></tr></table></figure>
<p>getchar()函数会等待用户输入一个字符，并将该字符作为返回值返回，而putchar()函数则将给定的字符输出到标准输出流。</p>
<h3 id="gets函数和puts函数">3.5 gets()函数和puts()函数</h3>
<p>gets()函数用于从标准输入流中读取一行字符串，直到遇到换行符为止。</p>
<p>puts()函数则将给定的字符串输出到标准输出流，并在字符串末尾自动添加一个换行符。它们的常见用法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">gets(str);  <span class="comment">// 读取一行字符串</span></span><br><span class="line"><span class="built_in">puts</span>(str);  <span class="comment">// 输出字符串并添加一个换行符</span></span><br></pre></td></tr></table></figure>
<p>gets()函数的安全性不高，容易引发缓冲区溢出等安全问题，因此建议使用fgets()函数代替gets()函数进行字符串输入。</p>
<h3 id="文件读写">3.6 文件读写</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);  <span class="comment">// 打开文件</span></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File does not exist.&quot;</span>);  <span class="comment">// 检查文件是否打开成功</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);  <span class="comment">// 如果文件打开失败，则终止程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">fgets(str, <span class="number">100</span>, fp);  <span class="comment">// 从文件中读取一行字符串</span></span><br><span class="line">fclose(fp);  <span class="comment">// 关闭文件</span></span><br></pre></td></tr></table></figure>
<h2 id="符号运算优先级">4.符号运算优先级</h2>
<table>
<thead>
<tr class="header">
<th>优先级</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>( )</td>
<td>左右</td>
</tr>
<tr class="even">
<td>2</td>
<td>! ~ -</td>
<td>右到左</td>
</tr>
<tr class="odd">
<td>3</td>
<td>* / %</td>
<td>左到右</td>
</tr>
<tr class="even">
<td>4</td>
<td>+ -</td>
<td>左到右</td>
</tr>
<tr class="odd">
<td>5</td>
<td>&lt;&lt; &gt;&gt;</td>
<td>左到右</td>
</tr>
<tr class="even">
<td>6</td>
<td>&lt; &lt;= &gt; &gt;=</td>
<td>左到右</td>
</tr>
<tr class="odd">
<td>7</td>
<td>== !=</td>
<td>左到右</td>
</tr>
<tr class="even">
<td>8</td>
<td>&amp;</td>
<td>左到右</td>
</tr>
<tr class="odd">
<td>9</td>
<td>^</td>
<td>左到右</td>
</tr>
<tr class="even">
<td>10</td>
<td>|</td>
<td>左到右</td>
</tr>
<tr class="odd">
<td>11</td>
<td>&amp;&amp;</td>
<td>左到右</td>
</tr>
<tr class="even">
<td>12</td>
<td>||</td>
<td>左到右</td>
</tr>
<tr class="odd">
<td>13</td>
<td>? :</td>
<td>右到左</td>
</tr>
<tr class="even">
<td>14</td>
<td>= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;=</td>
<td>右到左</td>
</tr>
</tbody>
</table>
<h2 id="数组">5.数组</h2>
<p>在C语言中，数组是一组相同数据类型的元素的集合。数组中的每个元素都可以通过下标来访问，下标从0开始计数。数组的定义方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type array_name[array_size];</span><br></pre></td></tr></table></figure>
<p>其中，type表示数组中元素的数据类型，array_name表示数组的名称，array_size表示数组中元素的个数。在数组中，第一个元素的下标为0，最后一个元素的下标为<code>array_size-1</code>。可以通过下标来访问数组中的元素。</p>
<h2 id="指针">6.指针</h2>
<p>在C语言中，指针是一种特殊的变量类型，它可以存储变量的地址。指针的定义方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type *pointer_name;</span><br></pre></td></tr></table></figure>
<p>其中，type表示指针所指向变量的数据类型，pointer_name表示指针的名称。指针变量需要指向某个内存地址才能使用，可以通过取地址运算符<code>&amp;</code>来获取变量的地址，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;  <span class="comment">// 将指针p指向变量a的地址</span></span><br><span class="line"><span class="type">int</span> b = *p;  <span class="comment">// 将b赋值为指针p所指向的变量的值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = a;  <span class="comment">// 将指针p指向数组a的第一个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));  <span class="comment">// 通过指针访问数组中的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>电子</category>
      </categories>
      <tags>
        <tag>嵌入式开发</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言复习-进阶篇</title>
    <url>/2023/04/23/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>复习一下C语言的进阶应用。</p>
<p>基础篇：<a
href="https://splendidwave.github.io/2023/04/22/2023-4/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E5%9F%BA%E7%A1%80%E7%AF%87/">C语言复习-基础篇</a></p>
<span id="more"></span>
<h2 id="内存管理">1.内存管理</h2>
<p>在C语言中，程序内存可以分为代码段、数据段、堆区(stack)和栈区(heap)。</p>
<h3 id="代码段">1.1 代码段</h3>
<p>代码段也称为文本段，是存储程序代码的区域，通常是只读的，且不允许在程序运行时进行修改。在程序执行时，代码段中的指令被复制到处理器中执行。</p>
<h3 id="数据段">1.2 数据段</h3>
<p>数据段是存储静态变量和全局变量的区域，包括已初始化和未初始化的变量。已初始化的变量在编译时就被赋初值，而未初始化的变量在程序运行时会被初始化为0或空指针。数据段也是只读的，不允许在程序运行时进行修改。</p>
<h3 id="堆区">1.3 堆区</h3>
<p>堆区是程序运行时动态分配内存的区域，通过malloc、realloc等函数来申请和释放内存。堆区的大小是在程序运行时动态变化的，因此需要开发者自行管理内存的分配和释放，这种相信程序员的方法带来方便的同时也会带来风险。</p>
<p>堆区是由操作系统进行管理的，当申请内存时，操作系统会在堆区中分配一块连续的空间，并返回一个指向该空间的指针。释放内存时，操作系统将该空间标记为可用，并将其返回给堆区。</p>
<h4 id="malloc函数">1.3.1 malloc函数</h4>
<p>malloc函数用来动态地分配指定字节数的内存空间，如果分配成功，则返回一个指向分配内存的指针，否则返回空指针。malloc函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>其中，size_t是一个无符号整数类型，表示要分配的内存字节数。如果调用成功，则返回一个指向分配内存的指针；否则返回空指针。void类型不能定义变量但是可以定义指针，这是一个指针函数。</p>
<h4 id="realloc函数">1.3.2 realloc函数</h4>
<p>realloc函数用来重新分配内存空间的大小，可以用来扩大或缩小原有的内存空间。如果成功，则返回指向新分配内存的指针，否则返回空指针。realloc函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>其中，ptr是一个指向原有内存的指针，size是新的内存大小。如果调用成功，则返回一个指向新分配内存的指针；否则返回空指针。</p>
<h4 id="free函数">1.3.3 free函数</h4>
<p>free函数用来释放已经分配的内存空间。free函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>
<p>其中，ptr是指向要释放的内存空间的指针。使用free函数时需要注意，必须传递给它一个之前由malloc或realloc函数返回的指针，否则会出现内存泄漏的问题。</p>
<h3 id="栈区">1.4 栈区</h3>
<p>栈区是用于存储局部变量、函数参数和函数返回地址等信息的区域，是由编译器自动管理的。每当一个函数被调用时，该函数的参数和局部变量就会被存储在栈区中。栈区是一个先进后出的结构，当一个函数返回时，该函数的所有局部变量和参数就会被弹出栈区。栈区的大小通常是固定的，但可以通过编译器选项进行调整。</p>
<p>需要注意的是，堆区和栈区的内存都属于虚拟内存范畴，具体的内存分配和管理是由操作系统进行管理的。在使用堆区和栈区时，需要注意内存的使用情况和分配方式，以避免内存泄漏和野指针等问题。</p>
<h2 id="函数指针">2.函数指针</h2>
<p>函数指针是指可以存储函数地址的变量，通过函数指针，可以动态地调用不同的函数，实现程序的灵活性和可扩展性。</p>
<h3 id="普通函数指针">2.1 普通函数指针</h3>
<p>函数指针的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*fptr)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>这个函数指针可以用来存储指向接受两个 int 类型参数并返回 int
类型结果的函数的地址。</p>
<h3 id="回调函数">2.2 回调函数</h3>
<p>回调函数指被传递给另一个函数，并由另一个函数在需要时调用的函数。回调函数通常用于事件处理、错误处理和异步通信等任务中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">callback</span><span class="params">(<span class="type">int</span> result)</span><span class="comment">//定义回调函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_something</span><span class="params">(<span class="type">int</span> (*fptr)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">void</span> (*callback)(<span class="type">int</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = fptr(x, y);</span><br><span class="line">    callback(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    do_something(add, <span class="number">3</span>, <span class="number">4</span>, callback);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序在主函数中，我们调用 do_something 函数，传递 add
函数的地址、两个整数和回调函数的地址。do_something 函数调用 add
函数，并将结果传递给回调函数。回调函数的好处在于，它可以将程序的控制权交给另一个函数，使程序更加灵活和可扩展。</p>
<h3 id="函数指针作为成员">2.3 函数指针作为成员</h3>
<p>函数指针数组是指一个数组，其中的每个元素都是一个指向函数的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*fptr_arr[<span class="number">3</span>])(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>这个函数指针数组可以用来存储指向三个不同的函数的地址，这些函数都接受两个
int 类型参数并返回 int 类型结果。</p>
<p>另一个做法是将函数指针放入结构体中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*fptr)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> <span class="title">s</span>;</span></span><br><span class="line">    s.fptr = add;</span><br><span class="line">    <span class="type">int</span> result = s.fptr(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>my_struct 结构体包含一个指向 int 类型函数的指针
fptr。在主函数中，我们将 add 函数的地址存储到结构体的 fptr
成员中，然后使用结构体中的 fptr 成员调用 add 函数。</p>
<p>另外函数指针还可以应用于动态加载库和多态性，这部分内容可能更偏向于C++这里先不展开。</p>
<h2 id="多文件程序">3.多文件程序</h2>
<p>一个工程通常将程序代码分布在多个文件中，以便于代码的组织、维护和共享。C语言中通常包括的是头文件（.h
文件）和源文件（.c 文件）。</p>
<p>头文件定义了函数的原型和常量等信息，供其他文件引用。通常包含
#ifndef、#define 和 #endif 三个预处理指令来防止头文件被重复引用。</p>
<p>源文件包含函数的实现代码，多个源文件可以通过头文件来共享函数的定义，从而实现模块化的程序设计。下面给出头文件中通常包含的一些内容。</p>
<h3 id="标准库函数">3.1 标准库函数</h3>
<p>下面列举了一些C标准库中常用的函数：</p>
<ul>
<li>stdio.h：输入输出函数，包括文件操作函数、格式化输入输出函数、字符输入输出函数等。</li>
<li>string.h：字符串操作函数，包括字符串复制函数、字符串连接函数、字符串比较函数等。</li>
<li>math.h：数学函数，包括三角函数、指数函数、对数函数、幂函数等。</li>
<li>time.h：日期和时间函数，包括获取当前时间函数、时间格式化函数、计时函数等。</li>
<li>stdlib.h：常用的函数，包括动态内存分配函数、字符串转换函数、系统调用函数等。</li>
<li>ctype.h：字符处理函数，包括字符分类函数、字符转换函数等。</li>
<li>assert.h：调试宏，用于在程序中检查错误和异常情况。</li>
<li>errno.h：错误码定义，用于表示函数执行过程中的错误信息。</li>
</ul>
<h3 id="宏定义">3.2 宏定义</h3>
<p>宏定义是C语言中常用的一种预处理指令，用于在编译时将某些代码段替换为指定的文本内容。标准语法为<code>#define 宏名 替换文本</code>其中，宏名是用户自定义的宏名称，替换文本是指在编译时需要替换的文本内容。当程序中出现该宏名称时，编译器会将其替换为指定的文本内容，从而达到代码重用的效果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="type">double</span> radius = <span class="number">10.0</span>;</span><br><span class="line"><span class="type">double</span> area = PI * radius * radius;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> max = MAX(a, b);</span><br></pre></td></tr></table></figure>
<p>宏定义并非真正意义上的函数调用，而是将代码中的某些部分替换为指定的文本内容。因此，在使用宏定义时，需要特别注意其替换内容是否合法，以及是否会产生意料之外的副作用。</p>
<h2 id="数据结构">4.数据结构</h2>
<p>这里只给出简约版提供复习用。</p>
<h3 id="链表">4.1 链表</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">// 节点数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedList</span> &#123;</span></span><br><span class="line">    Node* head;         <span class="comment">// 头结点指针</span></span><br><span class="line">    Node* tail;         <span class="comment">// 尾结点指针</span></span><br><span class="line">    <span class="type">int</span> length;         <span class="comment">// 链表长度</span></span><br><span class="line">&#125; LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(LinkedList* <span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈">4.2 栈</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 栈结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *data; <span class="comment">// 存储栈元素的数组</span></span><br><span class="line">    <span class="type">int</span> top;   <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="type">int</span> size;  <span class="comment">// 栈的大小</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈的初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(Stack *s, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    s-&gt;data = (<span class="type">int</span> *) <span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    s-&gt;size = size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个栈可以实现动态分配内存。</p>
<h3 id="队">4.3 队</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_QUEUE_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_QUEUE_SIZE];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(Queue *q)</span> &#123;</span><br><span class="line">    q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    q-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树">4.4 树</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义二叉树节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>电子</category>
      </categories>
      <tags>
        <tag>嵌入式开发</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>电动汽车选配指南--以比亚迪为例</title>
    <url>/2023/04/28/2023-4/%E7%94%B5%E5%8A%A8%E6%B1%BD%E8%BD%A6%E9%80%89%E9%85%8D%E6%8C%87%E5%8D%97--%E4%BB%A5%E6%AF%94%E4%BA%9A%E8%BF%AA%E4%B8%BA%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>随着清洁能源技术的不断进步和国家政策的推动，越来越多的年轻用户选择科技感更强的电动汽车。比起以往的燃油车，电动汽车更像是一种能够移动的电子设备，其日新月异的新技术也使得许多老车主纷纷表示被“背刺”了。本文将以科普的角度，简要介绍电动汽车的分类、结构。并以比亚迪的汉EV千山翠限量版和宋PLUS
DM-i为例介绍展开介绍。</p>
<p>注：本文主要介绍汽车的一些原理和名词解释，并拿了市面上销量较好的比亚迪举例子，并无消费导向，大家根据实际需求购买（除非byd给我打广告费）。</p>
<span id="more"></span>
<h2 id="明确需求">1.明确需求</h2>
<h3 id="电动车和燃油车的区别">1.1 电动车和燃油车的区别</h3>
<p>目前选购一辆代步车大部分人会在燃油车和新能源车中纠结一下。为此需要了解两者的异同才能更好地做出抉择。</p>
<p>传统燃油车是由如下几个部分组成:</p>
<ul>
<li><strong>车身主体</strong>：汽车的车身结构大部分由高强度材料组成，起到支撑车体和保护驾驶员安全的作用。部分车型会将前后车身做得偏软，发生碰撞可以用来缓冲防止行人或他车车主受到伤害。</li>
<li><strong>发动机</strong>：发动机是汽车的心脏部分，它将燃油的化学能转化为机械能，驱动汽车前进，由于发动机开始工作时需要进气引导，工作过程中需要不停点火，所以燃油车会配上一块蓄电池用于提供这部分所需能量。</li>
<li><strong>传动装置</strong>：传动轴和齿轮将发动机产生的动力传递到车轮，从而使车辆运动，同时它可以利用齿轮组的传动比将发动机的高速低扭转化为车轮的低速高扭。由于传动杆的存在，我们可以看见车子中轴线会存在一条凸起。</li>
<li><strong>悬架系统</strong>：悬架又称底盘，它起到了支撑车身重量，并减缓路面的颠簸和震动，控制转弯等功能。</li>
<li><strong>控制系统</strong>：车子的控制主要分为机械控制和电子控制两部分，用于辅助驾驶员控制汽车，通常以方向盘、踏板、机械开关或者车机交互的方法实现。</li>
</ul>
<p>相比之下，电动汽车主要的改动点就在于采用电动机代替了发动机再搭载一块大电池，电机的效率更高更节能。它在低速状态下可以输出极大的扭矩，而且不需要排放尾气。这也是国家大力推动新能源汽车发展的重要原因之一。</p>
<h3 id="油电混动车型">1.2 油电混动车型</h3>
<p>但新能源汽车发展早期存在电池技术不成熟，充电桩寻找困难、充电速度慢等问题，再加上BBA（宝马、奔驰、奥迪）和日系合资车的社会认可度更高，导致电动车选购率低，就算是选择新能源车也会选择混动类型的。</p>
<p>混动类型可以分为如下三种：</p>
<ul>
<li><strong>增程式</strong>：增程式是指内燃机只负责发电，不需要考虑驱动车辆，燃油只负责增加行驶路程的功能。</li>
<li><strong>插电混合</strong>：插电混动是指既可以随意使用电机又可以使用发动机驱动，它解决了电池充电慢，远距离续航不足的问题，会受到更多人的青睐。</li>
<li><strong>油电混合</strong>：油电混动是指车子在行驶过程中同时使用电和油，它结合了电车起步快和油车行驶稳定的优势，这种类型因为还是会排放大量尾气所以通常不被上绿牌不享受新能源政策，只是相当于一个省油的油车。</li>
</ul>
<p>纯电车是完全依赖电池行驶，虽然会有里程焦虑但是电车的养护成本会比油车低很多。</p>
<h3 id="如何选取">1.3 如何选取</h3>
<p>在选购车子的时候可以根据如下3点进行判断。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/05/20230505171127.png"
alt="选车" />
<figcaption aria-hidden="true">选车</figcaption>
</figure>
<p>主要还是根据使用场景进行选购，决定好买油车还是电车后再结合预算要SUV、轿车、越野车还是跑车就可以将购车范围缩小到几种车，然后针对性地去4s店看车和试驾。如果对自己使用需求不明确或者对外观要求较高的，可以先去车展看看效率比较高。一般来说选择市场认可度比较高的会更有保障，真出问题了也可以联合更多人去找厂商的问题。</p>
<p>接下来针对一些细节结构进行展开介绍。</p>
<h2 id="车身尺寸">2.车身尺寸</h2>
<h3 id="车柱与轴距">2.1 车柱与轴距</h3>
<p>车身承担了兼具实用（保护驾驶员安全）和美观（车型外观）两个重要因素。下图标注了聊车身经常会提到的几个名词指代的位置，如A柱、B柱、轴距。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/04/20230425202425.png"
alt="车柱" />
<figcaption aria-hidden="true">车柱</figcaption>
</figure>
<p>这张图中位于上方的车就是轿车，位于下方的则是SUV。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/04/20230425202640.png"
alt="轴距" />
<figcaption aria-hidden="true">轴距</figcaption>
</figure>
<p>根据轴距可以将车分为如下几个类型，下表只是一个参考标准，级别没有明确的定义。</p>
<table>
<thead>
<tr class="header">
<th>级别</th>
<th>定义</th>
<th>轴距范围</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A0级</td>
<td>微型车</td>
<td>≤ 2,490 mm</td>
</tr>
<tr class="even">
<td>A级</td>
<td>小型车</td>
<td>2,491 mm - 2,700 mm</td>
</tr>
<tr class="odd">
<td>B级</td>
<td>中型车</td>
<td>2,701 mm - 2,900 mm</td>
</tr>
<tr class="even">
<td>C级</td>
<td>大型车</td>
<td>≥ 2,901 mm</td>
</tr>
</tbody>
</table>
<p>轴距越大乘坐体验就会越舒适，但对司机的驾驶要求会相对提升一些，中国老百姓普遍喜欢买大一些的车，显得气派。千山翠的是轴距在2920，车长4995，属于是B和C之间，但因为它后备箱空间不是很大所以后排体验是有C级车的标准的，后座使用的是隐私玻璃，定位也是商务车的定位。宋plus轴距是2765属于是中型的SUV。</p>
<h3 id="车漆">2.2 车漆</h3>
<p>汽车的车漆是车身保护和美观的关键组成部分。通常认为原厂的车漆要比后补的更好，尤其是像千山翠这类特制车漆，会比同配置的汉EV四驱版贵上两万，同时刮蹭后补漆价格也会更高。</p>
<p>对于轻微刮痕通常处理方法有，不处理、车漆笔、抛光等操作，如果刮痕比较深或者涉及到较大的区域，可能需要进行磨砂和补漆处理。</p>
<p>车漆的保护方法有定期洗车、避免太阳直射、车衣、镀晶/镀膜等。不过我去提车的时候4S店并不推荐我加车衣，也不推荐车座垫，给了车窗膜和底盘护甲。</p>
<h2 id="动力系统">3.动力系统</h2>
<h3 id="电机类型">3.1 电机类型</h3>
<p>目前电机主流使用的是以特斯拉为首的交流异步电机和以比亚迪为老大的永磁同步电机。</p>
<p>交流异步电机(Asynchronous AC Motor, AC Induction
Motor)的工作原理是通过交流电源产生的旋转磁场诱导出转子中的电流，由于转子电流在磁场作用下会产生转矩，从而驱动转子旋转。然而，由于转子电流的产生和变化需要一定的时间，因此转子的旋转速度不能完全跟随旋转磁场的频率，产生了一定的转速差，因此被称为“异步”。</p>
<p>永磁同步电机(Permanent Magnet Synchronous Motor,
PMSM)的转子由永磁体组成，永磁体的磁场与定子磁场相互作用，从而使转子转动。为了使永磁同步电机能够稳定运行，其定子的磁场必须保持同步旋转，这需要通过控制定子的电流和频率来实现</p>
<p>千山翠使用的是交流永磁同步电机(Permanent Magnet Synchronous Motor
with AC
Drive)。这是一种结合了永磁同步电机和交流异步电机的特点的电机。它的转子由永磁体组成，因此具有永磁同步电机的高效率、高功率密度和响应速度快的特点。同时，它的定子采用交流异步电机的设计，可以通过变频器来控制其电流和频率，从而实现精确的转速控制和调节。</p>
<p>宋plus是插电类型的车，使用的是比亚迪自研的骁云-插混专用发动机，相对来说技术上还是比较有优势的。</p>
<h3 id="电机的指标">3.2 电机的指标</h3>
<p>电机性能的参数通常包括以下几个方面：</p>
<p>额定功率和额定转速：电机额定功率和额定转速是电机性能的基本参数，通常在电机铭牌上标明。额定功率是指电机在额定转速下所能输出的最大功率，单位为千瓦（kW）；额定转速是指电机在额定电压、额定电流下所能达到的转速，单位为转每分钟（rpm）。</p>
<p>转矩和转速曲线：电机的转矩和转速曲线反映了电机输出功率的变化规律，也是电机性能的重要参数。转矩和转速曲线通常以图表形式表示，可以用于评估电机在不同负载下的输出能力和效率。</p>
<p>效率：电机的效率是指电机输出功率与输入功率之比，通常以百分比表示。电机的效率直接关系到电机的能耗和工作效率，是评估电机性能的重要指标。</p>
<p>功率因数：电机的功率因数是指电机输出功率与电机视在功率之比，通常以小数形式表示。功率因数反映了电机的电能利用效率，高功率因数的电机能够降低电网负荷和能耗。</p>
<p>但通常汽车动力性能中标注的是最大功率和最大扭矩。越大说明汽车动力越足。</p>
<h3 id="驱动类型">3.3 驱动类型</h3>
<p>驱动类型通常指汽车的动力传动方式，主要分为前驱、后驱和四驱三种类型。</p>
<ul>
<li><p><strong>前驱</strong>是指汽车动力由发动机传输到前轮驱动，通过前轮驱动车辆前部的重心提供更好的牵引力和稳定性。前驱车型通常比较节省油耗和制造成本，但在高速行驶时会出现轻微的转向不稳定和过弯时的欠稳定性。</p></li>
<li><p><strong>后驱</strong>是指汽车动力由发动机传输到后轮驱动，通过后轮驱动车辆后部的重心提供更好的牵引力和操控性。后驱车型通常有更好的平衡性和操控性，但在低摩擦路面上的牵引能力相对较差。</p></li>
<li><p><strong>四驱</strong>是指所有车轮都有动力输出，通过动力分配系统将动力传递到不同的车轮，以提供更好的牵引和操控性能。四驱车型通常适用于路况复杂、陡坡、泥泞等恶劣路况下行驶，但相对于前驱和后驱车型，制造成本和油耗较高。</p></li>
</ul>
<p>不同驱动类型的汽车有各自的优缺点，在购买时需要根据自己的需求和用途进行选择，不同类型在驾驶过程没有明显区别，但是不差钱的可以无脑四驱。</p>
<h3 id="续航里程">3.4 续航里程</h3>
<p>在国内续航里程通常是按工信部制定的国家标准进行测评，其中最常用的标准为CLTC（China
Light-Duty Test Cycle）。</p>
<p>CLTC是一种基于欧盟NEDC（New European Driving
Cycle）标准进行修改和优化的测试循环。CLTC包括两个部分：低速城市循环和高速公路循环，其中低速城市循环主要测试低速、停车、加速和制动等行驶状态，高速公路循环主要测试高速巡航状态。</p>
<p>在CLTC标准下，电动车续航里程的测量通常是在室温（20℃~30℃）下进行，电池充满电的情况下，以模拟真实驾驶情况，按照标准测试循环进行测试，最终得出一个标准化的续航里程数值。</p>
<p>除了里程外还需要关注的是汽车的电车容量和充电时间，一般在高速上跑和在冬天跑都会使续航里程打折，而且一般电车不会将电全部用完，在估算续航时都需要考虑在内。</p>
<h2 id="制动及悬架系统">4.制动及悬架系统</h2>
<h3 id="制动类型">4.1 制动类型</h3>
<p>制动类型主要有两类，一类是盘式制动，一类是鼓式制动。</p>
<p>盘式制动是通过刹车片钳住制动盘来实现制动，刹车片通常会听到brembo这个牌子，这是一个意大利牌子，以其制造高品质刹车和离合器组件而闻名于世界。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/04/20230428124054.png"
alt="盘式制动" />
<figcaption aria-hidden="true">盘式制动</figcaption>
</figure>
<p>鼓式制动也是利用摩擦制动，不同的是它使用圆柱形的鼓式制动器来刹车，但这种方法因为散热问题，稳定性不如盘式，其复杂结构也会导致高故障率。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/04/20230428124700.png"
alt="鼓式制动" />
<figcaption aria-hidden="true">鼓式制动</figcaption>
</figure>
<p>主流还是盘式用的比较多，千山翠用的是比亚迪自研的通风打孔盘式，作为自己调教的刹车片，会更适合自家的车型。</p>
<h3 id="悬架">4.2 悬架</h3>
<p>悬架系统主要由弹簧、减震器、连接杆等部件组成，起到提高了车辆的稳定性和驾驶舒适性等功能。独立悬架是目前主流的悬架形式，它能够独立支撑每个车轮，提高了车辆的操控性和行驶稳定性。通常按连杆类型又可以分为如下几种：</p>
<ul>
<li>麦弗逊悬架：麦弗逊悬架适用于大多数前驱车和后驱车的前悬架，其结构简单、可靠性高、成本低，是目前最常见的悬架类型之一。但它的行程比较受限而且对侧向受力化解比较乏力。</li>
<li>双连杆悬架：双连杆使用了两个控制臂来支撑和控制车轮，会比麦弗逊操控性更强。</li>
<li>多连杆悬架：三连杆、四连杆、五连杆都统称多连杆，多连杆悬架还可以提供更高的悬挂行程和更优秀的悬架响应，但其成本和车辆重量也会随之提升。</li>
</ul>
<p>主动悬架可以根据车辆运动和路况状况实时调整悬架系统的硬度、行程和其他参数，从而提高车辆的驾驶稳定性和悬架性能。需要软件和硬件相互配合实现，比亚迪的<a
href="https://www.bilibili.com/video/BV1wv4y1H7Zv/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3fd1e5e8ca82ebd09d9c888f49c210cf">云辇</a>技术就是一个典型。</p>
<p>千山翠使用的是千麦弗逊后多连杆，在22款的低配汉ev车型中使用的是铁制连杆，所以被网友戏称“筷子悬挂”，在23款比亚迪就将底盘换成了铝合金了。</p>
<h3 id="轮胎">4.3 轮胎</h3>
<p>汽车轮胎直接与路面接触，承受着汽车的重量和各种力量，影响着汽车的操控性能、安全性能和舒适性能。比较出名的公司就是米其林。</p>
<p>轮胎标注一般会提供断面宽度(指轮胎正面的宽度)、扁平比(截面高度与截面宽度的比值)、尺寸(轮胎的内径)信息。其中扁平比可以会比较难理解，通俗来说较低的扁平比通常意味着高车辆的操控性和响应速度，但可能会牺牲一些乘坐舒适性。较高的扁平比则意味着轮胎的侧壁更高，对路面的减震效果更好，但可能会降低车辆的操控性。</p>
<p>千山翠的轮胎规格标注是245/45
R19表示这是一款断面宽度为245毫米、扁平比为45%、结构类型为径向轮胎，适合安装在直径为19英寸的轮毂上的轮胎。千山翠的轮胎是米其林和固特异混发的，两者区别倒是不是很大。</p>
<h2 id="控制与辅助系统">5.控制与辅助系统</h2>
<p>这里列一下千山翠的一些控制辅助系统，因为是比亚迪王朝系列的顶配，基本市面上有的计算都加装了，需要的可以自行搜索阅读，没需求的可以直接跳过。</p>
<ul>
<li>自适应巡航控制（Adaptive Cruise
Control，ACC）：一种智能驾驶辅助系统，能够通过雷达或激光等技术实现车辆的自动跟车和自动减速，使驾驶者在高速公路等道路上行驶更加轻松和安全。</li>
<li>智能车距控制（Intelligent Cruise
Control，ICC）：也是适应巡航控制（Adaptive Cruise
Control）系统的一种，除了保持与前车的安全距离外，还可以自动减速或停车以避免追尾事故的发生，相比之下更加智能。</li>
<li>交通拥堵辅助系统（Traffic Jam Assist,
TJA）：是一种智能驾驶辅助系统，主要用于缓解城市拥堵时的驾驶压力，提高行驶安全性。</li>
<li>前方碰撞预警系统（Forward Collision Warning,
FCW）：是一种车辆安全辅助系统，主要用于预警驾驶员前方可能发生的碰撞风险，以避免或减轻碰撞事故的后果。</li>
<li>自动紧急制动系统（Automatic Emergency Braking,
AEB）：是一种紧急制动系统，通常和交通标志识别系统（Camera-based Traffic
Sign Recognition, CCR）和行人车辆识别系统（Vulnerable Road
Users，VRU）联合使用。</li>
<li>紧急制动辅助系统（Emergency Brake Assist,
EBA）：是一种汽车安全辅助系统，可以帮助驾驶员在紧急制动时更快更稳地停车，从而减少事故的发生。通常与ESP（电子稳定控制系统）和ABS（防抱死制动系统），以提高车辆的稳定性和安全性。</li>
<li>紧急制动信号系统（Emergency Stop Signal,
ESS）：是一种汽车安全辅助系统，可以在紧急制动时自动闪烁制动灯，以提醒后方车辆注意。</li>
<li>车道偏离警示系统（Lane Departure Warning System,
LDWS）：是一种车辆安全辅助系统，用于提醒驾驶员车辆偏离了车道。</li>
<li>车道保持系统（Lane Keeping System,
LKS）：是一种车辆安全辅助系统，可以帮助驾驶员在车辆行驶过程中保持在正确的车道内。</li>
<li>智能远近光灯系统（Headlamp Matrix System,
HMA）:是一种基于车辆摄像头和电子控制单元的智能车灯系统。</li>
<li>道路交通标志识别系统（Traffic Sign Recognition System,
TSR）：是一种智能驾驶辅助系统，可以自动识别道路上的交通标志并显示在驾驶员的仪表盘上，帮助驾驶员更好地了解当前行驶状态和交通规则。</li>
<li>高速公路辅助驾驶系统（Highway Assist,
HWA）：是一种智能驾驶辅助系统，可以在高速公路上为驾驶员提供自动加速、减速、转向和车道保持等功能，从而降低驾驶员的疲劳度和驾驶风险，提高驾驶舒适性和安全性。</li>
<li>交互式变道辅助系统（ILCA）：是一种智能驾驶辅助系统，又称拨杆变道辅助，在车速60-130km/h范围内，开启智能领航模式下，用户只需拨动转向拨杆，系统便会在确保安全前提下自动控制车辆变道。</li>
<li>前方交通穿行提示系统（Front Cross Traffic Alert,
FCTA）：是一种车辆安全辅助系统，可用于检测和提示车辆前方横穿路口或停车位存在车辆或行人。同理还有后方交通穿行提示（RCTA）。</li>
<li>紧急车道保持辅助（Emergency Lane Keeping Assist,
ELKA）：是一种智能辅助驾驶系统，当汽车发生意外偏离车道后,会发出提醒并通过制动或转向等手段停入紧急车道。</li>
<li>盲点监测系统（Blind Spot Detection,
BSD）：是一种车辆驾驶辅助系统，可以帮助驾驶员检测车辆侧后方的盲区，以便更好地掌握交通状况和避免潜在的碰撞事故。</li>
<li>开门预警：打开门时如果后方有来车或来人会提示。</li>
<li>3D全息透明影像：这个功能非常的方便，特别是过窄路和停车的时候，新手或者车感不好的人一定要配一个。</li>
<li>遥控驾驶：用手机app可以遥控汽车。</li>
</ul>
<h2 id="购车流程和注意事项">6.购车流程和注意事项</h2>
<p>看车（4s店/车展）--&gt; 试驾（需要驾驶证） --&gt;
谈价格（可以留意优惠和政府补贴） --&gt; 付定金 --&gt; 提车（!）</p>
<p>价格方面油车可能更容易打一些，而且挑淡季去谈优惠幅度会很大。比亚迪的价格是全国统一的，没法谈，只能多要点4s店的优惠。如果选购的是新能源车，23年是免购置税的，可能还会接着延长。其次国家的新能源车补贴是没有了，但地方政府的补贴还会不定期发放。其次买车还需要上牌费和保险之类的，会比裸车价高出一些。基本上想拿到一个比较优惠的价格就多去几家4s店。</p>
<p>提车这里需要注意的事项会比较多。特别是车子质量要仔细检查漆面是否有问题，轮胎和玻璃型号，发动机，排气口里程数之类的。如果发现小问题可以让4S店适当补偿。然后合同上价格明细和赠送要全部备注清楚。尽量在4S店买车在流程上会更有保障，其次要等保险生效后再把车开回家。</p>
<p>最后祝各位都能顺利喜提爱车。</p>
]]></content>
      <categories>
        <category>文化娱乐</category>
        <category>逻辑与科普</category>
      </categories>
      <tags>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>SEGGER Embedded Studio 安装及新建工程</title>
    <url>/2023/06/18/2023-6/SEGGER%20Embedded%20Studio%20%E5%AE%89%E8%A3%85%E5%8F%8A%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>SEGGER Embedded Studio(SES)是一个集成开发环境（IDE），是SEGGER
Microcontroller公司开发出来专门用于嵌入式系统开发使用的。值得一提的是J-Link也是segger公司开发的。SES提供了一套全面的工具和功能，以便于嵌入式系统的开发过程，并且对目前来说使用SES学习和评估都是免费的。</p>
<p>过程参考网络资料以及官方手册<a
href="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/non-image/EmbeddedStudio_ARM_v730_manual.pdf">Embedded
Studio for ARM Reference Manual Version: 7.30</a></p>
<span id="more"></span>
<h2 id="安装">1.安装</h2>
<p>下载地址：<a
href="https://www.segger.cn/downloads/embedded-studio/">Embedded Studio
Downloads</a></p>
<p>这里根据使用的芯片架构和电脑系统下载对应版本，这里使用的芯片是GD32F10x，是ARM架构的。系统是win10，因此选择Embedded
Studio for ARM下的Windows。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230618144342.png"
alt="下载" />
<figcaption aria-hidden="true">下载</figcaption>
</figure>
<p>安装流程比较简单，双击安装包启动后只需要修改一下安装路径，一直点next就行。</p>
<h2 id="界面简介">2.界面简介</h2>
<p>进去之后选accept，可以看见如下图的画面，图中将几个分区用不同颜色的选框标记出来了。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230618200117.png"
alt="SES界面" />
<figcaption aria-hidden="true">SES界面</figcaption>
</figure>
<p>如果没有工具栏，可以在菜单栏中的veiw中开启。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230618201815.png"
alt="开启工具栏" />
<figcaption aria-hidden="true">开启工具栏</figcaption>
</figure>
<p>点击菜单栏的Target选择连接模拟器，再点击工具栏第一个按钮或者使用菜单栏的debug就会进入debug状态，会出现调试器窗口和输出窗口。调试例子就会出现如下现象。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230618202320.png"
alt="模拟debug" />
<figcaption aria-hidden="true">模拟debug</figcaption>
</figure>
<h2 id="新建工程">3.新建工程</h2>
<p>点击菜单栏 file-&gt; new
Project创建项目，在弹出的窗口中选择新建solution，一般一个solution可以挂多个project。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230618202559.png"
alt="选择新建项目" />
<figcaption aria-hidden="true">选择新建项目</figcaption>
</figure>
<p>这里需要先下载一下板子所需的支持包。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230618203040.png"
alt="下载板子支持包" />
<figcaption aria-hidden="true">下载板子支持包</figcaption>
</figure>
<p>这里以gd32f10x为例</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230618203438.png"
alt="gd32f10x" />
<figcaption aria-hidden="true">gd32f10x</figcaption>
</figure>
<p>如果下载失败也可以在菜单栏 Tools -&gt; package
Manage中再次查找下载，在Show Installed
Packages中可以查看下好的支持包。</p>
<p>随后回到上一步，选择第一个</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/06/20230618204137.png"
alt="创建" />
<figcaption aria-hidden="true">创建</figcaption>
</figure>
<p>详细的配置先不用管，一路默认就行。创建完可以成功build和debug就算成功。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>电子</category>
      </categories>
      <tags>
        <tag>电子信息</tag>
      </tags>
  </entry>
  <entry>
    <title>I2C详解--以51单片机和MMA8451Q为例</title>
    <url>/2023/08/05/2023-8/I2C%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>I2C(Inter－Integrated
Circuit)是由NXP(恩智浦)半导体开发的一种简单的双向两线制总线协议标准。它作为电子行业中最常见的串行通讯协议，虽然书面可以写成I2C，但实际它实际写法是<span
class="math inline">\(I^2C\)</span> 读作[I fang C]。</p>
<p>它只需要2个引脚--SDA（双向数据线）和SCL(时钟线)，就可以完成芯片间的通信，这种便捷的应答机制的提出让微控制器，电源、显示、传感器等芯片间能够简单快速的互联互通。</p>
<p>本文详细介绍了I2C的几种传输信号，并以51架构的芯片和三轴加速度传感器为例提供了一套模拟I2C的解决方案。</p>
<span id="more"></span>
<h2 id="i2c协议">1.I2C协议</h2>
<p>参考<a href="https://zhuanlan.zhihu.com/p/362287272">知乎文章
一文看懂I2C协议</a></p>
<p>I2C协议可以工作在以下5种速率模式下，不同的器件可能支持不同的速率。</p>
<ul>
<li>标准模式(Standard)：100kbps</li>
<li>快速模式(Fast)：400kbps</li>
<li>快速模式+(Fast-Plus)：1Mbps</li>
<li>高速模式(High-speed)：3.4Mbps</li>
<li>超快模式(Ultra-Fast)：5Mbps（单向传输）</li>
</ul>
<p>对于I2C协议来说其实只有非常基础的几种信号：起始、停止、数据、应答和非应答信号。</p>
<ol type="1">
<li><p>起始信号：I2C协议规定，SCL处于高电平时，SDA由高到低变化，这种信号是<strong>起始信号</strong>。</p></li>
<li><p>停止信号：SCL处于高电平，SDA由低到高变化，这种信号是<strong>停止信号</strong>。</p></li>
<li><p>数据信号：I2C协议对数据的采样发生在SCL高电平期间，除了起始和停止信号，在数据传输期间，SCL为高电平时，SDA必须保持稳定，不允许改变，在SCL低电平时才可以进行变化。而且一次允许传输的是1个字节的数据量。</p></li>
<li><p>应答信号：应答信号出现在1个字节传输完成之后，即第9个SCL时钟周期内，此时主机需要释放SDA总线，把总线控制权交给从机，由于上拉电阻的作用，此时总线为高电平，如果从机正确的收到了主机发来的数据，会把SDA拉低，表示应答响应。</p></li>
<li><p>非应答信号：当第9个SCL时钟周期时，SDA保持高电平，表示非应答信号，通常在读到数据时不需要从机回应，主机可以不放开总线控制权。</p></li>
</ol>
<h2 id="i2c读写时序图阅读">2.I2C读写时序图阅读</h2>
<p>在芯片手册中通常可以找到芯片的I2C时序图，下面以MMA8451Q为例，其时序图如下</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/2023/08/20230805091314.png"
alt="MMA8451Q时序图" />
<figcaption aria-hidden="true">MMA8451Q时序图</figcaption>
</figure>
<p>左上角的“&lt;&gt;”中代表着是想要进行的操作，如single-byte
read，意思是进行单字节读取。下面的master和slave分别代表主机需要进行的操作和从机需要进行的操作。这里主机指的是主控芯片，从机指的是MMA8451Q。</p>
<p>如果想要从从机这读取单个数据，主机需要先发送一个ST + device address +
w，即发送一个起始信号+设备地址数据信号+写信号，其中地址信号是7位的，写信号是1位，加起来就是一个字节的数据信号。随后主机放开控制权，从机会返回一个应答信号，表示通信正常。然后主机将需要读取的寄存器信号地址发送给从机，再收到一个应答，这时候主机需要再发送一个起始信号+设备地址信号+读信号，从机在发送应答后会发送数据给主机，这时候主机收到信号不需要应答，发送一个停止信号即可。</p>
<p>这就是一个完整的读取信息通信过程。</p>
<h2 id="i2c读写程序编写">3.I2C读写程序编写</h2>
<p>在使用单片机时，通常芯片厂商会配置好硬件I2C，只需要根据例程修改即可使用。但有时可能会出现硬件功能无法正常使用等情况。同时为了更好的了解I2C协议，这里使用模拟I2C来实现通信。</p>
<p>首先需要在硬件原理图中找到I2C通信的两个端口，并将它们初始化为开漏输出模式，注意硬件部分的端口需要加一个上拉电阻，否则无法输出高电平。</p>
<p>为了方便起见，这里使用宏定义将引脚换个名字，我以51架构芯片的P44和P45脚为例，这里请根据自己的主控芯片和硬件原理图进行修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define I2C_SDA P45</span><br><span class="line">#define I2C_SCL P44</span><br></pre></td></tr></table></figure>
<p>MMA8451的读写地址和寄存器位置也可以在芯片手册中找到。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define  MMA8451Q_WRITE		    0x38		/*Write Cmd*/</span><br><span class="line">#define  MMA8451Q_READ          0x39     	/*Read  Cmd*/</span><br><span class="line"></span><br><span class="line">#define MMA8451Q_CTRL_REG1      0x2A        /*control registers*/</span><br><span class="line">#define MMA8451Q_CTRL_REG2      0x2B</span><br><span class="line">#define MMA8451Q_WHO_AM_I       0x0D</span><br></pre></td></tr></table></figure></p>
<p>下面是示例代码，注意要根据主控芯片和传感器自行修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*****************************************************************************</span><br><span class="line"> ** \brief	 I2C_Delay</span><br><span class="line"> ** \param </span><br><span class="line"> **            	</span><br><span class="line"> ** \return  </span><br><span class="line"> ** \note  </span><br><span class="line"> *****************************************************************************/</span><br><span class="line">static void I2C_Delay(void)</span><br><span class="line">&#123;</span><br><span class="line">	uint16_t i;</span><br><span class="line">	for(i=0;i&lt;1;i++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*****************************************************************************</span><br><span class="line"> ** \brief	 I2C_Start</span><br><span class="line"> ** \param </span><br><span class="line"> **            	</span><br><span class="line"> ** \return  </span><br><span class="line"> ** \note  </span><br><span class="line"> *****************************************************************************/</span><br><span class="line">void I2C_Start(void)&#123;</span><br><span class="line">	I2C_SDA=1;</span><br><span class="line">	I2C_SCL=1;</span><br><span class="line">	I2C_Delay();</span><br><span class="line">	I2C_SDA=0;</span><br><span class="line">	I2C_Delay();</span><br><span class="line">	I2C_SCL=0;</span><br><span class="line">	I2C_Delay();</span><br><span class="line">&#125;</span><br><span class="line">/*****************************************************************************</span><br><span class="line"> ** \brief	 I2C_Stop</span><br><span class="line"> ** \param </span><br><span class="line"> **            	</span><br><span class="line"> ** \return  </span><br><span class="line"> ** \note  </span><br><span class="line"> *****************************************************************************/</span><br><span class="line">void I2C_Stop(void)&#123;</span><br><span class="line">	I2C_SDA=0;</span><br><span class="line">	I2C_SCL=1;</span><br><span class="line">	I2C_Delay();</span><br><span class="line">	I2C_SDA=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*****************************************************************************</span><br><span class="line"> ** \brief	 I2C_ReadAck</span><br><span class="line"> ** \param </span><br><span class="line"> **            	</span><br><span class="line"> ** \return  </span><br><span class="line"> ** \note  </span><br><span class="line"> *****************************************************************************/</span><br><span class="line">bit I2C_ReadAck()	//主机接收应答</span><br><span class="line">&#123;</span><br><span class="line">	bit ack=0;</span><br><span class="line">	I2C_SDA=1;			//释放总线</span><br><span class="line">	I2C_Delay();</span><br><span class="line">	I2C_SCL=1;</span><br><span class="line">	I2C_Delay();</span><br><span class="line">	ack=I2C_SDA;</span><br><span class="line">	I2C_SCL=0;</span><br><span class="line">	</span><br><span class="line">	return ack;</span><br><span class="line">&#125;</span><br><span class="line">/*****************************************************************************</span><br><span class="line"> ** \brief	 I2C_Sendbyte(u8 byte)</span><br><span class="line"> ** \param 	</span><br><span class="line"> **            	</span><br><span class="line"> ** \return  </span><br><span class="line"> ** \note  I2C总线主机发送一个字节数据</span><br><span class="line"> *****************************************************************************/</span><br><span class="line">void I2C_Sendbyte(u8 byte)//主机发送一个字节的数据</span><br><span class="line">&#123;</span><br><span class="line">	u8 i=0;</span><br><span class="line">	I2C_Delay();</span><br><span class="line">	for(i=0;i&lt;8;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		I2C_SDA=byte&amp;(0x80&gt;&gt;i);</span><br><span class="line">		I2C_Delay();</span><br><span class="line">		I2C_SCL=1;</span><br><span class="line">		I2C_Delay();</span><br><span class="line">		I2C_SCL=0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*****************************************************************************</span><br><span class="line"> ** \brief	 I2C_Readbyte</span><br><span class="line"> ** \param   </span><br><span class="line"> **            	</span><br><span class="line"> ** \return  </span><br><span class="line"> ** \note  I2C总线主机接收一个字节数据</span><br><span class="line"> *****************************************************************************/</span><br><span class="line">u8 I2C_Readbyte()//主机接收一个字节数据</span><br><span class="line">&#123;</span><br><span class="line">	u8 i;</span><br><span class="line">	u8 byte=0;</span><br><span class="line">	I2C_SDA = 1;//释放总线</span><br><span class="line">	</span><br><span class="line">	P4TRIS &amp;= ~(0x20);//设置为输入模式</span><br><span class="line">	</span><br><span class="line">	for(i=0;i&lt;8;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		I2C_SCL = 1;</span><br><span class="line">		I2C_Delay();</span><br><span class="line">		byte &lt;&lt;= 1;</span><br><span class="line">		//读取I2C_SDA上的数据</span><br><span class="line">		if(I2C_SDA)&#123;</span><br><span class="line">			byte++;</span><br><span class="line">		&#125;</span><br><span class="line">		I2C_SCL=0;</span><br><span class="line">		I2C_Delay();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	P4TRIS |= 0x20; //改回输出模式</span><br><span class="line">	P4OD |= 0x20;   //改为开漏输出</span><br><span class="line">	</span><br><span class="line">	return byte;</span><br><span class="line">&#125;</span><br><span class="line">/*****************************************************************************</span><br><span class="line"> ** \brief	 MMA8451Q_write_byte</span><br><span class="line"> ** \param   addr地址 byte数据</span><br><span class="line"> **            	</span><br><span class="line"> ** \return  </span><br><span class="line"> ** \note  写入一个字节数据</span><br><span class="line"> *****************************************************************************/</span><br><span class="line">void MMA8451Q_write_byte(u8 addr, u8 byte)</span><br><span class="line">&#123;</span><br><span class="line">	bit ack=0;</span><br><span class="line">	I2C_Start();</span><br><span class="line">	I2C_Sendbyte(MMA8451Q_WRITE);</span><br><span class="line">	ack=I2C_ReadAck();</span><br><span class="line">	I2C_Sendbyte(addr);</span><br><span class="line">	ack=I2C_ReadAck();</span><br><span class="line">	I2C_Sendbyte(byte);</span><br><span class="line">	ack=I2C_ReadAck();</span><br><span class="line">	I2C_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*****************************************************************************</span><br><span class="line"> ** \brief	 MMA8451Q_read_byte</span><br><span class="line"> ** \param   addr地址 byte数据</span><br><span class="line"> **            	</span><br><span class="line"> ** \return  </span><br><span class="line"> ** \note  读取一个字节数据</span><br><span class="line"> *****************************************************************************/</span><br><span class="line">u8 MMA8451Q_read_byte(u8 addr)</span><br><span class="line">&#123;</span><br><span class="line">	u8 byte=0;</span><br><span class="line">	bit ack=0;	</span><br><span class="line">	u8 i=0;</span><br><span class="line">	I2C_Start();</span><br><span class="line">	I2C_Sendbyte(MMA8451Q_WRITE);</span><br><span class="line">	ack = I2C_ReadAck();</span><br><span class="line">	I2C_Sendbyte(addr);</span><br><span class="line">	ack = I2C_ReadAck();</span><br><span class="line">	I2C_Delay();</span><br><span class="line">	I2C_Start();</span><br><span class="line">	I2C_Sendbyte(MMA8451Q_READ);</span><br><span class="line">	ack=I2C_ReadAck();</span><br><span class="line">	byte=I2C_Readbyte();</span><br><span class="line">	I2C_Stop();</span><br><span class="line">	return byte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完后可以读取传感器中的只读寄存器进行测试。比如WHO_AM_I寄存器，其他传感器要自行查询芯片手册。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>电子</category>
      </categories>
      <tags>
        <tag>电子信息</tag>
      </tags>
  </entry>
  <entry>
    <title>光学薄膜特性理论计算1-菲涅尔公式</title>
    <url>/2024/06/05/2024-6/%E5%85%89%E5%AD%A6%E8%96%84%E8%86%9C%E7%89%B9%E6%80%A7%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%971-%E8%8F%B2%E6%B6%85%E5%B0%94%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>光在界面的传播是薄膜理论的基础，本文从麦克斯韦方程组出发推导菲涅尔公式。</p>
<span id="more"></span>
<h2 id="折射率与光学导纳1">1.折射率与光学导纳<sup>[1]</sup></h2>
<p>麦克斯韦方程组如下</p>
<p><span class="math display">\[
\begin{align}
    % Gauss&#39;s law for electricity
    \nabla \cdot \mathbf{D} &amp;= \rho \nonumber \\
    % Gauss&#39;s law for magnetism
    \nabla \cdot \mathbf{B} &amp;= 0 \nonumber\\
    % Faraday&#39;s law of electromagnetic induction
    \nabla \times \mathbf{E} &amp;= -\frac{\partial \mathbf{B}}{\partial
t} \nonumber\\
    % Ampère&#39;s circuital law with Maxwell&#39;s addition
    \nabla \times \mathbf{H} &amp;=  \mathbf{J} +  \frac{\partial
\mathbf{D}}{\partial t} \nonumber
\end{align}
\]</span></p>
<p>将<span class="math inline">\(D = \varepsilon E\)</span> , <span
class="math inline">\(J = \sigma
E\)</span>代入麦克斯韦方程组的安培环路定律可得</p>
<p><span class="math display">\[
\nabla \times H = \varepsilon \frac{\partial E}{\partial t} + \sigma E
\tag{1-1}
\]</span></p>
<p>对法拉第电感定律两边取旋度并代入(1-1)有</p>
<p><span class="math display">\[
\nabla \times \nabla \times E = - \mu  \frac{\partial (\nabla \times
H)}{\partial t} = - \mu \frac{\partial }{\partial t}(\varepsilon
\frac{\partial E}{\partial t} + \sigma E \tag{1-2})
\]</span></p>
<p>运用矢量恒等式<span class="math inline">\(\nabla \times \nabla \times
E =  \nabla (\nabla\cdot
E)-\nabla^2E\)</span>在无电荷的均匀空间（根据高斯定理<span
class="math inline">\(\nabla \cdot \mathbf{D} =
0\)</span>），上式可以化简为</p>
<p><span class="math display">\[
\nabla^2E = \mu \varepsilon \frac{\partial^2 E}{\partial^2 t} + \mu
\sigma \frac{\partial E}{\partial t} \tag{1-3}
\]</span></p>
<p>如果介质不导电，即<span
class="math inline">\(\sigma=0\)</span>，式(1-3)变为</p>
<p><span class="math display">\[
\nabla^2E = \mu \varepsilon \frac{\partial^2 E}{\partial^2
t}   \tag{1-4}
\]</span></p>
<p>通过求解微分方程，在不导电的均匀介质中，沿x正方向行进的电磁波的表达式可以写成</p>
<p><span class="math display">\[
E = E_0 \exp[i\omega (t-\frac{x}{v})]\tag{1-5}
\]</span></p>
<p>其中<span class="math inline">\(v=1/\sqrt{\mu
\varepsilon}\)</span>是在介质中的传播速度，<span
class="math inline">\(\omega\)</span>是角频率。电池波在真空中传播的速度和在不导电均匀介质中的速度比值，被称为介质的折射率，公式如下：</p>
<p><span class="math display">\[
n = \frac{c}{v}=\frac{\sqrt{\varepsilon \mu}}{\sqrt{\varepsilon_0
\mu_0}} = \sqrt{\varepsilon_r \mu_r}\tag{1-6}
\]</span></p>
<p>在光频率下，光学材料的磁导率可以近似认为是1，所以有<span
class="math inline">\(n=\sqrt{\varepsilon_r}\)</span></p>
<p>式(1-5)可以被认为是式(1-3)的一个特解，对于金属介质（<span
class="math inline">\(\sigma \ne 0\)</span>）,将(1-5)回代，得到</p>
<p><span class="math display">\[
\frac{1}{v^2} = \varepsilon \mu - i\frac{\sigma \mu }{\omega} \tag{1-7}
\]</span></p>
<p>则对于金属介质的折射率有</p>
<p><span class="math display">\[
N^2 = \frac{c^2}{v^2} = (\varepsilon \mu - i\frac{\sigma \mu
}{\omega})/\varepsilon_0 \mu_0 \tag{1-8}
\]</span></p>
<p>可知金属的折射率为复数，记作<span class="math inline">\(N = n -
ik\)</span>，回代入式(1-5)得</p>
<p><span class="math display">\[
E = E_0 \exp{(-\frac{2\pi k x}{\lambda })}\exp{ \left [ i(\omega t -
\frac{2\pi n x}{\lambda})  \right ] }
\]</span></p>
<p>说明对于金属折射率的虚部会让电磁波发生指数级衰减，所以k又被称为吸收系数。</p>
<p>同理，磁场也可以写做波函数的形式，<strong>磁场和电场的表达式如下</strong>：</p>
<p><span class="math display">\[
\mathbf{H} = H_0 \exp{ \left [ i(\omega t - \frac{2\pi N }{\lambda})
\mathbf{S_0} \cdot \mathbf{r}  \right ] }
\]</span></p>
<p><span class="math display">\[
\mathbf{E} = E_0 \exp{ \left [ i(\omega t - \frac{2\pi N }{\lambda})
\mathbf{S_0} \cdot \mathbf{r}  \right ] }
\]</span></p>
<p>其中<span
class="math inline">\(\mathbf{S_0}\)</span>是平面波传播方向的单位矢量，<span
class="math inline">\(\mathbf{r}\)</span>是坐标矢径。</p>
<p>对于<span class="math inline">\(\nabla \times H = -i\frac{2\pi
N}{\lambda}(\mathbf{S_0} \times
\mathbf{H})\)</span>带入麦克斯韦方程组得</p>
<p><span class="math display">\[
\mathbf{S_0} \times \mathbf{H} = -\frac{N\sqrt{\varepsilon _0/\mu_0}
}{\mu_r} \mathbf{E}
\]</span></p>
<p><span class="math display">\[
\frac{N\sqrt{\varepsilon _0/\mu_0} }{\mu_r} \mathbf{S_0} \times
\mathbf{E} = \mathbf{H}
\]</span></p>
<p>上两式说明，电场和磁场是相互垂直的，而且都与传播方向垂直，且符合右手螺旋法则。对于传播过程中，E和H不但相互垂直，且数值间也存在一定比值。</p>
<p><span class="math display">\[
Y = \frac{\left | \mathbf{H} \right | }{\left | \mathbf{S_0 \times E}
\right | } = \frac{N\sqrt{\varepsilon _0 / \mu_0}}{\mu_r}
\]</span></p>
<p>Y被称为介质的光学导纳，其中磁导率<span
class="math inline">\(\mu_r\)</span>通常接近于1，若以自由空间导纳<span
class="math inline">\(\sqrt{\varepsilon _0 /
\mu_0}\)</span>为单位，则光学导纳与折射率相等。</p>
<h2 id="折射反射定律">2.折射反射定律</h2>
<p>根据电磁场的边界条件在界面处E和H的切向分量是连续的，有</p>
<p><span class="math display">\[
E_t^i + E_t^r = E_t^t
\]</span></p>
<p><span class="math display">\[
H_t^i + H_t^r = H_t^t
\]</span></p>
<p><img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/image/202406052131554.png" /></p>
<p>按图中所示，光线在xz平面传播，以<span
class="math inline">\(\theta_0\)</span>的角度入射到界面，界面为<span
class="math inline">\(z=0\)</span>平面。其入射光相位因子为</p>
<p><span class="math display">\[
\exp{\left \{ i\left [ \omega _i t - \frac{2\pi N_0}{\lambda} \left
(  \sin\theta_0 x + \cos \theta_0 z\right ) \right ]  \right \} }
\]</span></p>
<p>设反射光和透射光的相位分别为</p>
<p><span class="math display">\[
\exp{\left \{ i\left [ \omega _i t - \frac{2\pi N_0}{\lambda} \left
(  \alpha_r x +\beta_r y+ \gamma_r z\right ) \right ]  \right \} }
\]</span></p>
<p><span class="math display">\[
\exp{\left \{ i\left [ \omega _i t - \frac{2\pi N_1}{\lambda} \left
(  \alpha_t x +\beta_t y+ \gamma_t z\right ) \right ]  \right \} }
\]</span></p>
<p>要满足边界条件，界面上的相位因子必须相等。所以有<span
class="math inline">\(\beta_r = \beta_t = 0\)</span>、<span
class="math inline">\(N_0 \alpha_i = N_0 \alpha_r = N_1
\alpha_t\)</span></p>
<p>可以得出反射和折射定律</p>
<p><span class="math display">\[
\theta_0 = \theta_r
\]</span></p>
<p><span class="math display">\[
N_0 \sin \theta_0 = N_1 \sin \theta_t
\]</span></p>
<h2 id="菲涅尔公式">3.菲涅尔公式</h2>
<h3 id="垂直入射情况">3.1 垂直入射情况</h3>
<p>为进一步研究反射光和入射光振幅和相位的变化关系，我们先假设光是垂直入射界面的。</p>
<p>对于垂直入射界面的光，显然有E和H都是平行于界面，有 <span
class="math display">\[
H_1 = H_t , E_1 = E_t
\]</span></p>
<p>又根据边界条件有</p>
<p><span class="math display">\[
E_1 = E_0^+ + E_0^-
\]</span></p>
<p><span class="math display">\[
H_1 = H_0^+ + H_0^-
\]</span></p>
<p>其中下标0和1代表界面的两边，上标+代表正向传播，-代表反向传播。结合上式有</p>
<p><span class="math display">\[
H_1 = N_1(S_0 \times E_1) = N_0(S_0 \times E_0^+ - S_0 \times E^-_0)
\]</span></p>
<p>即</p>
<p><span class="math display">\[
N_1 E_1 = N_0 (E_0^+ - E_0^-)
\]</span></p>
<p>化简可得反射系数和透射系数</p>
<p><span class="math display">\[
r = \frac{E_0^-}{E_0^+} = \frac{N_0-N_1}{N_0+N_1}
\]</span></p>
<p><span class="math display">\[
t = \frac{E_1}{E_0^+} = \frac{2N_0}{N_0 + N_1}
\]</span></p>
<h3 id="倾斜入射情况">3.2 倾斜入射情况</h3>
<p>下面考虑倾斜入射的情况。我们将入射的电磁波分解为，电场垂直反射面（s光）和平行反射面（p光）振动的两种状态。</p>
<p><img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/image/202406052138385.png" /></p>
<p>为方便定义切向分量，现引入有效导纳的概念</p>
<p><span class="math display">\[
\eta = H_t^+ / (S_0 \times E_t^+)
\]</span></p>
<p>对于p光（TM波），磁场H垂直于入射面，与界面平行，因此<span
class="math inline">\(H = H_t\)</span>，而电场<span
class="math inline">\(E=Ecos \theta\)</span></p>
<p><span class="math display">\[
H_t = H = N(S_0 \times E) = N(r_0 \times E_t/cos\theta) =
\frac{N}{cos\theta}(r_0 \times E_t)
\]</span></p>
<p>所以对于p光有<span class="math inline">\(\eta_p = N/cos
\theta\)</span>,同理对于s光有<span class="math inline">\(\eta_s = Ncos
\theta\)</span></p>
<p>对菲涅尔反射系数可以写作</p>
<p><span class="math display">\[
r_p = \frac{\eta_{0p}-\eta_{1p}}{\eta_{0p}+\eta_{1p}} =
\frac{N_0cos\theta_1 - N_1 cos\theta_0}{N_0cos\theta_1 + N_1
cos\theta_0}
\]</span></p>
<p><span class="math display">\[
r_s = \frac{\eta_{0s}-\eta_{1s}}{\eta_{0s}+\eta_{1s}} =
\frac{N_0cos\theta_0 - N_1 cos\theta_1}{N_0cos\theta_0 + N_1
cos\theta_1}
\]</span></p>
<p>对于透射系数可以写作</p>
<p><span class="math display">\[
t_p = \frac{2N_0cos\theta_0}{N_0cos\theta_1+N_1cos\theta_0}
\]</span></p>
<p><span class="math display">\[
t_s = \frac{2N_0cos\theta_0}{N_0cos\theta_0 + N_1cos\theta_1}
\]</span></p>
<p>反射率为</p>
<p><span class="math display">\[
R = r^2
\]</span></p>
<p>透射率为</p>
<p><span class="math display">\[
T = \frac{N_1cos\theta_1}{N_0cos\theta_0}|t^2|
\]</span></p>
<p>该公式对复折射率介质也同样成立。</p>
<p>给出计算代码如下，其中函数公式中符号相反只影响相位，并不影响透射和反射率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Fresnel</span>(<span class="params">n1, n2, theta1</span>):</span><br><span class="line">    <span class="comment"># 角度转弧度</span></span><br><span class="line">    theta1 = theta1 /<span class="number">180</span> * np.pi</span><br><span class="line">    costheta1 = np.cos(theta1)</span><br><span class="line">    n1_r = n1.real</span><br><span class="line">    n2_r = n2.real</span><br><span class="line">    costheta2_2 = <span class="number">1</span>-(n1_r/n2_r*np.sin(theta1))**<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> costheta2_2 &gt;= <span class="number">0</span>:</span><br><span class="line">        costheta2 = np.sqrt(costheta2_2)</span><br><span class="line">        rp = (n2*costheta1 - n1*costheta2)/(n2*costheta1 + n1*costheta2)</span><br><span class="line">        rs = (n1*costheta1 - n2*costheta2)/(n1*costheta1 + n2*costheta2)</span><br><span class="line">        tp = (<span class="number">2</span>*n1*costheta1)/(n1*costheta2+n2*costheta1)</span><br><span class="line">        ts = (<span class="number">2</span>*n1*costheta1)/(n1*costheta1+n2*costheta2)    </span><br><span class="line">        temp = n2*costheta2/(n1*costheta1)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#发生了全反射</span></span><br><span class="line">        rp = <span class="number">1.0</span></span><br><span class="line">        rs = <span class="number">1.0</span></span><br><span class="line">        tp = <span class="number">0.0</span></span><br><span class="line">        ts = <span class="number">0.0</span></span><br><span class="line">        temp = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rp**<span class="number">2</span>, rs**<span class="number">2</span>, temp*(tp**<span class="number">2</span>),temp*(ts**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">theta_ls = np.linspace(<span class="number">0</span>, <span class="number">90</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">N_Bk7 = <span class="number">1.5214145</span></span><br><span class="line">N_air = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p光数据</span></span><br><span class="line">Rp_ls = []</span><br><span class="line">Tp_ls = []</span><br><span class="line"><span class="comment"># s光数据</span></span><br><span class="line">Rs_ls = []</span><br><span class="line">Ts_ls = []</span><br><span class="line"><span class="comment"># 平均数据</span></span><br><span class="line">Avg_r_ls = []</span><br><span class="line">Avg_t_ls = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 吸收计算，暂时为 0</span></span><br><span class="line">absorb = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> theta <span class="keyword">in</span> theta_ls:</span><br><span class="line">    Rp,Rs,Tp,Ts = Fresnel(N_air,N_Bk7,theta)</span><br><span class="line">    Rp_ls.append(Rp)</span><br><span class="line">    Rs_ls.append(Rs)</span><br><span class="line">    Tp_ls.append(Tp)</span><br><span class="line">    Ts_ls.append(Ts)</span><br><span class="line">    Avg_r_ls.append((Rp+Rs)/<span class="number">2</span>)</span><br><span class="line">    Avg_t_ls.append((Tp+Ts)/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.plot(theta_ls,Rp_ls,color=<span class="string">&quot;green&quot;</span>,label = <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">plt.plot(theta_ls,Rs_ls,color=<span class="string">&quot;blue&quot;</span>,label = <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">plt.plot(theta_ls,Avg_r_ls,color=<span class="string">&quot;red&quot;</span>,label = <span class="string">&#x27;avg&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper left&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;R&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">2</span>)</span><br><span class="line">plt.plot(theta_ls,Tp_ls,color=<span class="string">&quot;green&quot;</span>,label = <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">plt.plot(theta_ls,Ts_ls,color=<span class="string">&quot;blue&quot;</span>,label = <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">plt.plot(theta_ls,Avg_t_ls,color=<span class="string">&quot;red&quot;</span>,label = <span class="string">&#x27;avg&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper left&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;T&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="全反射情况">3.3 全反射情况</h3>
<p>这里只给出相位公式，公式来着参考资料[1]</p>
<p><span class="math display">\[
\tan \frac{1}{2}\varphi _s = \frac{(\sin^2\theta_0 -
n_1^2/n_0^2)^{1/2}}{\cos \theta_0}
\]</span></p>
<p><span class="math display">\[
\tan \frac{1}{2}\varphi _p = \frac{n_1^2/n_0^2 \cdot
\cos\theta_0}{(\sin^2\theta_0 - n_1^2/n_0^2)^{1/2}}
\]</span></p>
<p>但在使用zemax仿真时，发现相位不需要乘2数值才是匹配的，源码和仿真结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Phase</span>(<span class="params">n1, n2, theta1</span>):</span><br><span class="line">    <span class="comment"># 角度转弧度</span></span><br><span class="line">    theta1 = theta1 /<span class="number">180</span> * np.pi</span><br><span class="line">    costheta1 = np.cos(theta1)</span><br><span class="line">    n1_r = n1.real</span><br><span class="line">    n2_r = n2.real</span><br><span class="line">    costheta2_2 = <span class="number">1</span>-(n1_r/n2_r*np.sin(theta1))**<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> costheta2_2 &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> n1 &gt; n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#全反射</span></span><br><span class="line">        tande_s = np.sqrt(np.sin(theta1)**<span class="number">2</span>-n2**<span class="number">2</span>/n1**<span class="number">2</span>)/costheta1</span><br><span class="line">        a = (n2**<span class="number">2</span>)/(n1**<span class="number">2</span>) * (costheta1)</span><br><span class="line">        b = np.sqrt(np.sin(theta1)**<span class="number">2</span> - n2**<span class="number">2</span>/n1**<span class="number">2</span>)</span><br><span class="line">        tande_p = -(a)/(b)</span><br><span class="line">        <span class="keyword">return</span> np.arctan(tande_p)/np.pi*<span class="number">180</span>,np.arctan(tande_s)/np.pi*<span class="number">180</span></span><br><span class="line"></span><br><span class="line">theta_ls = np.linspace(<span class="number">0</span>, <span class="number">90</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">N_Bk7 = <span class="number">1.5214145</span></span><br><span class="line">N_air = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p光数据</span></span><br><span class="line">Rp_ls = []</span><br><span class="line">Tp_ls = []</span><br><span class="line"><span class="comment"># s光数据</span></span><br><span class="line">Rs_ls = []</span><br><span class="line">Ts_ls = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> theta <span class="keyword">in</span> theta_ls:</span><br><span class="line">    dep,des = Phase(N_Bk7, N_air, theta)</span><br><span class="line">    Rp_ls.append(dep)</span><br><span class="line">    Rs_ls.append(des)</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.plot(theta_ls,Rp_ls,color=<span class="string">&quot;green&quot;</span>,label = <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">plt.plot(theta_ls,Rs_ls,color=<span class="string">&quot;blue&quot;</span>,label = <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/image/202406052139055.png"
alt="全反射" />
<figcaption aria-hidden="true">全反射</figcaption>
</figure>
<h2 id="参考资料">参考资料</h2>
<p>[1] 唐晋发.现代光学薄膜技术.浙江大学出版社.2006年</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>物理</category>
      </categories>
      <tags>
        <tag>光学</tag>
        <tag>薄膜</tag>
      </tags>
  </entry>
  <entry>
    <title>光学薄膜特性理论计算2-传输矩阵法</title>
    <url>/2024/06/05/2024-6/%E5%85%89%E5%AD%A6%E8%96%84%E8%86%9C%E7%89%B9%E6%80%A7%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%972-%E4%BC%A0%E8%BE%93%E7%9F%A9%E9%98%B5%E6%B3%95/</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>本文通过等效导纳的方法，推导出薄膜的特征矩阵并给出了数值计算方法。</p>
<span id="more"></span>
<h2 id="单层介质薄膜">1.单层介质薄膜</h2>
<h3 id="特征矩阵">1.1 特征矩阵</h3>
<p>单层薄膜的两个界面在数学上可以使用一个等效界面来表示，我们记等效后的导纳为组合导纳Y。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/image/202406052141974.png"
alt="膜层等效" />
<figcaption aria-hidden="true">膜层等效</figcaption>
</figure>
<p>因此单层膜的反射系数可以表示为</p>
<p><span class="math display">\[
r = (\eta_0 - Y)/(\eta_0 + Y)
\]</span></p>
<p>下面只需要计算有效导纳，将所有同方向的取相同符号，对于边界条件有</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/image/202406052142478.png"
alt="单层膜电场" />
<figcaption aria-hidden="true">单层膜电场</figcaption>
</figure>
<p><span class="math display">\[
E_0 = E_0^+ + E_0^- = E_{11}^+ + E_{11}^-
\]</span></p>
<p><span class="math display">\[
H_0 = H_0^+ +H_0^- = \eta_1 E_{11}^+ - \eta_1 E_{11}^-
\]</span></p>
<p>在薄膜上传播的波会出现相位差，所以记</p>
<p><span class="math display">\[
E_0 = E_{12}^+ e^{-i\delta_1} +E_{12}^- e^{i\delta_1}
\]</span></p>
<p><span class="math display">\[
H_0 = \eta_1 e^{-i \delta_1 } E_{12}^+ - \eta_1 e^{-i \delta_1 }E_{12}^-
\]</span></p>
<p>用矩阵表示</p>
<p><span class="math display">\[
\begin{bmatrix}
E_0\\
H_0
\end{bmatrix} = \begin{bmatrix}
e^{- i \delta_1 } &amp; e^{i \delta_1}\\
\eta_1 e^{-i \delta_1 }  &amp; - \eta_1 e^{i \delta_1 }
\end{bmatrix}
\begin{bmatrix}
E_{12}^+\\
E_{12}^-
\end{bmatrix}
\]</span></p>
<p>同理在界面2处有</p>
<p><span class="math display">\[
E_2 = E_{12}^+ +E_{12}^-
\]</span></p>
<p><span class="math display">\[
H_2 = \eta_1 E_{12}^+ - \eta_1 E_{12}^-
\]</span></p>
<p>用矩阵表示</p>
<p><span class="math display">\[
\begin{bmatrix}
E_{12}^+\\
E_{12}^-
\end{bmatrix} = \begin{bmatrix}
\frac{1}{2} &amp; \frac{1}{2 \eta_1} \\
\frac{1}{2}  &amp; - \frac{1}{2 \eta_1}
\end{bmatrix}\begin{bmatrix}
E_2\\
H_2
\end{bmatrix}
\]</span></p>
<p>两式合并</p>
<p><span class="math display">\[
\begin{bmatrix}
E_0\\
H_0
\end{bmatrix} = \begin{bmatrix}
e^{-i \delta_1 } &amp; e^{i \delta_1}\\
\eta_1 e^{-i \delta_1 }  &amp; - \eta_1 e^{i \delta_1 }
\end{bmatrix}
\begin{bmatrix}
\frac{1}{2} &amp; \frac{1}{2 \eta_1} \\
\frac{1}{2}  &amp; - \frac{1}{2 \eta_1}
\end{bmatrix}=\begin{bmatrix}
\cos{\delta_1} &amp; -\frac{i}{\eta_1} \sin{\delta_1} \\
{-i\eta_1} \sin{\delta_1}  &amp; \cos{\delta_1}
\end{bmatrix}\begin{bmatrix}
E_2\\
H_2
\end{bmatrix}
\]</span></p>
<p>等效导纳为<span class="math inline">\(Y =
H_0/E_0\)</span>，上式也可以写作</p>
<p><span class="math display">\[
E_0\begin{bmatrix}
1\\
Y
\end{bmatrix} =\begin{bmatrix}
\cos{\delta_1} &amp; -\frac{i}{\eta_1} \sin{\delta_1} \\
{-i\eta_1} \sin{\delta_1}  &amp; \cos{\delta_1}
\end{bmatrix}\begin{bmatrix}
1\\
\eta_2
\end{bmatrix}E_2
\]</span></p>
<p>矩阵<span class="math inline">\(\begin{bmatrix}
\cos{\delta_1} &amp; -\frac{i}{\eta_j} \sin{\delta_j} \\
{-i\eta_j} \sin{\delta_j}  &amp; \cos{\delta_j}
\end{bmatrix}\)</span>被定义为膜层的特征矩阵。</p>
<h3 id="仿真代码">1.2 仿真代码</h3>
<p>下面给出单层膜计算的流程图和matlab仿真代码，其中透反射与zemax仿真结果一致，</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/image/202406052142046.png"
alt="单层膜计算流程图" />
<figcaption aria-hidden="true">单层膜计算流程图</figcaption>
</figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 传输矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[Ms,Mp]</span> = <span class="title">GET_single_TRM</span><span class="params">(n0,n,d,wavelength,theta0)</span></span></span><br><span class="line"><span class="comment">% 入射介质折射率 中间层折射率 中间层厚度 中间层折射率波长 入射角</span></span><br><span class="line"></span><br><span class="line">costheta1 = <span class="built_in">sqrt</span>(<span class="number">1</span>-(n0^<span class="number">2</span>*<span class="built_in">sin</span>(theta0)^<span class="number">2</span>)/(n^<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">deta = (<span class="number">2</span>*<span class="built_in">pi</span>/wavelength)*(n*d*costheta1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eta_p1 = n/costheta1;</span><br><span class="line">eta_s1 = n*costheta1;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算s光传输矩阵</span></span><br><span class="line">a1 = <span class="built_in">cos</span>(deta);</span><br><span class="line">a2 = <span class="number">-1</span><span class="built_in">i</span>*<span class="built_in">sin</span>(deta)/eta_s1;</span><br><span class="line">a3 = <span class="number">-1</span><span class="built_in">i</span>*<span class="built_in">sin</span>(deta)*eta_s1;</span><br><span class="line">a4 = <span class="built_in">cos</span>(deta);</span><br><span class="line">Ms = [a1,a2;a3,a4];</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算p光传输矩阵</span></span><br><span class="line">a1 = <span class="built_in">cos</span>(deta);</span><br><span class="line">a2 = <span class="number">-1</span><span class="built_in">i</span>*<span class="built_in">sin</span>(deta)/eta_p1;</span><br><span class="line">a3 = <span class="number">-1</span><span class="built_in">i</span>*<span class="built_in">sin</span>(deta)*eta_p1;</span><br><span class="line">a4 = <span class="built_in">cos</span>(deta);</span><br><span class="line">Mp = [a1,a2;a3,a4];</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">close all</span><br><span class="line"><span class="comment">% 定义参数 单位微米</span></span><br><span class="line">theta_ls = <span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">90</span>, <span class="number">500</span>);</span><br><span class="line">wavelength = <span class="number">0.55</span>;</span><br><span class="line">N_BK7 = <span class="number">1.5214145</span>;</span><br><span class="line">N_air = <span class="number">1</span>;</span><br><span class="line">N_my = <span class="number">1.38</span>;</span><br><span class="line">N_AL = <span class="number">0.7</span>+ <span class="number">7</span><span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">n0 = N_air;</span><br><span class="line">ns = N_air;</span><br><span class="line"><span class="comment">%d = wavelength/N_BK7*0.25;</span></span><br><span class="line">d = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 申请空间</span></span><br><span class="line"><span class="comment">% theta_ls = 0;</span></span><br><span class="line">Rs = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta_ls));</span><br><span class="line">Rp = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta_ls));</span><br><span class="line">Ts = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta_ls));</span><br><span class="line">Tp = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta_ls));</span><br><span class="line">S_phi_R = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta_ls));</span><br><span class="line">P_phi_R = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta_ls));</span><br><span class="line">S_phi_T = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta_ls));</span><br><span class="line">P_phi_T = <span class="built_in">zeros</span>(<span class="built_in">size</span>(theta_ls));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx = <span class="number">1</span>:<span class="built_in">numel</span>(theta_ls)</span><br><span class="line">    theta0 = theta_ls(idx);</span><br><span class="line">    theta0 = deg2rad(theta0);</span><br><span class="line">    [Ms,Mp] = GET_single_TRM(N_air,N_BK7,d,wavelength,theta0);</span><br><span class="line"></span><br><span class="line">    eta_p0 = n0/<span class="built_in">cos</span>(theta0);</span><br><span class="line">    eta_s0 = n0*<span class="built_in">cos</span>(theta0);</span><br><span class="line">    costhetas = <span class="built_in">sqrt</span>(<span class="number">1</span>-n0^<span class="number">2</span>*<span class="built_in">sin</span>(theta0)^<span class="number">2</span>/(ns^<span class="number">2</span>));</span><br><span class="line">    eta_ps = ns/costhetas;</span><br><span class="line">    eta_ss = ns*costhetas;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% s光</span></span><br><span class="line">    combMYs = Ms*[<span class="number">1</span>;eta_ss];</span><br><span class="line">    ys = combMYs(<span class="number">2</span>)/combMYs(<span class="number">1</span>);</span><br><span class="line">    rs = (eta_s0 - ys)/(eta_s0 + ys);</span><br><span class="line">    Rs(idx) = <span class="built_in">abs</span>(rs)^<span class="number">2</span>;</span><br><span class="line">    <span class="comment">% 势透射率</span></span><br><span class="line">    Psi = <span class="built_in">real</span>(eta_ss)/<span class="built_in">real</span>((combMYs(<span class="number">1</span>))*(<span class="built_in">conj</span>(combMYs(<span class="number">2</span>))));</span><br><span class="line">    Ts(idx) = (<span class="number">1</span> - Rs(idx))*Psi;</span><br><span class="line">    S_phi_R(idx) = <span class="built_in">angle</span>(rs)/<span class="built_in">pi</span>*<span class="number">180</span>;</span><br><span class="line">    <span class="comment">% p光</span></span><br><span class="line">    combMYp = Mp*[<span class="number">1</span>;eta_ps];</span><br><span class="line">    yp = combMYp(<span class="number">2</span>)/combMYp(<span class="number">1</span>);</span><br><span class="line">    rp = (eta_p0 - yp)/(eta_p0 + yp);</span><br><span class="line">    Rp(idx) = <span class="built_in">abs</span>(rp)^<span class="number">2</span>;</span><br><span class="line">    Psi = <span class="built_in">real</span>(eta_ps)/<span class="built_in">real</span>((combMYp(<span class="number">1</span>))*(<span class="built_in">conj</span>(combMYp(<span class="number">2</span>))));</span><br><span class="line">    Tp(idx) = (<span class="number">1</span>-Rp(idx))*Psi;</span><br><span class="line">    P_phi_R(idx) = <span class="built_in">angle</span>(rp)/<span class="built_in">pi</span>*<span class="number">180</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(theta_ls, Rs);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(theta_ls, Rp);</span><br><span class="line"><span class="built_in">plot</span>(theta_ls,(Rs+Rp)/<span class="number">2</span>);</span><br><span class="line">title(<span class="string">&#x27;Reflectivity&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(theta_ls,Ts);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(theta_ls,Tp);</span><br><span class="line"><span class="built_in">plot</span>(theta_ls,(Ts+Tp)/<span class="number">2</span>);</span><br><span class="line">title(<span class="string">&#x27;transmission&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>当把薄膜的有效光学厚度改为1/4波长的整数倍时候，如<code>theta0 = 0;</code>时、<code>d = wavelength/N_BK7*0.25;</code>在参考波长处传输矩阵会变成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ms =</span><br><span class="line"></span><br><span class="line">   0.0000 + 0.0000i   0.0000 - 0.6573i</span><br><span class="line">   0.0000 - 1.5214i   0.0000 + 0.0000i</span><br><span class="line"></span><br><span class="line">Mp =</span><br><span class="line"></span><br><span class="line">   0.0000 + 0.0000i   0.0000 - 0.6573i</span><br><span class="line">   0.0000 - 1.5214i   0.0000 + 0.0000i</span><br></pre></td></tr></table></figure>
<p>奇数倍时，特征矩阵的主对角线为0，此时膜系对透射和反射特性没有任何影响，被称为“虚设层”，而偶数倍时，会出现反射率的极值。厚度与反透射变化关系如下图，入射角为0度，横坐标单位为一个波长。</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/image/202406052143736.png"
alt="厚度和反透射关系" />
<figcaption aria-hidden="true">厚度和反透射关系</figcaption>
</figure>
<h2 id="传输矩阵法">2.传输矩阵法</h2>
<p>多层膜的计算方法和单层膜相似，使用特征矩阵方法计算，特征矩阵如下：</p>
<p><span class="math display">\[
\prod_{j=1}^{K} \begin{bmatrix}
\cos{\delta_j} &amp; -\frac{i}{\eta_j} \sin{\delta_j} \\
{-i\eta_j} \sin{\delta_j}  &amp; \cos{\delta_j}
\end{bmatrix}
\]</span></p>
<p>总体计算流程图如下</p>
<figure>
<img
src="https://myblog-1307904772.cos.ap-shanghai.myqcloud.com/image/202406052144814.png"
alt="流程图" />
<figcaption aria-hidden="true">流程图</figcaption>
</figure>
<p>多层膜与单层类似，只需要多加一个循环即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% 循环膜层</span><br><span class="line">for idx2 = 1:numel(n_ls)</span><br><span class="line">    nj = n_ls(idx2);</span><br><span class="line">    dj = d_ls(idx2);            </span><br><span class="line">    [Ms,Mp] = GET_single_TRM(n0,nj,dj,wavelength,theta0);</span><br><span class="line">    if idx2 == 1</span><br><span class="line">        Ms_all = Ms;</span><br><span class="line">        Mp_all = Mp;</span><br><span class="line">    else</span><br><span class="line">        Ms_all = Ms_all * Ms;</span><br><span class="line">        Mp_all = Mp_all * Mp;</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<p>[1] 唐晋发.现代光学薄膜技术.浙江大学出版社.2006年</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>物理</category>
      </categories>
      <tags>
        <tag>光学</tag>
        <tag>薄膜</tag>
      </tags>
  </entry>
</search>
